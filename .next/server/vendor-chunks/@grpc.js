"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@grpc";
exports.ids = ["vendor-chunks/@grpc"];
exports.modules = {

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/admin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2021 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.addAdminServicesToServer = exports.registerAdminService = void 0;\r\nconst registeredAdminServices = [];\r\nfunction registerAdminService(getServiceDefinition, getHandlers) {\r\n    registeredAdminServices.push({ getServiceDefinition, getHandlers });\r\n}\r\nexports.registerAdminService = registerAdminService;\r\nfunction addAdminServicesToServer(server) {\r\n    for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {\r\n        server.addService(getServiceDefinition(), getHandlers());\r\n    }\r\n}\r\nexports.addAdminServicesToServer = addAdminServicesToServer;\r\n//# sourceMappingURL=admin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyw0QkFBNEI7QUFDL0Q7QUFDQTtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanM/YmVlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIgPSBleHBvcnRzLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlID0gdm9pZCAwO1xyXG5jb25zdCByZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcyA9IFtdO1xyXG5mdW5jdGlvbiByZWdpc3RlckFkbWluU2VydmljZShnZXRTZXJ2aWNlRGVmaW5pdGlvbiwgZ2V0SGFuZGxlcnMpIHtcclxuICAgIHJlZ2lzdGVyZWRBZG1pblNlcnZpY2VzLnB1c2goeyBnZXRTZXJ2aWNlRGVmaW5pdGlvbiwgZ2V0SGFuZGxlcnMgfSk7XHJcbn1cclxuZXhwb3J0cy5yZWdpc3RlckFkbWluU2VydmljZSA9IHJlZ2lzdGVyQWRtaW5TZXJ2aWNlO1xyXG5mdW5jdGlvbiBhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIoc2VydmVyKSB7XHJcbiAgICBmb3IgKGNvbnN0IHsgZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzIH0gb2YgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMpIHtcclxuICAgICAgICBzZXJ2ZXIuYWRkU2VydmljZShnZXRTZXJ2aWNlRGVmaW5pdGlvbigpLCBnZXRIYW5kbGVycygpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmFkZEFkbWluU2VydmljZXNUb1NlcnZlciA9IGFkZEFkbWluU2VydmljZXNUb1NlcnZlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRtaW4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BackoffTimeout = void 0;\r\nconst INITIAL_BACKOFF_MS = 1000;\r\nconst BACKOFF_MULTIPLIER = 1.6;\r\nconst MAX_BACKOFF_MS = 120000;\r\nconst BACKOFF_JITTER = 0.2;\r\n/**\r\n * Get a number uniformly at random in the range [min, max)\r\n * @param min\r\n * @param max\r\n */\r\nfunction uniformRandom(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n}\r\nclass BackoffTimeout {\r\n    constructor(callback, options) {\r\n        this.callback = callback;\r\n        /**\r\n         * The delay time at the start, and after each reset.\r\n         */\r\n        this.initialDelay = INITIAL_BACKOFF_MS;\r\n        /**\r\n         * The exponential backoff multiplier.\r\n         */\r\n        this.multiplier = BACKOFF_MULTIPLIER;\r\n        /**\r\n         * The maximum delay time\r\n         */\r\n        this.maxDelay = MAX_BACKOFF_MS;\r\n        /**\r\n         * The maximum fraction by which the delay time can randomly vary after\r\n         * applying the multiplier.\r\n         */\r\n        this.jitter = BACKOFF_JITTER;\r\n        /**\r\n         * Indicates whether the timer is currently running.\r\n         */\r\n        this.running = false;\r\n        /**\r\n         * Indicates whether the timer should keep the Node process running if no\r\n         * other async operation is doing so.\r\n         */\r\n        this.hasRef = true;\r\n        /**\r\n         * The time that the currently running timer was started. Only valid if\r\n         * running is true.\r\n         */\r\n        this.startTime = new Date();\r\n        /**\r\n         * The approximate time that the currently running timer will end. Only valid\r\n         * if running is true.\r\n         */\r\n        this.endTime = new Date();\r\n        if (options) {\r\n            if (options.initialDelay) {\r\n                this.initialDelay = options.initialDelay;\r\n            }\r\n            if (options.multiplier) {\r\n                this.multiplier = options.multiplier;\r\n            }\r\n            if (options.jitter) {\r\n                this.jitter = options.jitter;\r\n            }\r\n            if (options.maxDelay) {\r\n                this.maxDelay = options.maxDelay;\r\n            }\r\n        }\r\n        this.nextDelay = this.initialDelay;\r\n        this.timerId = setTimeout(() => { }, 0);\r\n        clearTimeout(this.timerId);\r\n    }\r\n    runTimer(delay) {\r\n        var _a, _b;\r\n        this.endTime = this.startTime;\r\n        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);\r\n        clearTimeout(this.timerId);\r\n        this.timerId = setTimeout(() => {\r\n            this.callback();\r\n            this.running = false;\r\n        }, delay);\r\n        if (!this.hasRef) {\r\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n    }\r\n    /**\r\n     * Call the callback after the current amount of delay time\r\n     */\r\n    runOnce() {\r\n        this.running = true;\r\n        this.startTime = new Date();\r\n        this.runTimer(this.nextDelay);\r\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\r\n        const jitterMagnitude = nextBackoff * this.jitter;\r\n        this.nextDelay =\r\n            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\r\n    }\r\n    /**\r\n     * Stop the timer. The callback will not be called until `runOnce` is called\r\n     * again.\r\n     */\r\n    stop() {\r\n        clearTimeout(this.timerId);\r\n        this.running = false;\r\n    }\r\n    /**\r\n     * Reset the delay time to its initial value. If the timer is still running,\r\n     * retroactively apply that reset to the current timer.\r\n     */\r\n    reset() {\r\n        this.nextDelay = this.initialDelay;\r\n        if (this.running) {\r\n            const now = new Date();\r\n            const newEndTime = this.startTime;\r\n            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\r\n            clearTimeout(this.timerId);\r\n            if (now < newEndTime) {\r\n                this.runTimer(newEndTime.getTime() - now.getTime());\r\n            }\r\n            else {\r\n                this.running = false;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Check whether the timer is currently running.\r\n     */\r\n    isRunning() {\r\n        return this.running;\r\n    }\r\n    /**\r\n     * Set that while the timer is running, it should keep the Node process\r\n     * running.\r\n     */\r\n    ref() {\r\n        var _a, _b;\r\n        this.hasRef = true;\r\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    }\r\n    /**\r\n     * Set that while the timer is running, it should not keep the Node process\r\n     * running.\r\n     */\r\n    unref() {\r\n        var _a, _b;\r\n        this.hasRef = false;\r\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    }\r\n    /**\r\n     * Get the approximate timestamp of when the timer will fire. Only valid if\r\n     * this.isRunning() is true.\r\n     */\r\n    getEndTime() {\r\n        return this.endTime;\r\n    }\r\n}\r\nexports.BackoffTimeout = BackoffTimeout;\r\n//# sourceMappingURL=backoff-timeout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2JhY2tvZmYtdGltZW91dC5qcz8xODRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkJhY2tvZmZUaW1lb3V0ID0gdm9pZCAwO1xyXG5jb25zdCBJTklUSUFMX0JBQ0tPRkZfTVMgPSAxMDAwO1xyXG5jb25zdCBCQUNLT0ZGX01VTFRJUExJRVIgPSAxLjY7XHJcbmNvbnN0IE1BWF9CQUNLT0ZGX01TID0gMTIwMDAwO1xyXG5jb25zdCBCQUNLT0ZGX0pJVFRFUiA9IDAuMjtcclxuLyoqXHJcbiAqIEdldCBhIG51bWJlciB1bmlmb3JtbHkgYXQgcmFuZG9tIGluIHRoZSByYW5nZSBbbWluLCBtYXgpXHJcbiAqIEBwYXJhbSBtaW5cclxuICogQHBhcmFtIG1heFxyXG4gKi9cclxuZnVuY3Rpb24gdW5pZm9ybVJhbmRvbShtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcclxufVxyXG5jbGFzcyBCYWNrb2ZmVGltZW91dCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGVsYXkgdGltZSBhdCB0aGUgc3RhcnQsIGFuZCBhZnRlciBlYWNoIHJlc2V0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbERlbGF5ID0gSU5JVElBTF9CQUNLT0ZGX01TO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBleHBvbmVudGlhbCBiYWNrb2ZmIG11bHRpcGxpZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gQkFDS09GRl9NVUxUSVBMSUVSO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYXhpbXVtIGRlbGF5IHRpbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1heERlbGF5ID0gTUFYX0JBQ0tPRkZfTVM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1heGltdW0gZnJhY3Rpb24gYnkgd2hpY2ggdGhlIGRlbGF5IHRpbWUgY2FuIHJhbmRvbWx5IHZhcnkgYWZ0ZXJcclxuICAgICAgICAgKiBhcHBseWluZyB0aGUgbXVsdGlwbGllci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmppdHRlciA9IEJBQ0tPRkZfSklUVEVSO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0aW1lciBpcyBjdXJyZW50bHkgcnVubmluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGltZXIgc2hvdWxkIGtlZXAgdGhlIE5vZGUgcHJvY2VzcyBydW5uaW5nIGlmIG5vXHJcbiAgICAgICAgICogb3RoZXIgYXN5bmMgb3BlcmF0aW9uIGlzIGRvaW5nIHNvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGFzUmVmID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGltZSB0aGF0IHRoZSBjdXJyZW50bHkgcnVubmluZyB0aW1lciB3YXMgc3RhcnRlZC4gT25seSB2YWxpZCBpZlxyXG4gICAgICAgICAqIHJ1bm5pbmcgaXMgdHJ1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFwcHJveGltYXRlIHRpbWUgdGhhdCB0aGUgY3VycmVudGx5IHJ1bm5pbmcgdGltZXIgd2lsbCBlbmQuIE9ubHkgdmFsaWRcclxuICAgICAgICAgKiBpZiBydW5uaW5nIGlzIHRydWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbml0aWFsRGVsYXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbERlbGF5ID0gb3B0aW9ucy5pbml0aWFsRGVsYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubXVsdGlwbGllcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gb3B0aW9ucy5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmppdHRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5qaXR0ZXIgPSBvcHRpb25zLmppdHRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYXhEZWxheSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZWxheSA9IG9wdGlvbnMubWF4RGVsYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5uZXh0RGVsYXkgPSB0aGlzLmluaXRpYWxEZWxheTtcclxuICAgICAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XHJcbiAgICB9XHJcbiAgICBydW5UaW1lcihkZWxheSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gdGhpcy5zdGFydFRpbWU7XHJcbiAgICAgICAgdGhpcy5lbmRUaW1lLnNldE1pbGxpc2Vjb25kcyh0aGlzLmVuZFRpbWUuZ2V0TWlsbGlzZWNvbmRzKCkgKyB0aGlzLm5leHREZWxheSk7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XHJcbiAgICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgIGlmICghdGhpcy5oYXNSZWYpIHtcclxuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy50aW1lcklkKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbCB0aGUgY2FsbGJhY2sgYWZ0ZXIgdGhlIGN1cnJlbnQgYW1vdW50IG9mIGRlbGF5IHRpbWVcclxuICAgICAqL1xyXG4gICAgcnVuT25jZSgpIHtcclxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICB0aGlzLnJ1blRpbWVyKHRoaXMubmV4dERlbGF5KTtcclxuICAgICAgICBjb25zdCBuZXh0QmFja29mZiA9IE1hdGgubWluKHRoaXMubmV4dERlbGF5ICogdGhpcy5tdWx0aXBsaWVyLCB0aGlzLm1heERlbGF5KTtcclxuICAgICAgICBjb25zdCBqaXR0ZXJNYWduaXR1ZGUgPSBuZXh0QmFja29mZiAqIHRoaXMuaml0dGVyO1xyXG4gICAgICAgIHRoaXMubmV4dERlbGF5ID1cclxuICAgICAgICAgICAgbmV4dEJhY2tvZmYgKyB1bmlmb3JtUmFuZG9tKC1qaXR0ZXJNYWduaXR1ZGUsIGppdHRlck1hZ25pdHVkZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3AgdGhlIHRpbWVyLiBUaGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIHVudGlsIGBydW5PbmNlYCBpcyBjYWxsZWRcclxuICAgICAqIGFnYWluLlxyXG4gICAgICovXHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xyXG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgZGVsYXkgdGltZSB0byBpdHMgaW5pdGlhbCB2YWx1ZS4gSWYgdGhlIHRpbWVyIGlzIHN0aWxsIHJ1bm5pbmcsXHJcbiAgICAgKiByZXRyb2FjdGl2ZWx5IGFwcGx5IHRoYXQgcmVzZXQgdG8gdGhlIGN1cnJlbnQgdGltZXIuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMubmV4dERlbGF5ID0gdGhpcy5pbml0aWFsRGVsYXk7XHJcbiAgICAgICAgaWYgKHRoaXMucnVubmluZykge1xyXG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdFbmRUaW1lID0gdGhpcy5zdGFydFRpbWU7XHJcbiAgICAgICAgICAgIG5ld0VuZFRpbWUuc2V0TWlsbGlzZWNvbmRzKG5ld0VuZFRpbWUuZ2V0TWlsbGlzZWNvbmRzKCkgKyB0aGlzLm5leHREZWxheSk7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xyXG4gICAgICAgICAgICBpZiAobm93IDwgbmV3RW5kVGltZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lcihuZXdFbmRUaW1lLmdldFRpbWUoKSAtIG5vdy5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIHRpbWVyIGlzIGN1cnJlbnRseSBydW5uaW5nLlxyXG4gICAgICovXHJcbiAgICBpc1J1bm5pbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucnVubmluZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoYXQgd2hpbGUgdGhlIHRpbWVyIGlzIHJ1bm5pbmcsIGl0IHNob3VsZCBrZWVwIHRoZSBOb2RlIHByb2Nlc3NcclxuICAgICAqIHJ1bm5pbmcuXHJcbiAgICAgKi9cclxuICAgIHJlZigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHRoaXMuaGFzUmVmID0gdHJ1ZTtcclxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnRpbWVySWQpLnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhhdCB3aGlsZSB0aGUgdGltZXIgaXMgcnVubmluZywgaXQgc2hvdWxkIG5vdCBrZWVwIHRoZSBOb2RlIHByb2Nlc3NcclxuICAgICAqIHJ1bm5pbmcuXHJcbiAgICAgKi9cclxuICAgIHVucmVmKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdGhpcy5oYXNSZWYgPSBmYWxzZTtcclxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnRpbWVySWQpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYXBwcm94aW1hdGUgdGltZXN0YW1wIG9mIHdoZW4gdGhlIHRpbWVyIHdpbGwgZmlyZS4gT25seSB2YWxpZCBpZlxyXG4gICAgICogdGhpcy5pc1J1bm5pbmcoKSBpcyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBnZXRFbmRUaW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZFRpbWU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5CYWNrb2ZmVGltZW91dCA9IEJhY2tvZmZUaW1lb3V0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWNrb2ZmLXRpbWVvdXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.CallCredentials = void 0;\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nfunction isCurrentOauth2Client(client) {\r\n    return ('getRequestHeaders' in client &&\r\n        typeof client.getRequestHeaders === 'function');\r\n}\r\n/**\r\n * A class that represents a generic method of adding authentication-related\r\n * metadata on a per-request basis.\r\n */\r\nclass CallCredentials {\r\n    /**\r\n     * Creates a new CallCredentials object from a given function that generates\r\n     * Metadata objects.\r\n     * @param metadataGenerator A function that accepts a set of options, and\r\n     * generates a Metadata object based on these options, which is passed back\r\n     * to the caller via a supplied (err, metadata) callback.\r\n     */\r\n    static createFromMetadataGenerator(metadataGenerator) {\r\n        return new SingleCallCredentials(metadataGenerator);\r\n    }\r\n    /**\r\n     * Create a gRPC credential from a Google credential object.\r\n     * @param googleCredentials The authentication client to use.\r\n     * @return The resulting CallCredentials object.\r\n     */\r\n    static createFromGoogleCredential(googleCredentials) {\r\n        return CallCredentials.createFromMetadataGenerator((options, callback) => {\r\n            let getHeaders;\r\n            if (isCurrentOauth2Client(googleCredentials)) {\r\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\r\n            }\r\n            else {\r\n                getHeaders = new Promise((resolve, reject) => {\r\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\r\n                        if (err) {\r\n                            reject(err);\r\n                            return;\r\n                        }\r\n                        if (!headers) {\r\n                            reject(new Error('Headers not set by metadata plugin'));\r\n                            return;\r\n                        }\r\n                        resolve(headers);\r\n                    });\r\n                });\r\n            }\r\n            getHeaders.then(headers => {\r\n                const metadata = new metadata_1.Metadata();\r\n                for (const key of Object.keys(headers)) {\r\n                    metadata.add(key, headers[key]);\r\n                }\r\n                callback(null, metadata);\r\n            }, err => {\r\n                callback(err);\r\n            });\r\n        });\r\n    }\r\n    static createEmpty() {\r\n        return new EmptyCallCredentials();\r\n    }\r\n}\r\nexports.CallCredentials = CallCredentials;\r\nclass ComposedCallCredentials extends CallCredentials {\r\n    constructor(creds) {\r\n        super();\r\n        this.creds = creds;\r\n    }\r\n    async generateMetadata(options) {\r\n        const base = new metadata_1.Metadata();\r\n        const generated = await Promise.all(this.creds.map(cred => cred.generateMetadata(options)));\r\n        for (const gen of generated) {\r\n            base.merge(gen);\r\n        }\r\n        return base;\r\n    }\r\n    compose(other) {\r\n        return new ComposedCallCredentials(this.creds.concat([other]));\r\n    }\r\n    _equals(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (other instanceof ComposedCallCredentials) {\r\n            return this.creds.every((value, index) => value._equals(other.creds[index]));\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\nclass SingleCallCredentials extends CallCredentials {\r\n    constructor(metadataGenerator) {\r\n        super();\r\n        this.metadataGenerator = metadataGenerator;\r\n    }\r\n    generateMetadata(options) {\r\n        return new Promise((resolve, reject) => {\r\n            this.metadataGenerator(options, (err, metadata) => {\r\n                if (metadata !== undefined) {\r\n                    resolve(metadata);\r\n                }\r\n                else {\r\n                    reject(err);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    compose(other) {\r\n        return new ComposedCallCredentials([this, other]);\r\n    }\r\n    _equals(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (other instanceof SingleCallCredentials) {\r\n            return this.metadataGenerator === other.metadataGenerator;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\nclass EmptyCallCredentials extends CallCredentials {\r\n    generateMetadata(options) {\r\n        return Promise.resolve(new metadata_1.Metadata());\r\n    }\r\n    compose(other) {\r\n        return other;\r\n    }\r\n    _equals(other) {\r\n        return other instanceof EmptyCallCredentials;\r\n    }\r\n}\r\n//# sourceMappingURL=call-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtY3JlZGVudGlhbHMuanM/MTY0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHMgPSB2b2lkIDA7XHJcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcclxuZnVuY3Rpb24gaXNDdXJyZW50T2F1dGgyQ2xpZW50KGNsaWVudCkge1xyXG4gICAgcmV0dXJuICgnZ2V0UmVxdWVzdEhlYWRlcnMnIGluIGNsaWVudCAmJlxyXG4gICAgICAgIHR5cGVvZiBjbGllbnQuZ2V0UmVxdWVzdEhlYWRlcnMgPT09ICdmdW5jdGlvbicpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGdlbmVyaWMgbWV0aG9kIG9mIGFkZGluZyBhdXRoZW50aWNhdGlvbi1yZWxhdGVkXHJcbiAqIG1ldGFkYXRhIG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMuXHJcbiAqL1xyXG5jbGFzcyBDYWxsQ3JlZGVudGlhbHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENhbGxDcmVkZW50aWFscyBvYmplY3QgZnJvbSBhIGdpdmVuIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzXHJcbiAgICAgKiBNZXRhZGF0YSBvYmplY3RzLlxyXG4gICAgICogQHBhcmFtIG1ldGFkYXRhR2VuZXJhdG9yIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgc2V0IG9mIG9wdGlvbnMsIGFuZFxyXG4gICAgICogZ2VuZXJhdGVzIGEgTWV0YWRhdGEgb2JqZWN0IGJhc2VkIG9uIHRoZXNlIG9wdGlvbnMsIHdoaWNoIGlzIHBhc3NlZCBiYWNrXHJcbiAgICAgKiB0byB0aGUgY2FsbGVyIHZpYSBhIHN1cHBsaWVkIChlcnIsIG1ldGFkYXRhKSBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcihtZXRhZGF0YUdlbmVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2luZ2xlQ2FsbENyZWRlbnRpYWxzKG1ldGFkYXRhR2VuZXJhdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgZ1JQQyBjcmVkZW50aWFsIGZyb20gYSBHb29nbGUgY3JlZGVudGlhbCBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gZ29vZ2xlQ3JlZGVudGlhbHMgVGhlIGF1dGhlbnRpY2F0aW9uIGNsaWVudCB0byB1c2UuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQ2FsbENyZWRlbnRpYWxzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsKGdvb2dsZUNyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgcmV0dXJuIENhbGxDcmVkZW50aWFscy5jcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IoKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBnZXRIZWFkZXJzO1xyXG4gICAgICAgICAgICBpZiAoaXNDdXJyZW50T2F1dGgyQ2xpZW50KGdvb2dsZUNyZWRlbnRpYWxzKSkge1xyXG4gICAgICAgICAgICAgICAgZ2V0SGVhZGVycyA9IGdvb2dsZUNyZWRlbnRpYWxzLmdldFJlcXVlc3RIZWFkZXJzKG9wdGlvbnMuc2VydmljZV91cmwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ2V0SGVhZGVycyA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBnb29nbGVDcmVkZW50aWFscy5nZXRSZXF1ZXN0TWV0YWRhdGEob3B0aW9ucy5zZXJ2aWNlX3VybCwgKGVyciwgaGVhZGVycykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0hlYWRlcnMgbm90IHNldCBieSBtZXRhZGF0YSBwbHVnaW4nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShoZWFkZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldEhlYWRlcnMudGhlbihoZWFkZXJzID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuYWRkKGtleSwgaGVhZGVyc1trZXldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1ldGFkYXRhKTtcclxuICAgICAgICAgICAgfSwgZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZUVtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlDYWxsQ3JlZGVudGlhbHMoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IENhbGxDcmVkZW50aWFscztcclxuY2xhc3MgQ29tcG9zZWRDYWxsQ3JlZGVudGlhbHMgZXh0ZW5kcyBDYWxsQ3JlZGVudGlhbHMge1xyXG4gICAgY29uc3RydWN0b3IoY3JlZHMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY3JlZHMgPSBjcmVkcztcclxuICAgIH1cclxuICAgIGFzeW5jIGdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGJhc2UgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xyXG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZCA9IGF3YWl0IFByb21pc2UuYWxsKHRoaXMuY3JlZHMubWFwKGNyZWQgPT4gY3JlZC5nZW5lcmF0ZU1ldGFkYXRhKG9wdGlvbnMpKSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBnZW4gb2YgZ2VuZXJhdGVkKSB7XHJcbiAgICAgICAgICAgIGJhc2UubWVyZ2UoZ2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICB9XHJcbiAgICBjb21wb3NlKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENhbGxDcmVkZW50aWFscyh0aGlzLmNyZWRzLmNvbmNhdChbb3RoZXJdKSk7XHJcbiAgICB9XHJcbiAgICBfZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NlZENhbGxDcmVkZW50aWFscykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVkcy5ldmVyeSgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZS5fZXF1YWxzKG90aGVyLmNyZWRzW2luZGV4XSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBTaW5nbGVDYWxsQ3JlZGVudGlhbHMgZXh0ZW5kcyBDYWxsQ3JlZGVudGlhbHMge1xyXG4gICAgY29uc3RydWN0b3IobWV0YWRhdGFHZW5lcmF0b3IpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGFHZW5lcmF0b3IgPSBtZXRhZGF0YUdlbmVyYXRvcjtcclxuICAgIH1cclxuICAgIGdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFHZW5lcmF0b3Iob3B0aW9ucywgKGVyciwgbWV0YWRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtZXRhZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb21wb3NlKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENhbGxDcmVkZW50aWFscyhbdGhpcywgb3RoZXJdKTtcclxuICAgIH1cclxuICAgIF9lcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFNpbmdsZUNhbGxDcmVkZW50aWFscykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YUdlbmVyYXRvciA9PT0gb3RoZXIubWV0YWRhdGFHZW5lcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIEVtcHR5Q2FsbENyZWRlbnRpYWxzIGV4dGVuZHMgQ2FsbENyZWRlbnRpYWxzIHtcclxuICAgIGdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSk7XHJcbiAgICB9XHJcbiAgICBjb21wb3NlKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG90aGVyO1xyXG4gICAgfVxyXG4gICAgX2VxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEVtcHR5Q2FsbENyZWRlbnRpYWxzO1xyXG4gICAgfVxyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call-interface.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-interface.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\r\nfunction isInterceptingListener(listener) {\r\n    return (listener.onReceiveMetadata !== undefined &&\r\n        listener.onReceiveMetadata.length === 1);\r\n}\r\nexports.isInterceptingListener = isInterceptingListener;\r\nclass InterceptingListenerImpl {\r\n    constructor(listener, nextListener) {\r\n        this.listener = listener;\r\n        this.nextListener = nextListener;\r\n        this.processingMetadata = false;\r\n        this.hasPendingMessage = false;\r\n        this.processingMessage = false;\r\n        this.pendingStatus = null;\r\n    }\r\n    processPendingMessage() {\r\n        if (this.hasPendingMessage) {\r\n            this.nextListener.onReceiveMessage(this.pendingMessage);\r\n            this.pendingMessage = null;\r\n            this.hasPendingMessage = false;\r\n        }\r\n    }\r\n    processPendingStatus() {\r\n        if (this.pendingStatus) {\r\n            this.nextListener.onReceiveStatus(this.pendingStatus);\r\n        }\r\n    }\r\n    onReceiveMetadata(metadata) {\r\n        this.processingMetadata = true;\r\n        this.listener.onReceiveMetadata(metadata, metadata => {\r\n            this.processingMetadata = false;\r\n            this.nextListener.onReceiveMetadata(metadata);\r\n            this.processPendingMessage();\r\n            this.processPendingStatus();\r\n        });\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    onReceiveMessage(message) {\r\n        /* If this listener processes messages asynchronously, the last message may\r\n         * be reordered with respect to the status */\r\n        this.processingMessage = true;\r\n        this.listener.onReceiveMessage(message, msg => {\r\n            this.processingMessage = false;\r\n            if (this.processingMetadata) {\r\n                this.pendingMessage = msg;\r\n                this.hasPendingMessage = true;\r\n            }\r\n            else {\r\n                this.nextListener.onReceiveMessage(msg);\r\n                this.processPendingStatus();\r\n            }\r\n        });\r\n    }\r\n    onReceiveStatus(status) {\r\n        this.listener.onReceiveStatus(status, processedStatus => {\r\n            if (this.processingMetadata || this.processingMessage) {\r\n                this.pendingStatus = processedStatus;\r\n            }\r\n            else {\r\n                this.nextListener.onReceiveStatus(processedStatus);\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\r\n//# sourceMappingURL=call-interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyw4QkFBOEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtaW50ZXJmYWNlLmpzP2NmY2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsID0gZXhwb3J0cy5pc0ludGVyY2VwdGluZ0xpc3RlbmVyID0gdm9pZCAwO1xyXG5mdW5jdGlvbiBpc0ludGVyY2VwdGluZ0xpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICByZXR1cm4gKGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YS5sZW5ndGggPT09IDEpO1xyXG59XHJcbmV4cG9ydHMuaXNJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IGlzSW50ZXJjZXB0aW5nTGlzdGVuZXI7XHJcbmNsYXNzIEludGVyY2VwdGluZ0xpc3RlbmVySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihsaXN0ZW5lciwgbmV4dExpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgICAgIHRoaXMubmV4dExpc3RlbmVyID0gbmV4dExpc3RlbmVyO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1BlbmRpbmdNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UodGhpcy5wZW5kaW5nTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJvY2Vzc1BlbmRpbmdTdGF0dXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1N0YXR1cykge1xyXG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXModGhpcy5wZW5kaW5nU3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhLCBtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ01lc3NhZ2UoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N0YXR1cygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIC8qIElmIHRoaXMgbGlzdGVuZXIgcHJvY2Vzc2VzIG1lc3NhZ2VzIGFzeW5jaHJvbm91c2x5LCB0aGUgbGFzdCBtZXNzYWdlIG1heVxyXG4gICAgICAgICAqIGJlIHJlb3JkZXJlZCB3aXRoIHJlc3BlY3QgdG8gdGhlIHN0YXR1cyAqL1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShtZXNzYWdlLCBtc2cgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG1zZztcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShtc2cpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N0YXR1cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVTdGF0dXMoc3RhdHVzLCBwcm9jZXNzZWRTdGF0dXMgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgfHwgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gcHJvY2Vzc2VkU3RhdHVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKHByb2Nlc3NlZFN0YXR1cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbCA9IEludGVyY2VwdGluZ0xpc3RlbmVySW1wbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC1pbnRlcmZhY2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-number.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getNextCallNumber = void 0;\r\nlet nextCallNumber = 0;\r\nfunction getNextCallNumber() {\r\n    return nextCallNumber++;\r\n}\r\nexports.getNextCallNumber = getNextCallNumber;\r\n//# sourceMappingURL=call-number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtbnVtYmVyLmpzP2FmNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZ2V0TmV4dENhbGxOdW1iZXIgPSB2b2lkIDA7XHJcbmxldCBuZXh0Q2FsbE51bWJlciA9IDA7XHJcbmZ1bmN0aW9uIGdldE5leHRDYWxsTnVtYmVyKCkge1xyXG4gICAgcmV0dXJuIG5leHRDYWxsTnVtYmVyKys7XHJcbn1cclxuZXhwb3J0cy5nZXROZXh0Q2FsbE51bWJlciA9IGdldE5leHRDYWxsTnVtYmVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLW51bWJlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/call.js":
/*!******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = exports.callErrorFromStatus = void 0;\r\nconst events_1 = __webpack_require__(/*! events */ \"events\");\r\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\n/**\r\n * Construct a ServiceError from a StatusObject. This function exists primarily\r\n * as an attempt to make the error stack trace clearly communicate that the\r\n * error is not necessarily a problem in gRPC itself.\r\n * @param status\r\n */\r\nfunction callErrorFromStatus(status, callerStack) {\r\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\r\n    const error = new Error(message);\r\n    const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\r\n    return Object.assign(new Error(message), status, { stack });\r\n}\r\nexports.callErrorFromStatus = callErrorFromStatus;\r\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\r\n    constructor() {\r\n        super();\r\n    }\r\n    cancel() {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\r\n    }\r\n    getPeer() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\r\n    }\r\n}\r\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\r\nclass ClientReadableStreamImpl extends stream_1.Readable {\r\n    constructor(deserialize) {\r\n        super({ objectMode: true });\r\n        this.deserialize = deserialize;\r\n    }\r\n    cancel() {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\r\n    }\r\n    getPeer() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\r\n    }\r\n    _read(_size) {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\r\n    }\r\n}\r\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\r\nclass ClientWritableStreamImpl extends stream_1.Writable {\r\n    constructor(serialize) {\r\n        super({ objectMode: true });\r\n        this.serialize = serialize;\r\n    }\r\n    cancel() {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\r\n    }\r\n    getPeer() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\r\n    }\r\n    _write(chunk, encoding, cb) {\r\n        var _a;\r\n        const context = {\r\n            callback: cb,\r\n        };\r\n        const flags = Number(encoding);\r\n        if (!Number.isNaN(flags)) {\r\n            context.flags = flags;\r\n        }\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\r\n    }\r\n    _final(cb) {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\r\n        cb();\r\n    }\r\n}\r\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\r\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\r\n    constructor(serialize, deserialize) {\r\n        super({ objectMode: true });\r\n        this.serialize = serialize;\r\n        this.deserialize = deserialize;\r\n    }\r\n    cancel() {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\r\n    }\r\n    getPeer() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\r\n    }\r\n    _read(_size) {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\r\n    }\r\n    _write(chunk, encoding, cb) {\r\n        var _a;\r\n        const context = {\r\n            callback: cb,\r\n        };\r\n        const flags = Number(encoding);\r\n        if (!Number.isNaN(flags)) {\r\n            context.flags = flags;\r\n        }\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\r\n    }\r\n    _final(cb) {\r\n        var _a;\r\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\r\n        cb();\r\n    }\r\n}\r\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;\r\n//# sourceMappingURL=call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLDJCQUEyQjtBQUNoSyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhLEVBQUUsZ0NBQWdDLElBQUksZUFBZTtBQUN6RjtBQUNBLHFCQUFxQixZQUFZLGlCQUFpQixZQUFZO0FBQzlELHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcz8wOTNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkNsaWVudER1cGxleFN0cmVhbUltcGwgPSBleHBvcnRzLkNsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5DbGllbnRVbmFyeUNhbGxJbXBsID0gZXhwb3J0cy5jYWxsRXJyb3JGcm9tU3RhdHVzID0gdm9pZCAwO1xyXG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XHJcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3QgYSBTZXJ2aWNlRXJyb3IgZnJvbSBhIFN0YXR1c09iamVjdC4gVGhpcyBmdW5jdGlvbiBleGlzdHMgcHJpbWFyaWx5XHJcbiAqIGFzIGFuIGF0dGVtcHQgdG8gbWFrZSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UgY2xlYXJseSBjb21tdW5pY2F0ZSB0aGF0IHRoZVxyXG4gKiBlcnJvciBpcyBub3QgbmVjZXNzYXJpbHkgYSBwcm9ibGVtIGluIGdSUEMgaXRzZWxmLlxyXG4gKiBAcGFyYW0gc3RhdHVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxsRXJyb3JGcm9tU3RhdHVzKHN0YXR1cywgY2FsbGVyU3RhY2spIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHtzdGF0dXMuY29kZX0gJHtjb25zdGFudHNfMS5TdGF0dXNbc3RhdHVzLmNvZGVdfTogJHtzdGF0dXMuZGV0YWlsc31gO1xyXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICBjb25zdCBzdGFjayA9IGAke2Vycm9yLnN0YWNrfVxcbmZvciBjYWxsIGF0XFxuJHtjYWxsZXJTdGFja31gO1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKG1lc3NhZ2UpLCBzdGF0dXMsIHsgc3RhY2sgfSk7XHJcbn1cclxuZXhwb3J0cy5jYWxsRXJyb3JGcm9tU3RhdHVzID0gY2FsbEVycm9yRnJvbVN0YXR1cztcclxuY2xhc3MgQ2xpZW50VW5hcnlDYWxsSW1wbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG4gICAgY2FuY2VsKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ2xpZW50VW5hcnlDYWxsSW1wbCA9IENsaWVudFVuYXJ5Q2FsbEltcGw7XHJcbmNsYXNzIENsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLlJlYWRhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGRlc2VyaWFsaXplKSB7XHJcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcclxuICAgIH1cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xyXG4gICAgfVxyXG4gICAgZ2V0UGVlcigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcclxuICAgIH1cclxuICAgIF9yZWFkKF9zaXplKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0UmVhZCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsID0gQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsO1xyXG5jbGFzcyBDbGllbnRXcml0YWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemUpIHtcclxuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XHJcbiAgICB9XHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcclxuICAgIH1cclxuICAgIGdldFBlZXIoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XHJcbiAgICB9XHJcbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgICAgICBjYWxsYmFjazogY2IsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBmbGFncyA9IE51bWJlcihlbmNvZGluZyk7XHJcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oZmxhZ3MpKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmxhZ3MgPSBmbGFncztcclxuICAgICAgICB9XHJcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBjaHVuayk7XHJcbiAgICB9XHJcbiAgICBfZmluYWwoY2IpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFsZkNsb3NlKCk7XHJcbiAgICAgICAgY2IoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCA9IENsaWVudFdyaXRhYmxlU3RyZWFtSW1wbDtcclxuY2xhc3MgQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemUsIGRlc2VyaWFsaXplKSB7XHJcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xyXG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcclxuICAgIH1cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xyXG4gICAgfVxyXG4gICAgZ2V0UGVlcigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcclxuICAgIH1cclxuICAgIF9yZWFkKF9zaXplKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXJ0UmVhZCgpO1xyXG4gICAgfVxyXG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGNiLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBOdW1iZXIoZW5jb2RpbmcpO1xyXG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGZsYWdzKSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmZsYWdzID0gZmxhZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgY2h1bmspO1xyXG4gICAgfVxyXG4gICAgX2ZpbmFsKGNiKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbGZDbG9zZSgpO1xyXG4gICAgICAgIGNiKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DbGllbnREdXBsZXhTdHJlYW1JbXBsID0gQ2xpZW50RHVwbGV4U3RyZWFtSW1wbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-credentials.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ChannelCredentials = void 0;\r\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\r\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\r\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction verifyIsBufferOrNull(obj, friendlyName) {\r\n    if (obj && !(obj instanceof Buffer)) {\r\n        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\r\n    }\r\n}\r\n/**\r\n * A class that contains credentials for communicating over a channel, as well\r\n * as a set of per-call credentials, which are applied to every method call made\r\n * over a channel initialized with an instance of this class.\r\n */\r\nclass ChannelCredentials {\r\n    constructor(callCredentials) {\r\n        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\r\n    }\r\n    /**\r\n     * Gets the set of per-call credentials associated with this instance.\r\n     */\r\n    _getCallCredentials() {\r\n        return this.callCredentials;\r\n    }\r\n    /**\r\n     * Return a new ChannelCredentials instance with a given set of credentials.\r\n     * The resulting instance can be used to construct a Channel that communicates\r\n     * over TLS.\r\n     * @param rootCerts The root certificate data.\r\n     * @param privateKey The client certificate private key, if available.\r\n     * @param certChain The client certificate key chain, if available.\r\n     * @param verifyOptions Additional options to modify certificate verification\r\n     */\r\n    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\r\n        var _a;\r\n        verifyIsBufferOrNull(rootCerts, 'Root certificate');\r\n        verifyIsBufferOrNull(privateKey, 'Private key');\r\n        verifyIsBufferOrNull(certChain, 'Certificate chain');\r\n        if (privateKey && !certChain) {\r\n            throw new Error('Private key must be given with accompanying certificate chain');\r\n        }\r\n        if (!privateKey && certChain) {\r\n            throw new Error('Certificate chain must be given with accompanying private key');\r\n        }\r\n        const secureContext = (0, tls_1.createSecureContext)({\r\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\r\n            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\r\n            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\r\n            ciphers: tls_helpers_1.CIPHER_SUITES,\r\n        });\r\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\r\n    }\r\n    /**\r\n     * Return a new ChannelCredentials instance with credentials created using\r\n     * the provided secureContext. The resulting instances can be used to\r\n     * construct a Channel that communicates over TLS. gRPC will not override\r\n     * anything in the provided secureContext, so the environment variables\r\n     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\r\n     * not be applied.\r\n     * @param secureContext The return value of tls.createSecureContext()\r\n     * @param verifyOptions Additional options to modify certificate verification\r\n     */\r\n    static createFromSecureContext(secureContext, verifyOptions) {\r\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\r\n    }\r\n    /**\r\n     * Return a new ChannelCredentials instance with no credentials.\r\n     */\r\n    static createInsecure() {\r\n        return new InsecureChannelCredentialsImpl();\r\n    }\r\n}\r\nexports.ChannelCredentials = ChannelCredentials;\r\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\r\n    constructor(callCredentials) {\r\n        super(callCredentials);\r\n    }\r\n    compose(callCredentials) {\r\n        throw new Error('Cannot compose insecure credentials');\r\n    }\r\n    _getConnectionOptions() {\r\n        return null;\r\n    }\r\n    _isSecure() {\r\n        return false;\r\n    }\r\n    _equals(other) {\r\n        return other instanceof InsecureChannelCredentialsImpl;\r\n    }\r\n}\r\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\r\n    constructor(secureContext, verifyOptions) {\r\n        super();\r\n        this.secureContext = secureContext;\r\n        this.verifyOptions = verifyOptions;\r\n        this.connectionOptions = {\r\n            secureContext,\r\n        };\r\n        // Node asserts that this option is a function, so we cannot pass undefined\r\n        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {\r\n            this.connectionOptions.checkServerIdentity =\r\n                verifyOptions.checkServerIdentity;\r\n        }\r\n    }\r\n    compose(callCredentials) {\r\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\r\n        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\r\n    }\r\n    _getConnectionOptions() {\r\n        // Copy to prevent callers from mutating this.connectionOptions\r\n        return Object.assign({}, this.connectionOptions);\r\n    }\r\n    _isSecure() {\r\n        return true;\r\n    }\r\n    _equals(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (other instanceof SecureChannelCredentialsImpl) {\r\n            return (this.secureContext === other.secureContext &&\r\n                this.verifyOptions.checkServerIdentity ===\r\n                    other.verifyOptions.checkServerIdentity);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\r\n    constructor(channelCredentials, callCreds) {\r\n        super(callCreds);\r\n        this.channelCredentials = channelCredentials;\r\n    }\r\n    compose(callCredentials) {\r\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\r\n        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\r\n    }\r\n    _getConnectionOptions() {\r\n        return this.channelCredentials._getConnectionOptions();\r\n    }\r\n    _isSecure() {\r\n        return true;\r\n    }\r\n    _equals(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (other instanceof ComposedChannelCredentialsImpl) {\r\n            return (this.channelCredentials._equals(other.channelCredentials) &&\r\n                this.callCredentials._equals(other.callCredentials));\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=channel-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzSUFBc0k7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcz85MDE5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkNoYW5uZWxDcmVkZW50aWFscyA9IHZvaWQgMDtcclxuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xyXG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xyXG5jb25zdCB0bHNfaGVscGVyc18xID0gcmVxdWlyZShcIi4vdGxzLWhlbHBlcnNcIik7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbmZ1bmN0aW9uIHZlcmlmeUlzQnVmZmVyT3JOdWxsKG9iaiwgZnJpZW5kbHlOYW1lKSB7XHJcbiAgICBpZiAob2JqICYmICEob2JqIGluc3RhbmNlb2YgQnVmZmVyKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZnJpZW5kbHlOYW1lfSwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBCdWZmZXIuYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgY2xhc3MgdGhhdCBjb250YWlucyBjcmVkZW50aWFscyBmb3IgY29tbXVuaWNhdGluZyBvdmVyIGEgY2hhbm5lbCwgYXMgd2VsbFxyXG4gKiBhcyBhIHNldCBvZiBwZXItY2FsbCBjcmVkZW50aWFscywgd2hpY2ggYXJlIGFwcGxpZWQgdG8gZXZlcnkgbWV0aG9kIGNhbGwgbWFkZVxyXG4gKiBvdmVyIGEgY2hhbm5lbCBpbml0aWFsaXplZCB3aXRoIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5jbGFzcyBDaGFubmVsQ3JlZGVudGlhbHMge1xyXG4gICAgY29uc3RydWN0b3IoY2FsbENyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMgPSBjYWxsQ3JlZGVudGlhbHMgfHwgY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBzZXQgb2YgcGVyLWNhbGwgY3JlZGVudGlhbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIF9nZXRDYWxsQ3JlZGVudGlhbHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbENyZWRlbnRpYWxzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggYSBnaXZlbiBzZXQgb2YgY3JlZGVudGlhbHMuXHJcbiAgICAgKiBUaGUgcmVzdWx0aW5nIGluc3RhbmNlIGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIENoYW5uZWwgdGhhdCBjb21tdW5pY2F0ZXNcclxuICAgICAqIG92ZXIgVExTLlxyXG4gICAgICogQHBhcmFtIHJvb3RDZXJ0cyBUaGUgcm9vdCBjZXJ0aWZpY2F0ZSBkYXRhLlxyXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgVGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBwcml2YXRlIGtleSwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICogQHBhcmFtIGNlcnRDaGFpbiBUaGUgY2xpZW50IGNlcnRpZmljYXRlIGtleSBjaGFpbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICogQHBhcmFtIHZlcmlmeU9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIG1vZGlmeSBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb25cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVNzbChyb290Q2VydHMsIHByaXZhdGVLZXksIGNlcnRDaGFpbiwgdmVyaWZ5T3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChyb290Q2VydHMsICdSb290IGNlcnRpZmljYXRlJyk7XHJcbiAgICAgICAgdmVyaWZ5SXNCdWZmZXJPck51bGwocHJpdmF0ZUtleSwgJ1ByaXZhdGUga2V5Jyk7XHJcbiAgICAgICAgdmVyaWZ5SXNCdWZmZXJPck51bGwoY2VydENoYWluLCAnQ2VydGlmaWNhdGUgY2hhaW4nKTtcclxuICAgICAgICBpZiAocHJpdmF0ZUtleSAmJiAhY2VydENoYWluKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJpdmF0ZSBrZXkgbXVzdCBiZSBnaXZlbiB3aXRoIGFjY29tcGFueWluZyBjZXJ0aWZpY2F0ZSBjaGFpbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXByaXZhdGVLZXkgJiYgY2VydENoYWluKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2VydGlmaWNhdGUgY2hhaW4gbXVzdCBiZSBnaXZlbiB3aXRoIGFjY29tcGFueWluZyBwcml2YXRlIGtleScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzZWN1cmVDb250ZXh0ID0gKDAsIHRsc18xLmNyZWF0ZVNlY3VyZUNvbnRleHQpKHtcclxuICAgICAgICAgICAgY2E6IChfYSA9IHJvb3RDZXJ0cyAhPT0gbnVsbCAmJiByb290Q2VydHMgIT09IHZvaWQgMCA/IHJvb3RDZXJ0cyA6ICgwLCB0bHNfaGVscGVyc18xLmdldERlZmF1bHRSb290c0RhdGEpKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAga2V5OiBwcml2YXRlS2V5ICE9PSBudWxsICYmIHByaXZhdGVLZXkgIT09IHZvaWQgMCA/IHByaXZhdGVLZXkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNlcnQ6IGNlcnRDaGFpbiAhPT0gbnVsbCAmJiBjZXJ0Q2hhaW4gIT09IHZvaWQgMCA/IGNlcnRDaGFpbiA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgY2lwaGVyczogdGxzX2hlbHBlcnNfMS5DSVBIRVJfU1VJVEVTLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbChzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zICE9PSBudWxsICYmIHZlcmlmeU9wdGlvbnMgIT09IHZvaWQgMCA/IHZlcmlmeU9wdGlvbnMgOiB7fSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIG5ldyBDaGFubmVsQ3JlZGVudGlhbHMgaW5zdGFuY2Ugd2l0aCBjcmVkZW50aWFscyBjcmVhdGVkIHVzaW5nXHJcbiAgICAgKiB0aGUgcHJvdmlkZWQgc2VjdXJlQ29udGV4dC4gVGhlIHJlc3VsdGluZyBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgdG9cclxuICAgICAqIGNvbnN0cnVjdCBhIENoYW5uZWwgdGhhdCBjb21tdW5pY2F0ZXMgb3ZlciBUTFMuIGdSUEMgd2lsbCBub3Qgb3ZlcnJpZGVcclxuICAgICAqIGFueXRoaW5nIGluIHRoZSBwcm92aWRlZCBzZWN1cmVDb250ZXh0LCBzbyB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXHJcbiAgICAgKiBHUlBDX1NTTF9DSVBIRVJfU1VJVEVTIGFuZCBHUlBDX0RFRkFVTFRfU1NMX1JPT1RTX0ZJTEVfUEFUSCB3aWxsXHJcbiAgICAgKiBub3QgYmUgYXBwbGllZC5cclxuICAgICAqIEBwYXJhbSBzZWN1cmVDb250ZXh0IFRoZSByZXR1cm4gdmFsdWUgb2YgdGxzLmNyZWF0ZVNlY3VyZUNvbnRleHQoKVxyXG4gICAgICogQHBhcmFtIHZlcmlmeU9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIG1vZGlmeSBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb25cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUZyb21TZWN1cmVDb250ZXh0KHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwoc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucyAhPT0gbnVsbCAmJiB2ZXJpZnlPcHRpb25zICE9PSB2b2lkIDAgPyB2ZXJpZnlPcHRpb25zIDoge30pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggbm8gY3JlZGVudGlhbHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVJbnNlY3VyZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ2hhbm5lbENyZWRlbnRpYWxzID0gQ2hhbm5lbENyZWRlbnRpYWxzO1xyXG5jbGFzcyBJbnNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwgZXh0ZW5kcyBDaGFubmVsQ3JlZGVudGlhbHMge1xyXG4gICAgY29uc3RydWN0b3IoY2FsbENyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgc3VwZXIoY2FsbENyZWRlbnRpYWxzKTtcclxuICAgIH1cclxuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcG9zZSBpbnNlY3VyZSBjcmVkZW50aWFscycpO1xyXG4gICAgfVxyXG4gICAgX2dldENvbm5lY3Rpb25PcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgX2lzU2VjdXJlKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIF9lcXVhbHMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBJbnNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGw7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnNlY3VyZUNvbnRleHQgPSBzZWN1cmVDb250ZXh0O1xyXG4gICAgICAgIHRoaXMudmVyaWZ5T3B0aW9ucyA9IHZlcmlmeU9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgc2VjdXJlQ29udGV4dCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIE5vZGUgYXNzZXJ0cyB0aGF0IHRoaXMgb3B0aW9uIGlzIGEgZnVuY3Rpb24sIHNvIHdlIGNhbm5vdCBwYXNzIHVuZGVmaW5lZFxyXG4gICAgICAgIGlmICh2ZXJpZnlPcHRpb25zID09PSBudWxsIHx8IHZlcmlmeU9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPVxyXG4gICAgICAgICAgICAgICAgdmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgY29uc3QgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMgPSB0aGlzLmNhbGxDcmVkZW50aWFscy5jb21wb3NlKGNhbGxDcmVkZW50aWFscyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwodGhpcywgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMpO1xyXG4gICAgfVxyXG4gICAgX2dldENvbm5lY3Rpb25PcHRpb25zKCkge1xyXG4gICAgICAgIC8vIENvcHkgdG8gcHJldmVudCBjYWxsZXJzIGZyb20gbXV0YXRpbmcgdGhpcy5jb25uZWN0aW9uT3B0aW9uc1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb25PcHRpb25zKTtcclxuICAgIH1cclxuICAgIF9pc1NlY3VyZSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9lcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnNlY3VyZUNvbnRleHQgPT09IG90aGVyLnNlY3VyZUNvbnRleHQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID09PVxyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLnZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ3JlZGVudGlhbHMsIGNhbGxDcmVkcykge1xyXG4gICAgICAgIHN1cGVyKGNhbGxDcmVkcyk7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsQ3JlZGVudGlhbHMgPSBjaGFubmVsQ3JlZGVudGlhbHM7XHJcbiAgICB9XHJcbiAgICBjb21wb3NlKGNhbGxDcmVkZW50aWFscykge1xyXG4gICAgICAgIGNvbnN0IGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzID0gdGhpcy5jYWxsQ3JlZGVudGlhbHMuY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLCBjb21iaW5lZENhbGxDcmVkZW50aWFscyk7XHJcbiAgICB9XHJcbiAgICBfZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLl9nZXRDb25uZWN0aW9uT3B0aW9ucygpO1xyXG4gICAgfVxyXG4gICAgX2lzU2VjdXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgX2VxdWFscyhvdGhlcikge1xyXG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFubmVsQ3JlZGVudGlhbHMuX2VxdWFscyhvdGhlci5jaGFubmVsQ3JlZGVudGlhbHMpICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxDcmVkZW50aWFscy5fZXF1YWxzKG90aGVyLmNhbGxDcmVkZW50aWFscykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.channelOptionsEqual = exports.recognizedOptions = void 0;\r\n/**\r\n * This is for checking provided options at runtime. This is an object for\r\n * easier membership checking.\r\n */\r\nexports.recognizedOptions = {\r\n    'grpc.ssl_target_name_override': true,\r\n    'grpc.primary_user_agent': true,\r\n    'grpc.secondary_user_agent': true,\r\n    'grpc.default_authority': true,\r\n    'grpc.keepalive_time_ms': true,\r\n    'grpc.keepalive_timeout_ms': true,\r\n    'grpc.keepalive_permit_without_calls': true,\r\n    'grpc.service_config': true,\r\n    'grpc.max_concurrent_streams': true,\r\n    'grpc.initial_reconnect_backoff_ms': true,\r\n    'grpc.max_reconnect_backoff_ms': true,\r\n    'grpc.use_local_subchannel_pool': true,\r\n    'grpc.max_send_message_length': true,\r\n    'grpc.max_receive_message_length': true,\r\n    'grpc.enable_http_proxy': true,\r\n    'grpc.enable_channelz': true,\r\n    'grpc.dns_min_time_between_resolutions_ms': true,\r\n    'grpc.enable_retries': true,\r\n    'grpc.per_rpc_retry_buffer_size': true,\r\n    'grpc.retry_buffer_size': true,\r\n    'grpc.max_connection_age_ms': true,\r\n    'grpc.max_connection_age_grace_ms': true,\r\n    'grpc-node.max_session_memory': true,\r\n    'grpc.service_config_disable_resolution': true,\r\n    'grpc.client_idle_timeout_ms': true,\r\n    'grpc-node.tls_enable_trace': true,\r\n};\r\nfunction channelOptionsEqual(options1, options2) {\r\n    const keys1 = Object.keys(options1).sort();\r\n    const keys2 = Object.keys(options2).sort();\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < keys1.length; i += 1) {\r\n        if (keys1[i] !== keys2[i]) {\r\n            return false;\r\n        }\r\n        if (options1[keys1[i]] !== options2[keys2[i]]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.channelOptionsEqual = channelOptionsEqual;\r\n//# sourceMappingURL=channel-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLW9wdGlvbnMuanM/NDhmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5jaGFubmVsT3B0aW9uc0VxdWFsID0gZXhwb3J0cy5yZWNvZ25pemVkT3B0aW9ucyA9IHZvaWQgMDtcclxuLyoqXHJcbiAqIFRoaXMgaXMgZm9yIGNoZWNraW5nIHByb3ZpZGVkIG9wdGlvbnMgYXQgcnVudGltZS4gVGhpcyBpcyBhbiBvYmplY3QgZm9yXHJcbiAqIGVhc2llciBtZW1iZXJzaGlwIGNoZWNraW5nLlxyXG4gKi9cclxuZXhwb3J0cy5yZWNvZ25pemVkT3B0aW9ucyA9IHtcclxuICAgICdncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSc6IHRydWUsXHJcbiAgICAnZ3JwYy5wcmltYXJ5X3VzZXJfYWdlbnQnOiB0cnVlLFxyXG4gICAgJ2dycGMuc2Vjb25kYXJ5X3VzZXJfYWdlbnQnOiB0cnVlLFxyXG4gICAgJ2dycGMuZGVmYXVsdF9hdXRob3JpdHknOiB0cnVlLFxyXG4gICAgJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnOiB0cnVlLFxyXG4gICAgJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnOiB0cnVlLFxyXG4gICAgJ2dycGMua2VlcGFsaXZlX3Blcm1pdF93aXRob3V0X2NhbGxzJzogdHJ1ZSxcclxuICAgICdncnBjLnNlcnZpY2VfY29uZmlnJzogdHJ1ZSxcclxuICAgICdncnBjLm1heF9jb25jdXJyZW50X3N0cmVhbXMnOiB0cnVlLFxyXG4gICAgJ2dycGMuaW5pdGlhbF9yZWNvbm5lY3RfYmFja29mZl9tcyc6IHRydWUsXHJcbiAgICAnZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnOiB0cnVlLFxyXG4gICAgJ2dycGMudXNlX2xvY2FsX3N1YmNoYW5uZWxfcG9vbCc6IHRydWUsXHJcbiAgICAnZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCc6IHRydWUsXHJcbiAgICAnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCc6IHRydWUsXHJcbiAgICAnZ3JwYy5lbmFibGVfaHR0cF9wcm94eSc6IHRydWUsXHJcbiAgICAnZ3JwYy5lbmFibGVfY2hhbm5lbHonOiB0cnVlLFxyXG4gICAgJ2dycGMuZG5zX21pbl90aW1lX2JldHdlZW5fcmVzb2x1dGlvbnNfbXMnOiB0cnVlLFxyXG4gICAgJ2dycGMuZW5hYmxlX3JldHJpZXMnOiB0cnVlLFxyXG4gICAgJ2dycGMucGVyX3JwY19yZXRyeV9idWZmZXJfc2l6ZSc6IHRydWUsXHJcbiAgICAnZ3JwYy5yZXRyeV9idWZmZXJfc2l6ZSc6IHRydWUsXHJcbiAgICAnZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfbXMnOiB0cnVlLFxyXG4gICAgJ2dycGMubWF4X2Nvbm5lY3Rpb25fYWdlX2dyYWNlX21zJzogdHJ1ZSxcclxuICAgICdncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5JzogdHJ1ZSxcclxuICAgICdncnBjLnNlcnZpY2VfY29uZmlnX2Rpc2FibGVfcmVzb2x1dGlvbic6IHRydWUsXHJcbiAgICAnZ3JwYy5jbGllbnRfaWRsZV90aW1lb3V0X21zJzogdHJ1ZSxcclxuICAgICdncnBjLW5vZGUudGxzX2VuYWJsZV90cmFjZSc6IHRydWUsXHJcbn07XHJcbmZ1bmN0aW9uIGNoYW5uZWxPcHRpb25zRXF1YWwob3B0aW9uczEsIG9wdGlvbnMyKSB7XHJcbiAgICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9wdGlvbnMxKS5zb3J0KCk7XHJcbiAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9wdGlvbnMyKS5zb3J0KCk7XHJcbiAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgaWYgKGtleXMxW2ldICE9PSBrZXlzMltpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zMVtrZXlzMVtpXV0gIT09IG9wdGlvbnMyW2tleXMyW2ldXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZXhwb3J0cy5jaGFubmVsT3B0aW9uc0VxdWFsID0gY2hhbm5lbE9wdGlvbnNFcXVhbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ChannelImplementation = void 0;\r\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\r\nconst internal_channel_1 = __webpack_require__(/*! ./internal-channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\");\r\nclass ChannelImplementation {\r\n    constructor(target, credentials, options) {\r\n        if (typeof target !== 'string') {\r\n            throw new TypeError('Channel target must be a string');\r\n        }\r\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\r\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\r\n        }\r\n        if (options) {\r\n            if (typeof options !== 'object') {\r\n                throw new TypeError('Channel options must be an object');\r\n            }\r\n        }\r\n        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);\r\n    }\r\n    close() {\r\n        this.internalChannel.close();\r\n    }\r\n    getTarget() {\r\n        return this.internalChannel.getTarget();\r\n    }\r\n    getConnectivityState(tryToConnect) {\r\n        return this.internalChannel.getConnectivityState(tryToConnect);\r\n    }\r\n    watchConnectivityState(currentState, deadline, callback) {\r\n        this.internalChannel.watchConnectivityState(currentState, deadline, callback);\r\n    }\r\n    /**\r\n     * Get the channelz reference object for this channel. The returned value is\r\n     * garbage if channelz is disabled for this channel.\r\n     * @returns\r\n     */\r\n    getChannelzRef() {\r\n        return this.internalChannel.getChannelzRef();\r\n    }\r\n    createCall(method, deadline, host, parentCall, propagateFlags) {\r\n        if (typeof method !== 'string') {\r\n            throw new TypeError('Channel#createCall: method must be a string');\r\n        }\r\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\r\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\r\n        }\r\n        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);\r\n    }\r\n}\r\nexports.ChannelImplementation = ChannelImplementation;\r\n//# sourceMappingURL=channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3Qiw4QkFBOEIsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC5qcz8yMjNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkNoYW5uZWxJbXBsZW1lbnRhdGlvbiA9IHZvaWQgMDtcclxuY29uc3QgY2hhbm5lbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1jcmVkZW50aWFsc1wiKTtcclxuY29uc3QgaW50ZXJuYWxfY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwtY2hhbm5lbFwiKTtcclxuY2xhc3MgQ2hhbm5lbEltcGxlbWVudGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgY3JlZGVudGlhbHMsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCB0YXJnZXQgbXVzdCBiZSBhIHN0cmluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShjcmVkZW50aWFscyBpbnN0YW5jZW9mIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgY3JlZGVudGlhbHMgbXVzdCBiZSBhIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbENoYW5uZWwgPSBuZXcgaW50ZXJuYWxfY2hhbm5lbF8xLkludGVybmFsQ2hhbm5lbCh0YXJnZXQsIGNyZWRlbnRpYWxzLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGNsb3NlKCkge1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxDaGFubmVsLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICBnZXRUYXJnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDaGFubmVsLmdldFRhcmdldCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUodHJ5VG9Db25uZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKHRyeVRvQ29ubmVjdCk7XHJcbiAgICB9XHJcbiAgICB3YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbENoYW5uZWwud2F0Y2hDb25uZWN0aXZpdHlTdGF0ZShjdXJyZW50U3RhdGUsIGRlYWRsaW5lLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY2hhbm5lbHogcmVmZXJlbmNlIG9iamVjdCBmb3IgdGhpcyBjaGFubmVsLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXNcclxuICAgICAqIGdhcmJhZ2UgaWYgY2hhbm5lbHogaXMgZGlzYWJsZWQgZm9yIHRoaXMgY2hhbm5lbC5cclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGdldENoYW5uZWx6UmVmKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQ2hhbm5lbC5nZXRDaGFubmVselJlZigpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IG1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHR5cGVvZiBkZWFkbGluZSA9PT0gJ251bWJlcicgfHwgZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IGRlYWRsaW5lIG11c3QgYmUgYSBudW1iZXIgb3IgRGF0ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuY3JlYXRlQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncyk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DaGFubmVsSW1wbGVtZW50YXRpb24gPSBDaGFubmVsSW1wbGVtZW50YXRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channelz.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2021 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst admin_1 = __webpack_require__(/*! ./admin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\r\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\r\nfunction channelRefToMessage(ref) {\r\n    return {\r\n        channel_id: ref.id,\r\n        name: ref.name,\r\n    };\r\n}\r\nfunction subchannelRefToMessage(ref) {\r\n    return {\r\n        subchannel_id: ref.id,\r\n        name: ref.name,\r\n    };\r\n}\r\nfunction serverRefToMessage(ref) {\r\n    return {\r\n        server_id: ref.id,\r\n    };\r\n}\r\nfunction socketRefToMessage(ref) {\r\n    return {\r\n        socket_id: ref.id,\r\n        name: ref.name,\r\n    };\r\n}\r\n/**\r\n * The loose upper bound on the number of events that should be retained in a\r\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\r\n * number that should be large enough to contain the recent relevant\r\n * information, but small enough to not use excessive memory.\r\n */\r\nconst TARGET_RETAINED_TRACES = 32;\r\nclass ChannelzTrace {\r\n    constructor() {\r\n        this.events = [];\r\n        this.eventsLogged = 0;\r\n        this.creationTimestamp = new Date();\r\n    }\r\n    addTrace(severity, description, child) {\r\n        const timestamp = new Date();\r\n        this.events.push({\r\n            description: description,\r\n            severity: severity,\r\n            timestamp: timestamp,\r\n            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\r\n            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined,\r\n        });\r\n        // Whenever the trace array gets too large, discard the first half\r\n        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\r\n            this.events = this.events.slice(TARGET_RETAINED_TRACES);\r\n        }\r\n        this.eventsLogged += 1;\r\n    }\r\n    getTraceMessage() {\r\n        return {\r\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\r\n            num_events_logged: this.eventsLogged,\r\n            events: this.events.map(event => {\r\n                return {\r\n                    description: event.description,\r\n                    severity: event.severity,\r\n                    timestamp: dateToProtoTimestamp(event.timestamp),\r\n                    channel_ref: event.childChannel\r\n                        ? channelRefToMessage(event.childChannel)\r\n                        : null,\r\n                    subchannel_ref: event.childSubchannel\r\n                        ? subchannelRefToMessage(event.childSubchannel)\r\n                        : null,\r\n                };\r\n            }),\r\n        };\r\n    }\r\n}\r\nexports.ChannelzTrace = ChannelzTrace;\r\nclass ChannelzChildrenTracker {\r\n    constructor() {\r\n        this.channelChildren = new Map();\r\n        this.subchannelChildren = new Map();\r\n        this.socketChildren = new Map();\r\n    }\r\n    refChild(child) {\r\n        var _a, _b, _c;\r\n        switch (child.kind) {\r\n            case 'channel': {\r\n                const trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : {\r\n                    ref: child,\r\n                    count: 0,\r\n                };\r\n                trackedChild.count += 1;\r\n                this.channelChildren.set(child.id, trackedChild);\r\n                break;\r\n            }\r\n            case 'subchannel': {\r\n                const trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : {\r\n                    ref: child,\r\n                    count: 0,\r\n                };\r\n                trackedChild.count += 1;\r\n                this.subchannelChildren.set(child.id, trackedChild);\r\n                break;\r\n            }\r\n            case 'socket': {\r\n                const trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : {\r\n                    ref: child,\r\n                    count: 0,\r\n                };\r\n                trackedChild.count += 1;\r\n                this.socketChildren.set(child.id, trackedChild);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    unrefChild(child) {\r\n        switch (child.kind) {\r\n            case 'channel': {\r\n                const trackedChild = this.channelChildren.get(child.id);\r\n                if (trackedChild !== undefined) {\r\n                    trackedChild.count -= 1;\r\n                    if (trackedChild.count === 0) {\r\n                        this.channelChildren.delete(child.id);\r\n                    }\r\n                    else {\r\n                        this.channelChildren.set(child.id, trackedChild);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case 'subchannel': {\r\n                const trackedChild = this.subchannelChildren.get(child.id);\r\n                if (trackedChild !== undefined) {\r\n                    trackedChild.count -= 1;\r\n                    if (trackedChild.count === 0) {\r\n                        this.subchannelChildren.delete(child.id);\r\n                    }\r\n                    else {\r\n                        this.subchannelChildren.set(child.id, trackedChild);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case 'socket': {\r\n                const trackedChild = this.socketChildren.get(child.id);\r\n                if (trackedChild !== undefined) {\r\n                    trackedChild.count -= 1;\r\n                    if (trackedChild.count === 0) {\r\n                        this.socketChildren.delete(child.id);\r\n                    }\r\n                    else {\r\n                        this.socketChildren.set(child.id, trackedChild);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    getChildLists() {\r\n        const channels = [];\r\n        for (const { ref } of this.channelChildren.values()) {\r\n            channels.push(ref);\r\n        }\r\n        const subchannels = [];\r\n        for (const { ref } of this.subchannelChildren.values()) {\r\n            subchannels.push(ref);\r\n        }\r\n        const sockets = [];\r\n        for (const { ref } of this.socketChildren.values()) {\r\n            sockets.push(ref);\r\n        }\r\n        return { channels, subchannels, sockets };\r\n    }\r\n}\r\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\r\nclass ChannelzCallTracker {\r\n    constructor() {\r\n        this.callsStarted = 0;\r\n        this.callsSucceeded = 0;\r\n        this.callsFailed = 0;\r\n        this.lastCallStartedTimestamp = null;\r\n    }\r\n    addCallStarted() {\r\n        this.callsStarted += 1;\r\n        this.lastCallStartedTimestamp = new Date();\r\n    }\r\n    addCallSucceeded() {\r\n        this.callsSucceeded += 1;\r\n    }\r\n    addCallFailed() {\r\n        this.callsFailed += 1;\r\n    }\r\n}\r\nexports.ChannelzCallTracker = ChannelzCallTracker;\r\nlet nextId = 1;\r\nfunction getNextId() {\r\n    return nextId++;\r\n}\r\nconst channels = [];\r\nconst subchannels = [];\r\nconst servers = [];\r\nconst sockets = [];\r\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\r\n    const id = getNextId();\r\n    const ref = { id, name, kind: 'channel' };\r\n    if (channelzEnabled) {\r\n        channels[id] = { ref, getInfo };\r\n    }\r\n    return ref;\r\n}\r\nexports.registerChannelzChannel = registerChannelzChannel;\r\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\r\n    const id = getNextId();\r\n    const ref = { id, name, kind: 'subchannel' };\r\n    if (channelzEnabled) {\r\n        subchannels[id] = { ref, getInfo };\r\n    }\r\n    return ref;\r\n}\r\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\r\nfunction registerChannelzServer(getInfo, channelzEnabled) {\r\n    const id = getNextId();\r\n    const ref = { id, kind: 'server' };\r\n    if (channelzEnabled) {\r\n        servers[id] = { ref, getInfo };\r\n    }\r\n    return ref;\r\n}\r\nexports.registerChannelzServer = registerChannelzServer;\r\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\r\n    const id = getNextId();\r\n    const ref = { id, name, kind: 'socket' };\r\n    if (channelzEnabled) {\r\n        sockets[id] = { ref, getInfo };\r\n    }\r\n    return ref;\r\n}\r\nexports.registerChannelzSocket = registerChannelzSocket;\r\nfunction unregisterChannelzRef(ref) {\r\n    switch (ref.kind) {\r\n        case 'channel':\r\n            delete channels[ref.id];\r\n            return;\r\n        case 'subchannel':\r\n            delete subchannels[ref.id];\r\n            return;\r\n        case 'server':\r\n            delete servers[ref.id];\r\n            return;\r\n        case 'socket':\r\n            delete sockets[ref.id];\r\n            return;\r\n    }\r\n}\r\nexports.unregisterChannelzRef = unregisterChannelzRef;\r\n/**\r\n * Parse a single section of an IPv6 address as two bytes\r\n * @param addressSection A hexadecimal string of length up to 4\r\n * @returns The pair of bytes representing this address section\r\n */\r\nfunction parseIPv6Section(addressSection) {\r\n    const numberValue = Number.parseInt(addressSection, 16);\r\n    return [(numberValue / 256) | 0, numberValue % 256];\r\n}\r\n/**\r\n * Parse a chunk of an IPv6 address string to some number of bytes\r\n * @param addressChunk Some number of segments of up to 4 hexadecimal\r\n *   characters each, joined by colons.\r\n * @returns The list of bytes representing this address chunk\r\n */\r\nfunction parseIPv6Chunk(addressChunk) {\r\n    if (addressChunk === '') {\r\n        return [];\r\n    }\r\n    const bytePairs = addressChunk\r\n        .split(':')\r\n        .map(section => parseIPv6Section(section));\r\n    const result = [];\r\n    return result.concat(...bytePairs);\r\n}\r\n/**\r\n * Converts an IPv4 or IPv6 address from string representation to binary\r\n * representation\r\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\r\n * @returns\r\n */\r\nfunction ipAddressStringToBuffer(ipAddress) {\r\n    if ((0, net_1.isIPv4)(ipAddress)) {\r\n        return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\r\n    }\r\n    else if ((0, net_1.isIPv6)(ipAddress)) {\r\n        let leftSection;\r\n        let rightSection;\r\n        const doubleColonIndex = ipAddress.indexOf('::');\r\n        if (doubleColonIndex === -1) {\r\n            leftSection = ipAddress;\r\n            rightSection = '';\r\n        }\r\n        else {\r\n            leftSection = ipAddress.substring(0, doubleColonIndex);\r\n            rightSection = ipAddress.substring(doubleColonIndex + 2);\r\n        }\r\n        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\r\n        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\r\n        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\r\n        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nfunction connectivityStateToMessage(state) {\r\n    switch (state) {\r\n        case connectivity_state_1.ConnectivityState.CONNECTING:\r\n            return {\r\n                state: 'CONNECTING',\r\n            };\r\n        case connectivity_state_1.ConnectivityState.IDLE:\r\n            return {\r\n                state: 'IDLE',\r\n            };\r\n        case connectivity_state_1.ConnectivityState.READY:\r\n            return {\r\n                state: 'READY',\r\n            };\r\n        case connectivity_state_1.ConnectivityState.SHUTDOWN:\r\n            return {\r\n                state: 'SHUTDOWN',\r\n            };\r\n        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\r\n            return {\r\n                state: 'TRANSIENT_FAILURE',\r\n            };\r\n        default:\r\n            return {\r\n                state: 'UNKNOWN',\r\n            };\r\n    }\r\n}\r\nfunction dateToProtoTimestamp(date) {\r\n    if (!date) {\r\n        return null;\r\n    }\r\n    const millisSinceEpoch = date.getTime();\r\n    return {\r\n        seconds: (millisSinceEpoch / 1000) | 0,\r\n        nanos: (millisSinceEpoch % 1000) * 1000000,\r\n    };\r\n}\r\nfunction getChannelMessage(channelEntry) {\r\n    const resolvedInfo = channelEntry.getInfo();\r\n    return {\r\n        ref: channelRefToMessage(channelEntry.ref),\r\n        data: {\r\n            target: resolvedInfo.target,\r\n            state: connectivityStateToMessage(resolvedInfo.state),\r\n            calls_started: resolvedInfo.callTracker.callsStarted,\r\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\r\n            calls_failed: resolvedInfo.callTracker.callsFailed,\r\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\r\n            trace: resolvedInfo.trace.getTraceMessage(),\r\n        },\r\n        channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\r\n        subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref)),\r\n    };\r\n}\r\nfunction GetChannel(call, callback) {\r\n    const channelId = Number.parseInt(call.request.channel_id);\r\n    const channelEntry = channels[channelId];\r\n    if (channelEntry === undefined) {\r\n        callback({\r\n            code: constants_1.Status.NOT_FOUND,\r\n            details: 'No channel data found for id ' + channelId,\r\n        });\r\n        return;\r\n    }\r\n    callback(null, { channel: getChannelMessage(channelEntry) });\r\n}\r\nfunction GetTopChannels(call, callback) {\r\n    const maxResults = Number.parseInt(call.request.max_results);\r\n    const resultList = [];\r\n    let i = Number.parseInt(call.request.start_channel_id);\r\n    for (; i < channels.length; i++) {\r\n        const channelEntry = channels[i];\r\n        if (channelEntry === undefined) {\r\n            continue;\r\n        }\r\n        resultList.push(getChannelMessage(channelEntry));\r\n        if (resultList.length >= maxResults) {\r\n            break;\r\n        }\r\n    }\r\n    callback(null, {\r\n        channel: resultList,\r\n        end: i >= servers.length,\r\n    });\r\n}\r\nfunction getServerMessage(serverEntry) {\r\n    const resolvedInfo = serverEntry.getInfo();\r\n    return {\r\n        ref: serverRefToMessage(serverEntry.ref),\r\n        data: {\r\n            calls_started: resolvedInfo.callTracker.callsStarted,\r\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\r\n            calls_failed: resolvedInfo.callTracker.callsFailed,\r\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\r\n            trace: resolvedInfo.trace.getTraceMessage(),\r\n        },\r\n        listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref)),\r\n    };\r\n}\r\nfunction GetServer(call, callback) {\r\n    const serverId = Number.parseInt(call.request.server_id);\r\n    const serverEntry = servers[serverId];\r\n    if (serverEntry === undefined) {\r\n        callback({\r\n            code: constants_1.Status.NOT_FOUND,\r\n            details: 'No server data found for id ' + serverId,\r\n        });\r\n        return;\r\n    }\r\n    callback(null, { server: getServerMessage(serverEntry) });\r\n}\r\nfunction GetServers(call, callback) {\r\n    const maxResults = Number.parseInt(call.request.max_results);\r\n    const resultList = [];\r\n    let i = Number.parseInt(call.request.start_server_id);\r\n    for (; i < servers.length; i++) {\r\n        const serverEntry = servers[i];\r\n        if (serverEntry === undefined) {\r\n            continue;\r\n        }\r\n        resultList.push(getServerMessage(serverEntry));\r\n        if (resultList.length >= maxResults) {\r\n            break;\r\n        }\r\n    }\r\n    callback(null, {\r\n        server: resultList,\r\n        end: i >= servers.length,\r\n    });\r\n}\r\nfunction GetSubchannel(call, callback) {\r\n    const subchannelId = Number.parseInt(call.request.subchannel_id);\r\n    const subchannelEntry = subchannels[subchannelId];\r\n    if (subchannelEntry === undefined) {\r\n        callback({\r\n            code: constants_1.Status.NOT_FOUND,\r\n            details: 'No subchannel data found for id ' + subchannelId,\r\n        });\r\n        return;\r\n    }\r\n    const resolvedInfo = subchannelEntry.getInfo();\r\n    const subchannelMessage = {\r\n        ref: subchannelRefToMessage(subchannelEntry.ref),\r\n        data: {\r\n            target: resolvedInfo.target,\r\n            state: connectivityStateToMessage(resolvedInfo.state),\r\n            calls_started: resolvedInfo.callTracker.callsStarted,\r\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\r\n            calls_failed: resolvedInfo.callTracker.callsFailed,\r\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\r\n            trace: resolvedInfo.trace.getTraceMessage(),\r\n        },\r\n        socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref)),\r\n    };\r\n    callback(null, { subchannel: subchannelMessage });\r\n}\r\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\r\n    var _a;\r\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {\r\n        return {\r\n            address: 'tcpip_address',\r\n            tcpip_address: {\r\n                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\r\n                port: subchannelAddress.port,\r\n            },\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            address: 'uds_address',\r\n            uds_address: {\r\n                filename: subchannelAddress.path,\r\n            },\r\n        };\r\n    }\r\n}\r\nfunction GetSocket(call, callback) {\r\n    var _a, _b, _c, _d, _e;\r\n    const socketId = Number.parseInt(call.request.socket_id);\r\n    const socketEntry = sockets[socketId];\r\n    if (socketEntry === undefined) {\r\n        callback({\r\n            code: constants_1.Status.NOT_FOUND,\r\n            details: 'No socket data found for id ' + socketId,\r\n        });\r\n        return;\r\n    }\r\n    const resolvedInfo = socketEntry.getInfo();\r\n    const securityMessage = resolvedInfo.security\r\n        ? {\r\n            model: 'tls',\r\n            tls: {\r\n                cipher_suite: resolvedInfo.security.cipherSuiteStandardName\r\n                    ? 'standard_name'\r\n                    : 'other_name',\r\n                standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\r\n                other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\r\n                local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\r\n                remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined,\r\n            },\r\n        }\r\n        : null;\r\n    const socketMessage = {\r\n        ref: socketRefToMessage(socketEntry.ref),\r\n        local: resolvedInfo.localAddress\r\n            ? subchannelAddressToAddressMessage(resolvedInfo.localAddress)\r\n            : null,\r\n        remote: resolvedInfo.remoteAddress\r\n            ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress)\r\n            : null,\r\n        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\r\n        security: securityMessage,\r\n        data: {\r\n            keep_alives_sent: resolvedInfo.keepAlivesSent,\r\n            streams_started: resolvedInfo.streamsStarted,\r\n            streams_succeeded: resolvedInfo.streamsSucceeded,\r\n            streams_failed: resolvedInfo.streamsFailed,\r\n            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\r\n            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\r\n            messages_received: resolvedInfo.messagesReceived,\r\n            messages_sent: resolvedInfo.messagesSent,\r\n            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\r\n            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\r\n            local_flow_control_window: resolvedInfo.localFlowControlWindow\r\n                ? { value: resolvedInfo.localFlowControlWindow }\r\n                : null,\r\n            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow\r\n                ? { value: resolvedInfo.remoteFlowControlWindow }\r\n                : null,\r\n        },\r\n    };\r\n    callback(null, { socket: socketMessage });\r\n}\r\nfunction GetServerSockets(call, callback) {\r\n    const serverId = Number.parseInt(call.request.server_id);\r\n    const serverEntry = servers[serverId];\r\n    if (serverEntry === undefined) {\r\n        callback({\r\n            code: constants_1.Status.NOT_FOUND,\r\n            details: 'No server data found for id ' + serverId,\r\n        });\r\n        return;\r\n    }\r\n    const startId = Number.parseInt(call.request.start_socket_id);\r\n    const maxResults = Number.parseInt(call.request.max_results);\r\n    const resolvedInfo = serverEntry.getInfo();\r\n    // If we wanted to include listener sockets in the result, this line would\r\n    // instead say\r\n    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\r\n    const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\r\n    const resultList = [];\r\n    let i = 0;\r\n    for (; i < allSockets.length; i++) {\r\n        if (allSockets[i].id >= startId) {\r\n            resultList.push(socketRefToMessage(allSockets[i]));\r\n            if (resultList.length >= maxResults) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    callback(null, {\r\n        socket_ref: resultList,\r\n        end: i >= allSockets.length,\r\n    });\r\n}\r\nfunction getChannelzHandlers() {\r\n    return {\r\n        GetChannel,\r\n        GetTopChannels,\r\n        GetServer,\r\n        GetServers,\r\n        GetSubchannel,\r\n        GetSocket,\r\n        GetServerSockets,\r\n    };\r\n}\r\nexports.getChannelzHandlers = getChannelzHandlers;\r\nlet loadedChannelzDefinition = null;\r\nfunction getChannelzServiceDefinition() {\r\n    if (loadedChannelzDefinition) {\r\n        return loadedChannelzDefinition;\r\n    }\r\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\r\n     * runtime for users who will not use/enable channelz. */\r\n    const loaderLoadSync = (__webpack_require__(/*! @grpc/proto-loader */ \"(rsc)/./node_modules/@grpc/proto-loader/build/src/index.js\").loadSync);\r\n    const loadedProto = loaderLoadSync('channelz.proto', {\r\n        keepCase: true,\r\n        longs: String,\r\n        enums: String,\r\n        defaults: true,\r\n        oneofs: true,\r\n        includeDirs: [`${__dirname}/../../proto`],\r\n    });\r\n    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);\r\n    loadedChannelzDefinition =\r\n        channelzGrpcObject.grpc.channelz.v1.Channelz.service;\r\n    return loadedChannelzDefinition;\r\n}\r\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\r\nfunction setup() {\r\n    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);\r\n}\r\nexports.setup = setup;\r\n//# sourceMappingURL=channelz.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsb0NBQW9DLEdBQUcsMkJBQTJCLEdBQUcsNkJBQTZCLEdBQUcsOEJBQThCLEdBQUcsOEJBQThCLEdBQUcsa0NBQWtDLEdBQUcsK0JBQStCLEdBQUcsMkJBQTJCLEdBQUcsK0JBQStCLEdBQUcscUJBQXFCO0FBQ25WLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLHNFQUFTO0FBQ2pDLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsMENBQTBDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCLHVDQUF1QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNIQUNWO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanM/YTBlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpIYW5kbGVycyA9IGV4cG9ydHMudW5yZWdpc3RlckNoYW5uZWx6UmVmID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U29ja2V0ID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U2VydmVyID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwgPSBleHBvcnRzLkNoYW5uZWx6Q2FsbFRyYWNrZXIgPSBleHBvcnRzLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyID0gZXhwb3J0cy5DaGFubmVselRyYWNlID0gdm9pZCAwO1xyXG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XHJcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XHJcbmNvbnN0IGFkbWluXzEgPSByZXF1aXJlKFwiLi9hZG1pblwiKTtcclxuY29uc3QgbWFrZV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL21ha2UtY2xpZW50XCIpO1xyXG5mdW5jdGlvbiBjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjaGFubmVsX2lkOiByZWYuaWQsXHJcbiAgICAgICAgbmFtZTogcmVmLm5hbWUsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHN1YmNoYW5uZWxSZWZUb01lc3NhZ2UocmVmKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1YmNoYW5uZWxfaWQ6IHJlZi5pZCxcclxuICAgICAgICBuYW1lOiByZWYubmFtZSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gc2VydmVyUmVmVG9NZXNzYWdlKHJlZikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzZXJ2ZXJfaWQ6IHJlZi5pZCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzb2NrZXRfaWQ6IHJlZi5pZCxcclxuICAgICAgICBuYW1lOiByZWYubmFtZSxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBsb29zZSB1cHBlciBib3VuZCBvbiB0aGUgbnVtYmVyIG9mIGV2ZW50cyB0aGF0IHNob3VsZCBiZSByZXRhaW5lZCBpbiBhXHJcbiAqIHRyYWNlLiBUaGlzIG1heSBiZSBleGNlZWRlZCBieSB1cCB0byBhIGZhY3RvciBvZiAyLiBBcmJpdHJhcmlseSBjaG9zZW4gYXMgYVxyXG4gKiBudW1iZXIgdGhhdCBzaG91bGQgYmUgbGFyZ2UgZW5vdWdoIHRvIGNvbnRhaW4gdGhlIHJlY2VudCByZWxldmFudFxyXG4gKiBpbmZvcm1hdGlvbiwgYnV0IHNtYWxsIGVub3VnaCB0byBub3QgdXNlIGV4Y2Vzc2l2ZSBtZW1vcnkuXHJcbiAqL1xyXG5jb25zdCBUQVJHRVRfUkVUQUlORURfVFJBQ0VTID0gMzI7XHJcbmNsYXNzIENoYW5uZWx6VHJhY2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLmV2ZW50c0xvZ2dlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5jcmVhdGlvblRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICB9XHJcbiAgICBhZGRUcmFjZShzZXZlcml0eSwgZGVzY3JpcHRpb24sIGNoaWxkKSB7XHJcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcclxuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICBzZXZlcml0eTogc2V2ZXJpdHksXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxyXG4gICAgICAgICAgICBjaGlsZENoYW5uZWw6IChjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGQua2luZCkgPT09ICdjaGFubmVsJyA/IGNoaWxkIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjaGlsZFN1YmNoYW5uZWw6IChjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGQua2luZCkgPT09ICdzdWJjaGFubmVsJyA/IGNoaWxkIDogdW5kZWZpbmVkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFdoZW5ldmVyIHRoZSB0cmFjZSBhcnJheSBnZXRzIHRvbyBsYXJnZSwgZGlzY2FyZCB0aGUgZmlyc3QgaGFsZlxyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50cy5sZW5ndGggPj0gVEFSR0VUX1JFVEFJTkVEX1RSQUNFUyAqIDIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cy5zbGljZShUQVJHRVRfUkVUQUlORURfVFJBQ0VTKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ldmVudHNMb2dnZWQgKz0gMTtcclxuICAgIH1cclxuICAgIGdldFRyYWNlTWVzc2FnZSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjcmVhdGlvbl90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHRoaXMuY3JlYXRpb25UaW1lc3RhbXApLFxyXG4gICAgICAgICAgICBudW1fZXZlbnRzX2xvZ2dlZDogdGhpcy5ldmVudHNMb2dnZWQsXHJcbiAgICAgICAgICAgIGV2ZW50czogdGhpcy5ldmVudHMubWFwKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGV2ZW50LmRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIHNldmVyaXR5OiBldmVudC5zZXZlcml0eSxcclxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKGV2ZW50LnRpbWVzdGFtcCksXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbF9yZWY6IGV2ZW50LmNoaWxkQ2hhbm5lbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNoYW5uZWxSZWZUb01lc3NhZ2UoZXZlbnQuY2hpbGRDaGFubmVsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbF9yZWY6IGV2ZW50LmNoaWxkU3ViY2hhbm5lbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN1YmNoYW5uZWxSZWZUb01lc3NhZ2UoZXZlbnQuY2hpbGRTdWJjaGFubmVsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ2hhbm5lbHpUcmFjZSA9IENoYW5uZWx6VHJhY2U7XHJcbmNsYXNzIENoYW5uZWx6Q2hpbGRyZW5UcmFja2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuc29ja2V0Q2hpbGRyZW4gPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICByZWZDaGlsZChjaGlsZCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHN3aXRjaCAoY2hpbGQua2luZCkge1xyXG4gICAgICAgICAgICBjYXNlICdjaGFubmVsJzoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tlZENoaWxkID0gKF9hID0gdGhpcy5jaGFubmVsQ2hpbGRyZW4uZ2V0KGNoaWxkLmlkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZjogY2hpbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IDAsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50ICs9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlICdzdWJjaGFubmVsJzoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tlZENoaWxkID0gKF9iID0gdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uZ2V0KGNoaWxkLmlkKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZjogY2hpbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IDAsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50ICs9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlICdzb2NrZXQnOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSAoX2MgPSB0aGlzLnNvY2tldENoaWxkcmVuLmdldChjaGlsZC5pZCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHtcclxuICAgICAgICAgICAgICAgICAgICByZWY6IGNoaWxkLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCArPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVucmVmQ2hpbGQoY2hpbGQpIHtcclxuICAgICAgICBzd2l0Y2ggKGNoaWxkLmtpbmQpIHtcclxuICAgICAgICAgICAgY2FzZSAnY2hhbm5lbCc6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrZWRDaGlsZCA9IHRoaXMuY2hhbm5lbENoaWxkcmVuLmdldChjaGlsZC5pZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkLmNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuLmRlbGV0ZShjaGlsZC5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnc3ViY2hhbm5lbCc6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrZWRDaGlsZCA9IHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLmdldChjaGlsZC5pZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkLmNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLmRlbGV0ZShjaGlsZC5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnc29ja2V0Jzoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tlZENoaWxkID0gdGhpcy5zb2NrZXRDaGlsZHJlbi5nZXQoY2hpbGQuaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50IC09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZC5jb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuLmRlbGV0ZShjaGlsZC5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldENoaWxkTGlzdHMoKSB7XHJcbiAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHsgcmVmIH0gb2YgdGhpcy5jaGFubmVsQ2hpbGRyZW4udmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgY2hhbm5lbHMucHVzaChyZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdWJjaGFubmVscyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgeyByZWYgfSBvZiB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBzdWJjaGFubmVscy5wdXNoKHJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNvY2tldHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHsgcmVmIH0gb2YgdGhpcy5zb2NrZXRDaGlsZHJlbi52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBzb2NrZXRzLnB1c2gocmVmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgY2hhbm5lbHMsIHN1YmNoYW5uZWxzLCBzb2NrZXRzIH07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DaGFubmVsekNoaWxkcmVuVHJhY2tlciA9IENoYW5uZWx6Q2hpbGRyZW5UcmFja2VyO1xyXG5jbGFzcyBDaGFubmVsekNhbGxUcmFja2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbHNTdGFydGVkID0gMDtcclxuICAgICAgICB0aGlzLmNhbGxzU3VjY2VlZGVkID0gMDtcclxuICAgICAgICB0aGlzLmNhbGxzRmFpbGVkID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBhZGRDYWxsU3RhcnRlZCgpIHtcclxuICAgICAgICB0aGlzLmNhbGxzU3RhcnRlZCArPSAxO1xyXG4gICAgICAgIHRoaXMubGFzdENhbGxTdGFydGVkVGltZXN0YW1wID0gbmV3IERhdGUoKTtcclxuICAgIH1cclxuICAgIGFkZENhbGxTdWNjZWVkZWQoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsc1N1Y2NlZWRlZCArPSAxO1xyXG4gICAgfVxyXG4gICAgYWRkQ2FsbEZhaWxlZCgpIHtcclxuICAgICAgICB0aGlzLmNhbGxzRmFpbGVkICs9IDE7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DaGFubmVsekNhbGxUcmFja2VyID0gQ2hhbm5lbHpDYWxsVHJhY2tlcjtcclxubGV0IG5leHRJZCA9IDE7XHJcbmZ1bmN0aW9uIGdldE5leHRJZCgpIHtcclxuICAgIHJldHVybiBuZXh0SWQrKztcclxufVxyXG5jb25zdCBjaGFubmVscyA9IFtdO1xyXG5jb25zdCBzdWJjaGFubmVscyA9IFtdO1xyXG5jb25zdCBzZXJ2ZXJzID0gW107XHJcbmNvbnN0IHNvY2tldHMgPSBbXTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJDaGFubmVsekNoYW5uZWwobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICBjb25zdCBpZCA9IGdldE5leHRJZCgpO1xyXG4gICAgY29uc3QgcmVmID0geyBpZCwgbmFtZSwga2luZDogJ2NoYW5uZWwnIH07XHJcbiAgICBpZiAoY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgY2hhbm5lbHNbaWRdID0geyByZWYsIGdldEluZm8gfTtcclxuICAgIH1cclxuICAgIHJldHVybiByZWY7XHJcbn1cclxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCA9IHJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsO1xyXG5mdW5jdGlvbiByZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbChuYW1lLCBnZXRJbmZvLCBjaGFubmVsekVuYWJsZWQpIHtcclxuICAgIGNvbnN0IGlkID0gZ2V0TmV4dElkKCk7XHJcbiAgICBjb25zdCByZWYgPSB7IGlkLCBuYW1lLCBraW5kOiAnc3ViY2hhbm5lbCcgfTtcclxuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICBzdWJjaGFubmVsc1tpZF0gPSB7IHJlZiwgZ2V0SW5mbyB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlZjtcclxufVxyXG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsID0gcmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWw7XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXIoZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICBjb25zdCBpZCA9IGdldE5leHRJZCgpO1xyXG4gICAgY29uc3QgcmVmID0geyBpZCwga2luZDogJ3NlcnZlcicgfTtcclxuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICBzZXJ2ZXJzW2lkXSA9IHsgcmVmLCBnZXRJbmZvIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVmO1xyXG59XHJcbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNlcnZlciA9IHJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXI7XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICBjb25zdCBpZCA9IGdldE5leHRJZCgpO1xyXG4gICAgY29uc3QgcmVmID0geyBpZCwgbmFtZSwga2luZDogJ3NvY2tldCcgfTtcclxuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICBzb2NrZXRzW2lkXSA9IHsgcmVmLCBnZXRJbmZvIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVmO1xyXG59XHJcbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNvY2tldCA9IHJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQ7XHJcbmZ1bmN0aW9uIHVucmVnaXN0ZXJDaGFubmVselJlZihyZWYpIHtcclxuICAgIHN3aXRjaCAocmVmLmtpbmQpIHtcclxuICAgICAgICBjYXNlICdjaGFubmVsJzpcclxuICAgICAgICAgICAgZGVsZXRlIGNoYW5uZWxzW3JlZi5pZF07XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjYXNlICdzdWJjaGFubmVsJzpcclxuICAgICAgICAgICAgZGVsZXRlIHN1YmNoYW5uZWxzW3JlZi5pZF07XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjYXNlICdzZXJ2ZXInOlxyXG4gICAgICAgICAgICBkZWxldGUgc2VydmVyc1tyZWYuaWRdO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY2FzZSAnc29ja2V0JzpcclxuICAgICAgICAgICAgZGVsZXRlIHNvY2tldHNbcmVmLmlkXTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMudW5yZWdpc3RlckNoYW5uZWx6UmVmID0gdW5yZWdpc3RlckNoYW5uZWx6UmVmO1xyXG4vKipcclxuICogUGFyc2UgYSBzaW5nbGUgc2VjdGlvbiBvZiBhbiBJUHY2IGFkZHJlc3MgYXMgdHdvIGJ5dGVzXHJcbiAqIEBwYXJhbSBhZGRyZXNzU2VjdGlvbiBBIGhleGFkZWNpbWFsIHN0cmluZyBvZiBsZW5ndGggdXAgdG8gNFxyXG4gKiBAcmV0dXJucyBUaGUgcGFpciBvZiBieXRlcyByZXByZXNlbnRpbmcgdGhpcyBhZGRyZXNzIHNlY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlSVB2NlNlY3Rpb24oYWRkcmVzc1NlY3Rpb24pIHtcclxuICAgIGNvbnN0IG51bWJlclZhbHVlID0gTnVtYmVyLnBhcnNlSW50KGFkZHJlc3NTZWN0aW9uLCAxNik7XHJcbiAgICByZXR1cm4gWyhudW1iZXJWYWx1ZSAvIDI1NikgfCAwLCBudW1iZXJWYWx1ZSAlIDI1Nl07XHJcbn1cclxuLyoqXHJcbiAqIFBhcnNlIGEgY2h1bmsgb2YgYW4gSVB2NiBhZGRyZXNzIHN0cmluZyB0byBzb21lIG51bWJlciBvZiBieXRlc1xyXG4gKiBAcGFyYW0gYWRkcmVzc0NodW5rIFNvbWUgbnVtYmVyIG9mIHNlZ21lbnRzIG9mIHVwIHRvIDQgaGV4YWRlY2ltYWxcclxuICogICBjaGFyYWN0ZXJzIGVhY2gsIGpvaW5lZCBieSBjb2xvbnMuXHJcbiAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGlzIGFkZHJlc3MgY2h1bmtcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlSVB2NkNodW5rKGFkZHJlc3NDaHVuaykge1xyXG4gICAgaWYgKGFkZHJlc3NDaHVuayA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBjb25zdCBieXRlUGFpcnMgPSBhZGRyZXNzQ2h1bmtcclxuICAgICAgICAuc3BsaXQoJzonKVxyXG4gICAgICAgIC5tYXAoc2VjdGlvbiA9PiBwYXJzZUlQdjZTZWN0aW9uKHNlY3Rpb24pKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoLi4uYnl0ZVBhaXJzKTtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgYW4gSVB2NCBvciBJUHY2IGFkZHJlc3MgZnJvbSBzdHJpbmcgcmVwcmVzZW50YXRpb24gdG8gYmluYXJ5XHJcbiAqIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSBpcEFkZHJlc3MgYW4gSVAgYWRkcmVzcyBpbiBzdGFuZGFyZCBJUHY0IG9yIElQdjYgdGV4dCBmb3JtYXRcclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIGlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyKGlwQWRkcmVzcykge1xyXG4gICAgaWYgKCgwLCBuZXRfMS5pc0lQdjQpKGlwQWRkcmVzcykpIHtcclxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oVWludDhBcnJheS5mcm9tKGlwQWRkcmVzcy5zcGxpdCgnLicpLm1hcChzZWdtZW50ID0+IE51bWJlci5wYXJzZUludChzZWdtZW50KSkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCgwLCBuZXRfMS5pc0lQdjYpKGlwQWRkcmVzcykpIHtcclxuICAgICAgICBsZXQgbGVmdFNlY3Rpb247XHJcbiAgICAgICAgbGV0IHJpZ2h0U2VjdGlvbjtcclxuICAgICAgICBjb25zdCBkb3VibGVDb2xvbkluZGV4ID0gaXBBZGRyZXNzLmluZGV4T2YoJzo6Jyk7XHJcbiAgICAgICAgaWYgKGRvdWJsZUNvbG9uSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGxlZnRTZWN0aW9uID0gaXBBZGRyZXNzO1xyXG4gICAgICAgICAgICByaWdodFNlY3Rpb24gPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlZnRTZWN0aW9uID0gaXBBZGRyZXNzLnN1YnN0cmluZygwLCBkb3VibGVDb2xvbkluZGV4KTtcclxuICAgICAgICAgICAgcmlnaHRTZWN0aW9uID0gaXBBZGRyZXNzLnN1YnN0cmluZyhkb3VibGVDb2xvbkluZGV4ICsgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlZnRCdWZmZXIgPSBCdWZmZXIuZnJvbShwYXJzZUlQdjZDaHVuayhsZWZ0U2VjdGlvbikpO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0QnVmZmVyID0gQnVmZmVyLmZyb20ocGFyc2VJUHY2Q2h1bmsocmlnaHRTZWN0aW9uKSk7XHJcbiAgICAgICAgY29uc3QgbWlkZGxlQnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2IC0gbGVmdEJ1ZmZlci5sZW5ndGggLSByaWdodEJ1ZmZlci5sZW5ndGgsIDApO1xyXG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtsZWZ0QnVmZmVyLCBtaWRkbGVCdWZmZXIsIHJpZ2h0QnVmZmVyXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb25uZWN0aXZpdHlTdGF0ZVRvTWVzc2FnZShzdGF0ZSkge1xyXG4gICAgc3dpdGNoIChzdGF0ZSkge1xyXG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORzpcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlOiAnQ09OTkVDVElORycsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdJRExFJyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdSRUFEWScsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTjpcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlOiAnU0hVVERPV04nLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkU6XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1RSQU5TSUVOVF9GQUlMVVJFJyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdVTktOT1dOJyxcclxuICAgICAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBkYXRlVG9Qcm90b1RpbWVzdGFtcChkYXRlKSB7XHJcbiAgICBpZiAoIWRhdGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IG1pbGxpc1NpbmNlRXBvY2ggPSBkYXRlLmdldFRpbWUoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2Vjb25kczogKG1pbGxpc1NpbmNlRXBvY2ggLyAxMDAwKSB8IDAsXHJcbiAgICAgICAgbmFub3M6IChtaWxsaXNTaW5jZUVwb2NoICUgMTAwMCkgKiAxMDAwMDAwLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRDaGFubmVsTWVzc2FnZShjaGFubmVsRW50cnkpIHtcclxuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IGNoYW5uZWxFbnRyeS5nZXRJbmZvKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlZjogY2hhbm5lbFJlZlRvTWVzc2FnZShjaGFubmVsRW50cnkucmVmKSxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIHRhcmdldDogcmVzb2x2ZWRJbmZvLnRhcmdldCxcclxuICAgICAgICAgICAgc3RhdGU6IGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHJlc29sdmVkSW5mby5zdGF0ZSksXHJcbiAgICAgICAgICAgIGNhbGxzX3N0YXJ0ZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXHJcbiAgICAgICAgICAgIGNhbGxzX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxyXG4gICAgICAgICAgICBjYWxsc19mYWlsZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc0ZhaWxlZCxcclxuICAgICAgICAgICAgbGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wKSxcclxuICAgICAgICAgICAgdHJhY2U6IHJlc29sdmVkSW5mby50cmFjZS5nZXRUcmFjZU1lc3NhZ2UoKSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNoYW5uZWxfcmVmOiByZXNvbHZlZEluZm8uY2hpbGRyZW4uY2hhbm5lbHMubWFwKHJlZiA9PiBjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikpLFxyXG4gICAgICAgIHN1YmNoYW5uZWxfcmVmOiByZXNvbHZlZEluZm8uY2hpbGRyZW4uc3ViY2hhbm5lbHMubWFwKHJlZiA9PiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBHZXRDaGFubmVsKGNhbGwsIGNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBjaGFubmVsSWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LmNoYW5uZWxfaWQpO1xyXG4gICAgY29uc3QgY2hhbm5lbEVudHJ5ID0gY2hhbm5lbHNbY2hhbm5lbElkXTtcclxuICAgIGlmIChjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNhbGxiYWNrKHtcclxuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcclxuICAgICAgICAgICAgZGV0YWlsczogJ05vIGNoYW5uZWwgZGF0YSBmb3VuZCBmb3IgaWQgJyArIGNoYW5uZWxJZCxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjYWxsYmFjayhudWxsLCB7IGNoYW5uZWw6IGdldENoYW5uZWxNZXNzYWdlKGNoYW5uZWxFbnRyeSkgfSk7XHJcbn1cclxuZnVuY3Rpb24gR2V0VG9wQ2hhbm5lbHMoY2FsbCwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IG1heFJlc3VsdHMgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0Lm1heF9yZXN1bHRzKTtcclxuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcclxuICAgIGxldCBpID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zdGFydF9jaGFubmVsX2lkKTtcclxuICAgIGZvciAoOyBpIDwgY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGFubmVsRW50cnkgPSBjaGFubmVsc1tpXTtcclxuICAgICAgICBpZiAoY2hhbm5lbEVudHJ5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdExpc3QucHVzaChnZXRDaGFubmVsTWVzc2FnZShjaGFubmVsRW50cnkpKTtcclxuICAgICAgICBpZiAocmVzdWx0TGlzdC5sZW5ndGggPj0gbWF4UmVzdWx0cykge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYWxsYmFjayhudWxsLCB7XHJcbiAgICAgICAgY2hhbm5lbDogcmVzdWx0TGlzdCxcclxuICAgICAgICBlbmQ6IGkgPj0gc2VydmVycy5sZW5ndGgsXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRTZXJ2ZXJNZXNzYWdlKHNlcnZlckVudHJ5KSB7XHJcbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBzZXJ2ZXJFbnRyeS5nZXRJbmZvKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlZjogc2VydmVyUmVmVG9NZXNzYWdlKHNlcnZlckVudHJ5LnJlZiksXHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICBjYWxsc19zdGFydGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdGFydGVkLFxyXG4gICAgICAgICAgICBjYWxsc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcclxuICAgICAgICAgICAgY2FsbHNfZmFpbGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNGYWlsZWQsXHJcbiAgICAgICAgICAgIGxhc3RfY2FsbF9zdGFydGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCksXHJcbiAgICAgICAgICAgIHRyYWNlOiByZXNvbHZlZEluZm8udHJhY2UuZ2V0VHJhY2VNZXNzYWdlKCksXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaXN0ZW5fc29ja2V0OiByZXNvbHZlZEluZm8ubGlzdGVuZXJDaGlsZHJlbi5zb2NrZXRzLm1hcChyZWYgPT4gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikpLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBHZXRTZXJ2ZXIoY2FsbCwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IHNlcnZlcklkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zZXJ2ZXJfaWQpO1xyXG4gICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJzW3NlcnZlcklkXTtcclxuICAgIGlmIChzZXJ2ZXJFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY2FsbGJhY2soe1xyXG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxyXG4gICAgICAgICAgICBkZXRhaWxzOiAnTm8gc2VydmVyIGRhdGEgZm91bmQgZm9yIGlkICcgKyBzZXJ2ZXJJZCxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjYWxsYmFjayhudWxsLCB7IHNlcnZlcjogZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkgfSk7XHJcbn1cclxuZnVuY3Rpb24gR2V0U2VydmVycyhjYWxsLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3QubWF4X3Jlc3VsdHMpO1xyXG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdO1xyXG4gICAgbGV0IGkgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN0YXJ0X3NlcnZlcl9pZCk7XHJcbiAgICBmb3IgKDsgaSA8IHNlcnZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBzZXJ2ZXJFbnRyeSA9IHNlcnZlcnNbaV07XHJcbiAgICAgICAgaWYgKHNlcnZlckVudHJ5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdExpc3QucHVzaChnZXRTZXJ2ZXJNZXNzYWdlKHNlcnZlckVudHJ5KSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdExpc3QubGVuZ3RoID49IG1heFJlc3VsdHMpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2FsbGJhY2sobnVsbCwge1xyXG4gICAgICAgIHNlcnZlcjogcmVzdWx0TGlzdCxcclxuICAgICAgICBlbmQ6IGkgPj0gc2VydmVycy5sZW5ndGgsXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBHZXRTdWJjaGFubmVsKGNhbGwsIGNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBzdWJjaGFubmVsSWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN1YmNoYW5uZWxfaWQpO1xyXG4gICAgY29uc3Qgc3ViY2hhbm5lbEVudHJ5ID0gc3ViY2hhbm5lbHNbc3ViY2hhbm5lbElkXTtcclxuICAgIGlmIChzdWJjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNhbGxiYWNrKHtcclxuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcclxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHN1YmNoYW5uZWwgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHN1YmNoYW5uZWxJZCxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBzdWJjaGFubmVsRW50cnkuZ2V0SW5mbygpO1xyXG4gICAgY29uc3Qgc3ViY2hhbm5lbE1lc3NhZ2UgPSB7XHJcbiAgICAgICAgcmVmOiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHN1YmNoYW5uZWxFbnRyeS5yZWYpLFxyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgdGFyZ2V0OiByZXNvbHZlZEluZm8udGFyZ2V0LFxyXG4gICAgICAgICAgICBzdGF0ZTogY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2UocmVzb2x2ZWRJbmZvLnN0YXRlKSxcclxuICAgICAgICAgICAgY2FsbHNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3RhcnRlZCxcclxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXHJcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxyXG4gICAgICAgICAgICBsYXN0X2NhbGxfc3RhcnRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXApLFxyXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc29ja2V0X3JlZjogcmVzb2x2ZWRJbmZvLmNoaWxkcmVuLnNvY2tldHMubWFwKHJlZiA9PiBzb2NrZXRSZWZUb01lc3NhZ2UocmVmKSksXHJcbiAgICB9O1xyXG4gICAgY2FsbGJhY2sobnVsbCwgeyBzdWJjaGFubmVsOiBzdWJjaGFubmVsTWVzc2FnZSB9KTtcclxufVxyXG5mdW5jdGlvbiBzdWJjaGFubmVsQWRkcmVzc1RvQWRkcmVzc01lc3NhZ2Uoc3ViY2hhbm5lbEFkZHJlc3MpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmICgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcykoc3ViY2hhbm5lbEFkZHJlc3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWRkcmVzczogJ3RjcGlwX2FkZHJlc3MnLFxyXG4gICAgICAgICAgICB0Y3BpcF9hZGRyZXNzOiB7XHJcbiAgICAgICAgICAgICAgICBpcF9hZGRyZXNzOiAoX2EgPSBpcEFkZHJlc3NTdHJpbmdUb0J1ZmZlcihzdWJjaGFubmVsQWRkcmVzcy5ob3N0KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgcG9ydDogc3ViY2hhbm5lbEFkZHJlc3MucG9ydCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWRkcmVzczogJ3Vkc19hZGRyZXNzJyxcclxuICAgICAgICAgICAgdWRzX2FkZHJlc3M6IHtcclxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBzdWJjaGFubmVsQWRkcmVzcy5wYXRoLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gR2V0U29ja2V0KGNhbGwsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xyXG4gICAgY29uc3Qgc29ja2V0SWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNvY2tldF9pZCk7XHJcbiAgICBjb25zdCBzb2NrZXRFbnRyeSA9IHNvY2tldHNbc29ja2V0SWRdO1xyXG4gICAgaWYgKHNvY2tldEVudHJ5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjYWxsYmFjayh7XHJcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXHJcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzb2NrZXQgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNvY2tldElkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNvY2tldEVudHJ5LmdldEluZm8oKTtcclxuICAgIGNvbnN0IHNlY3VyaXR5TWVzc2FnZSA9IHJlc29sdmVkSW5mby5zZWN1cml0eVxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBtb2RlbDogJ3RscycsXHJcbiAgICAgICAgICAgIHRsczoge1xyXG4gICAgICAgICAgICAgICAgY2lwaGVyX3N1aXRlOiByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWVcclxuICAgICAgICAgICAgICAgICAgICA/ICdzdGFuZGFyZF9uYW1lJ1xyXG4gICAgICAgICAgICAgICAgICAgIDogJ290aGVyX25hbWUnLFxyXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRfbmFtZTogKF9hID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmNpcGhlclN1aXRlU3RhbmRhcmROYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBvdGhlcl9uYW1lOiAoX2IgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVPdGhlck5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGxvY2FsX2NlcnRpZmljYXRlOiAoX2MgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkubG9jYWxDZXJ0aWZpY2F0ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgcmVtb3RlX2NlcnRpZmljYXRlOiAoX2QgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkucmVtb3RlQ2VydGlmaWNhdGUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9XHJcbiAgICAgICAgOiBudWxsO1xyXG4gICAgY29uc3Qgc29ja2V0TWVzc2FnZSA9IHtcclxuICAgICAgICByZWY6IHNvY2tldFJlZlRvTWVzc2FnZShzb2NrZXRFbnRyeS5yZWYpLFxyXG4gICAgICAgIGxvY2FsOiByZXNvbHZlZEluZm8ubG9jYWxBZGRyZXNzXHJcbiAgICAgICAgICAgID8gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHJlc29sdmVkSW5mby5sb2NhbEFkZHJlc3MpXHJcbiAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICByZW1vdGU6IHJlc29sdmVkSW5mby5yZW1vdGVBZGRyZXNzXHJcbiAgICAgICAgICAgID8gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHJlc29sdmVkSW5mby5yZW1vdGVBZGRyZXNzKVxyXG4gICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgcmVtb3RlX25hbWU6IChfZSA9IHJlc29sdmVkSW5mby5yZW1vdGVOYW1lKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgc2VjdXJpdHk6IHNlY3VyaXR5TWVzc2FnZSxcclxuICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIGtlZXBfYWxpdmVzX3NlbnQ6IHJlc29sdmVkSW5mby5rZWVwQWxpdmVzU2VudCxcclxuICAgICAgICAgICAgc3RyZWFtc19zdGFydGVkOiByZXNvbHZlZEluZm8uc3RyZWFtc1N0YXJ0ZWQsXHJcbiAgICAgICAgICAgIHN0cmVhbXNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uc3RyZWFtc1N1Y2NlZWRlZCxcclxuICAgICAgICAgICAgc3RyZWFtc19mYWlsZWQ6IHJlc29sdmVkSW5mby5zdHJlYW1zRmFpbGVkLFxyXG4gICAgICAgICAgICBsYXN0X2xvY2FsX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXApLFxyXG4gICAgICAgICAgICBsYXN0X3JlbW90ZV9zdHJlYW1fY3JlYXRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCksXHJcbiAgICAgICAgICAgIG1lc3NhZ2VzX3JlY2VpdmVkOiByZXNvbHZlZEluZm8ubWVzc2FnZXNSZWNlaXZlZCxcclxuICAgICAgICAgICAgbWVzc2FnZXNfc2VudDogcmVzb2x2ZWRJbmZvLm1lc3NhZ2VzU2VudCxcclxuICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3JlY2VpdmVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXApLFxyXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2Vfc2VudF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXApLFxyXG4gICAgICAgICAgICBsb2NhbF9mbG93X2NvbnRyb2xfd2luZG93OiByZXNvbHZlZEluZm8ubG9jYWxGbG93Q29udHJvbFdpbmRvd1xyXG4gICAgICAgICAgICAgICAgPyB7IHZhbHVlOiByZXNvbHZlZEluZm8ubG9jYWxGbG93Q29udHJvbFdpbmRvdyB9XHJcbiAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgIHJlbW90ZV9mbG93X2NvbnRyb2xfd2luZG93OiByZXNvbHZlZEluZm8ucmVtb3RlRmxvd0NvbnRyb2xXaW5kb3dcclxuICAgICAgICAgICAgICAgID8geyB2YWx1ZTogcmVzb2x2ZWRJbmZvLnJlbW90ZUZsb3dDb250cm9sV2luZG93IH1cclxuICAgICAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIGNhbGxiYWNrKG51bGwsIHsgc29ja2V0OiBzb2NrZXRNZXNzYWdlIH0pO1xyXG59XHJcbmZ1bmN0aW9uIEdldFNlcnZlclNvY2tldHMoY2FsbCwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IHNlcnZlcklkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zZXJ2ZXJfaWQpO1xyXG4gICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJzW3NlcnZlcklkXTtcclxuICAgIGlmIChzZXJ2ZXJFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY2FsbGJhY2soe1xyXG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxyXG4gICAgICAgICAgICBkZXRhaWxzOiAnTm8gc2VydmVyIGRhdGEgZm91bmQgZm9yIGlkICcgKyBzZXJ2ZXJJZCxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydElkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zdGFydF9zb2NrZXRfaWQpO1xyXG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3QubWF4X3Jlc3VsdHMpO1xyXG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc2VydmVyRW50cnkuZ2V0SW5mbygpO1xyXG4gICAgLy8gSWYgd2Ugd2FudGVkIHRvIGluY2x1ZGUgbGlzdGVuZXIgc29ja2V0cyBpbiB0aGUgcmVzdWx0LCB0aGlzIGxpbmUgd291bGRcclxuICAgIC8vIGluc3RlYWQgc2F5XHJcbiAgICAvLyBjb25zdCBhbGxTb2NrZXRzID0gcmVzb2x2ZWRJbmZvLmxpc3RlbmVyQ2hpbGRyZW4uc29ja2V0cy5jb25jYXQocmVzb2x2ZWRJbmZvLnNlc3Npb25DaGlsZHJlbi5zb2NrZXRzKS5zb3J0KChyZWYxLCByZWYyKSA9PiByZWYxLmlkIC0gcmVmMi5pZCk7XHJcbiAgICBjb25zdCBhbGxTb2NrZXRzID0gcmVzb2x2ZWRJbmZvLnNlc3Npb25DaGlsZHJlbi5zb2NrZXRzLnNvcnQoKHJlZjEsIHJlZjIpID0+IHJlZjEuaWQgLSByZWYyLmlkKTtcclxuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGZvciAoOyBpIDwgYWxsU29ja2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChhbGxTb2NrZXRzW2ldLmlkID49IHN0YXJ0SWQpIHtcclxuICAgICAgICAgICAgcmVzdWx0TGlzdC5wdXNoKHNvY2tldFJlZlRvTWVzc2FnZShhbGxTb2NrZXRzW2ldKSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRMaXN0Lmxlbmd0aCA+PSBtYXhSZXN1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhbGxiYWNrKG51bGwsIHtcclxuICAgICAgICBzb2NrZXRfcmVmOiByZXN1bHRMaXN0LFxyXG4gICAgICAgIGVuZDogaSA+PSBhbGxTb2NrZXRzLmxlbmd0aCxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldENoYW5uZWx6SGFuZGxlcnMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIEdldENoYW5uZWwsXHJcbiAgICAgICAgR2V0VG9wQ2hhbm5lbHMsXHJcbiAgICAgICAgR2V0U2VydmVyLFxyXG4gICAgICAgIEdldFNlcnZlcnMsXHJcbiAgICAgICAgR2V0U3ViY2hhbm5lbCxcclxuICAgICAgICBHZXRTb2NrZXQsXHJcbiAgICAgICAgR2V0U2VydmVyU29ja2V0cyxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRDaGFubmVsekhhbmRsZXJzID0gZ2V0Q2hhbm5lbHpIYW5kbGVycztcclxubGV0IGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbiA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24oKSB7XHJcbiAgICBpZiAobG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbjtcclxuICAgIH1cclxuICAgIC8qIFRoZSBwdXJwb3NlIG9mIHRoaXMgY29tcGxleGl0eSBpcyB0byBhdm9pZCBsb2FkaW5nIEBncnBjL3Byb3RvLWxvYWRlciBhdFxyXG4gICAgICogcnVudGltZSBmb3IgdXNlcnMgd2hvIHdpbGwgbm90IHVzZS9lbmFibGUgY2hhbm5lbHouICovXHJcbiAgICBjb25zdCBsb2FkZXJMb2FkU3luYyA9IHJlcXVpcmUoJ0BncnBjL3Byb3RvLWxvYWRlcicpXHJcbiAgICAgICAgLmxvYWRTeW5jO1xyXG4gICAgY29uc3QgbG9hZGVkUHJvdG8gPSBsb2FkZXJMb2FkU3luYygnY2hhbm5lbHoucHJvdG8nLCB7XHJcbiAgICAgICAga2VlcENhc2U6IHRydWUsXHJcbiAgICAgICAgbG9uZ3M6IFN0cmluZyxcclxuICAgICAgICBlbnVtczogU3RyaW5nLFxyXG4gICAgICAgIGRlZmF1bHRzOiB0cnVlLFxyXG4gICAgICAgIG9uZW9mczogdHJ1ZSxcclxuICAgICAgICBpbmNsdWRlRGlyczogW2Ake19fZGlybmFtZX0vLi4vLi4vcHJvdG9gXSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgY2hhbm5lbHpHcnBjT2JqZWN0ID0gKDAsIG1ha2VfY2xpZW50XzEubG9hZFBhY2thZ2VEZWZpbml0aW9uKShsb2FkZWRQcm90byk7XHJcbiAgICBsb2FkZWRDaGFubmVsekRlZmluaXRpb24gPVxyXG4gICAgICAgIGNoYW5uZWx6R3JwY09iamVjdC5ncnBjLmNoYW5uZWx6LnYxLkNoYW5uZWx6LnNlcnZpY2U7XHJcbiAgICByZXR1cm4gbG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uO1xyXG59XHJcbmV4cG9ydHMuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiA9IGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb247XHJcbmZ1bmN0aW9uIHNldHVwKCkge1xyXG4gICAgKDAsIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2UpKGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24sIGdldENoYW5uZWx6SGFuZGxlcnMpO1xyXG59XHJcbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbHouanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\");\r\n/**\r\n * Error class associated with passing both interceptors and interceptor\r\n * providers to a client constructor or as call options.\r\n */\r\nclass InterceptorConfigurationError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n        this.name = 'InterceptorConfigurationError';\r\n        Error.captureStackTrace(this, InterceptorConfigurationError);\r\n    }\r\n}\r\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\r\nclass ListenerBuilder {\r\n    constructor() {\r\n        this.metadata = undefined;\r\n        this.message = undefined;\r\n        this.status = undefined;\r\n    }\r\n    withOnReceiveMetadata(onReceiveMetadata) {\r\n        this.metadata = onReceiveMetadata;\r\n        return this;\r\n    }\r\n    withOnReceiveMessage(onReceiveMessage) {\r\n        this.message = onReceiveMessage;\r\n        return this;\r\n    }\r\n    withOnReceiveStatus(onReceiveStatus) {\r\n        this.status = onReceiveStatus;\r\n        return this;\r\n    }\r\n    build() {\r\n        return {\r\n            onReceiveMetadata: this.metadata,\r\n            onReceiveMessage: this.message,\r\n            onReceiveStatus: this.status,\r\n        };\r\n    }\r\n}\r\nexports.ListenerBuilder = ListenerBuilder;\r\nclass RequesterBuilder {\r\n    constructor() {\r\n        this.start = undefined;\r\n        this.message = undefined;\r\n        this.halfClose = undefined;\r\n        this.cancel = undefined;\r\n    }\r\n    withStart(start) {\r\n        this.start = start;\r\n        return this;\r\n    }\r\n    withSendMessage(sendMessage) {\r\n        this.message = sendMessage;\r\n        return this;\r\n    }\r\n    withHalfClose(halfClose) {\r\n        this.halfClose = halfClose;\r\n        return this;\r\n    }\r\n    withCancel(cancel) {\r\n        this.cancel = cancel;\r\n        return this;\r\n    }\r\n    build() {\r\n        return {\r\n            start: this.start,\r\n            sendMessage: this.message,\r\n            halfClose: this.halfClose,\r\n            cancel: this.cancel,\r\n        };\r\n    }\r\n}\r\nexports.RequesterBuilder = RequesterBuilder;\r\n/**\r\n * A Listener with a default pass-through implementation of each method. Used\r\n * for filling out Listeners with some methods omitted.\r\n */\r\nconst defaultListener = {\r\n    onReceiveMetadata: (metadata, next) => {\r\n        next(metadata);\r\n    },\r\n    onReceiveMessage: (message, next) => {\r\n        next(message);\r\n    },\r\n    onReceiveStatus: (status, next) => {\r\n        next(status);\r\n    },\r\n};\r\n/**\r\n * A Requester with a default pass-through implementation of each method. Used\r\n * for filling out Requesters with some methods omitted.\r\n */\r\nconst defaultRequester = {\r\n    start: (metadata, listener, next) => {\r\n        next(metadata, listener);\r\n    },\r\n    sendMessage: (message, next) => {\r\n        next(message);\r\n    },\r\n    halfClose: next => {\r\n        next();\r\n    },\r\n    cancel: next => {\r\n        next();\r\n    },\r\n};\r\nclass InterceptingCall {\r\n    constructor(nextCall, requester) {\r\n        var _a, _b, _c, _d;\r\n        this.nextCall = nextCall;\r\n        /**\r\n         * Indicates that metadata has been passed to the requester's start\r\n         * method but it has not been passed to the corresponding next callback\r\n         */\r\n        this.processingMetadata = false;\r\n        /**\r\n         * Message context for a pending message that is waiting for\r\n         */\r\n        this.pendingMessageContext = null;\r\n        /**\r\n         * Indicates that a message has been passed to the requester's sendMessage\r\n         * method but it has not been passed to the corresponding next callback\r\n         */\r\n        this.processingMessage = false;\r\n        /**\r\n         * Indicates that a status was received but could not be propagated because\r\n         * a message was still being processed.\r\n         */\r\n        this.pendingHalfClose = false;\r\n        if (requester) {\r\n            this.requester = {\r\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\r\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\r\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\r\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel,\r\n            };\r\n        }\r\n        else {\r\n            this.requester = defaultRequester;\r\n        }\r\n    }\r\n    cancelWithStatus(status, details) {\r\n        this.requester.cancel(() => {\r\n            this.nextCall.cancelWithStatus(status, details);\r\n        });\r\n    }\r\n    getPeer() {\r\n        return this.nextCall.getPeer();\r\n    }\r\n    processPendingMessage() {\r\n        if (this.pendingMessageContext) {\r\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\r\n            this.pendingMessageContext = null;\r\n            this.pendingMessage = null;\r\n        }\r\n    }\r\n    processPendingHalfClose() {\r\n        if (this.pendingHalfClose) {\r\n            this.nextCall.halfClose();\r\n        }\r\n    }\r\n    start(metadata, interceptingListener) {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        const fullInterceptingListener = {\r\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata => { }),\r\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message => { }),\r\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status => { }),\r\n        };\r\n        this.processingMetadata = true;\r\n        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\r\n            var _a, _b, _c;\r\n            this.processingMetadata = false;\r\n            let finalInterceptingListener;\r\n            if ((0, call_interface_1.isInterceptingListener)(listener)) {\r\n                finalInterceptingListener = listener;\r\n            }\r\n            else {\r\n                const fullListener = {\r\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\r\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\r\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus,\r\n                };\r\n                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\r\n            }\r\n            this.nextCall.start(md, finalInterceptingListener);\r\n            this.processPendingMessage();\r\n            this.processPendingHalfClose();\r\n        });\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    sendMessageWithContext(context, message) {\r\n        this.processingMessage = true;\r\n        this.requester.sendMessage(message, finalMessage => {\r\n            this.processingMessage = false;\r\n            if (this.processingMetadata) {\r\n                this.pendingMessageContext = context;\r\n                this.pendingMessage = message;\r\n            }\r\n            else {\r\n                this.nextCall.sendMessageWithContext(context, finalMessage);\r\n                this.processPendingHalfClose();\r\n            }\r\n        });\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    sendMessage(message) {\r\n        this.sendMessageWithContext({}, message);\r\n    }\r\n    startRead() {\r\n        this.nextCall.startRead();\r\n    }\r\n    halfClose() {\r\n        this.requester.halfClose(() => {\r\n            if (this.processingMetadata || this.processingMessage) {\r\n                this.pendingHalfClose = true;\r\n            }\r\n            else {\r\n                this.nextCall.halfClose();\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.InterceptingCall = InterceptingCall;\r\nfunction getCall(channel, path, options) {\r\n    var _a, _b;\r\n    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\r\n    const host = options.host;\r\n    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\r\n    const propagateFlags = options.propagate_flags;\r\n    const credentials = options.credentials;\r\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\r\n    if (credentials) {\r\n        call.setCredentials(credentials);\r\n    }\r\n    return call;\r\n}\r\n/**\r\n * InterceptingCall implementation that directly owns the underlying Call\r\n * object and handles serialization and deseraizliation.\r\n */\r\nclass BaseInterceptingCall {\r\n    constructor(call, \r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    methodDefinition) {\r\n        this.call = call;\r\n        this.methodDefinition = methodDefinition;\r\n    }\r\n    cancelWithStatus(status, details) {\r\n        this.call.cancelWithStatus(status, details);\r\n    }\r\n    getPeer() {\r\n        return this.call.getPeer();\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    sendMessageWithContext(context, message) {\r\n        let serialized;\r\n        try {\r\n            serialized = this.methodDefinition.requestSerialize(message);\r\n        }\r\n        catch (e) {\r\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);\r\n            return;\r\n        }\r\n        this.call.sendMessageWithContext(context, serialized);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    sendMessage(message) {\r\n        this.sendMessageWithContext({}, message);\r\n    }\r\n    start(metadata, interceptingListener) {\r\n        let readError = null;\r\n        this.call.start(metadata, {\r\n            onReceiveMetadata: metadata => {\r\n                var _a;\r\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\r\n            },\r\n            onReceiveMessage: message => {\r\n                var _a;\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                let deserialized;\r\n                try {\r\n                    deserialized = this.methodDefinition.responseDeserialize(message);\r\n                }\r\n                catch (e) {\r\n                    readError = {\r\n                        code: constants_1.Status.INTERNAL,\r\n                        details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,\r\n                        metadata: new metadata_1.Metadata(),\r\n                    };\r\n                    this.call.cancelWithStatus(readError.code, readError.details);\r\n                    return;\r\n                }\r\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\r\n            },\r\n            onReceiveStatus: status => {\r\n                var _a, _b;\r\n                if (readError) {\r\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\r\n                }\r\n                else {\r\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\r\n                }\r\n            },\r\n        });\r\n    }\r\n    startRead() {\r\n        this.call.startRead();\r\n    }\r\n    halfClose() {\r\n        this.call.halfClose();\r\n    }\r\n}\r\n/**\r\n * BaseInterceptingCall with special-cased behavior for methods with unary\r\n * responses.\r\n */\r\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    constructor(call, methodDefinition) {\r\n        super(call, methodDefinition);\r\n    }\r\n    start(metadata, listener) {\r\n        var _a, _b;\r\n        let receivedMessage = false;\r\n        const wrapperListener = {\r\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata => { }),\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            onReceiveMessage: (message) => {\r\n                var _a;\r\n                receivedMessage = true;\r\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\r\n            },\r\n            onReceiveStatus: (status) => {\r\n                var _a, _b;\r\n                if (!receivedMessage) {\r\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\r\n                }\r\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\r\n            },\r\n        };\r\n        super.start(metadata, wrapperListener);\r\n        this.call.startRead();\r\n    }\r\n}\r\n/**\r\n * BaseInterceptingCall with special-cased behavior for methods with streaming\r\n * responses.\r\n */\r\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {\r\n}\r\nfunction getBottomInterceptingCall(channel, options, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nmethodDefinition) {\r\n    const call = getCall(channel, methodDefinition.path, options);\r\n    if (methodDefinition.responseStream) {\r\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\r\n    }\r\n    else {\r\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\r\n    }\r\n}\r\nfunction getInterceptingCall(interceptorArgs, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nmethodDefinition, options, channel) {\r\n    if (interceptorArgs.clientInterceptors.length > 0 &&\r\n        interceptorArgs.clientInterceptorProviders.length > 0) {\r\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +\r\n            'to the client constructor. Only one of these is allowed.');\r\n    }\r\n    if (interceptorArgs.callInterceptors.length > 0 &&\r\n        interceptorArgs.callInterceptorProviders.length > 0) {\r\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +\r\n            'options. Only one of these is allowed.');\r\n    }\r\n    let interceptors = [];\r\n    // Interceptors passed to the call override interceptors passed to the client constructor\r\n    if (interceptorArgs.callInterceptors.length > 0 ||\r\n        interceptorArgs.callInterceptorProviders.length > 0) {\r\n        interceptors = []\r\n            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition)))\r\n            .filter(interceptor => interceptor);\r\n        // Filter out falsy values when providers return nothing\r\n    }\r\n    else {\r\n        interceptors = []\r\n            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition)))\r\n            .filter(interceptor => interceptor);\r\n        // Filter out falsy values when providers return nothing\r\n    }\r\n    const interceptorOptions = Object.assign({}, options, {\r\n        method_definition: methodDefinition,\r\n    });\r\n    /* For each interceptor in the list, the nextCall function passed to it is\r\n     * based on the next interceptor in the list, using a nextCall function\r\n     * constructed with the following interceptor in the list, and so on. The\r\n     * initialValue, which is effectively at the end of the list, is a nextCall\r\n     * function that invokes getBottomInterceptingCall, the result of which\r\n     * handles (de)serialization and also gets the underlying call from the\r\n     * channel. */\r\n    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\r\n        return currentOptions => nextInterceptor(currentOptions, nextCall);\r\n    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\r\n    return getCall(interceptorOptions);\r\n}\r\nexports.getInterceptingCall = getInterceptingCall;\r\n//# sourceMappingURL=client-interceptors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLHFDQUFxQztBQUNuSixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb1JBQW9SO0FBQ3BSLGlSQUFpUjtBQUNqUiw4UUFBOFE7QUFDOVE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxnQ0FBZ0M7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGdDQUFnQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb09BQW9PO0FBQ3BPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NsaWVudC1pbnRlcmNlcHRvcnMuanM/OGJjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5nZXRJbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5JbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5SZXF1ZXN0ZXJCdWlsZGVyID0gZXhwb3J0cy5MaXN0ZW5lckJ1aWxkZXIgPSBleHBvcnRzLkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yID0gdm9pZCAwO1xyXG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XHJcbmNvbnN0IGNhbGxfaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9jYWxsLWludGVyZmFjZVwiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcclxuLyoqXHJcbiAqIEVycm9yIGNsYXNzIGFzc29jaWF0ZWQgd2l0aCBwYXNzaW5nIGJvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvclxyXG4gKiBwcm92aWRlcnMgdG8gYSBjbGllbnQgY29uc3RydWN0b3Igb3IgYXMgY2FsbCBvcHRpb25zLlxyXG4gKi9cclxuY2xhc3MgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yJztcclxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcik7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciA9IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yO1xyXG5jbGFzcyBMaXN0ZW5lckJ1aWxkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICB3aXRoT25SZWNlaXZlTWV0YWRhdGEob25SZWNlaXZlTWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gb25SZWNlaXZlTWV0YWRhdGE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB3aXRoT25SZWNlaXZlTWVzc2FnZShvblJlY2VpdmVNZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gb25SZWNlaXZlTWVzc2FnZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHdpdGhPblJlY2VpdmVTdGF0dXMob25SZWNlaXZlU3RhdHVzKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBvblJlY2VpdmVTdGF0dXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBidWlsZCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcclxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogdGhpcy5tZXNzYWdlLFxyXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHRoaXMuc3RhdHVzLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5MaXN0ZW5lckJ1aWxkZXIgPSBMaXN0ZW5lckJ1aWxkZXI7XHJcbmNsYXNzIFJlcXVlc3RlckJ1aWxkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5oYWxmQ2xvc2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jYW5jZWwgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICB3aXRoU3RhcnQoc3RhcnQpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB3aXRoU2VuZE1lc3NhZ2Uoc2VuZE1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBzZW5kTWVzc2FnZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHdpdGhIYWxmQ2xvc2UoaGFsZkNsb3NlKSB7XHJcbiAgICAgICAgdGhpcy5oYWxmQ2xvc2UgPSBoYWxmQ2xvc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB3aXRoQ2FuY2VsKGNhbmNlbCkge1xyXG4gICAgICAgIHRoaXMuY2FuY2VsID0gY2FuY2VsO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgYnVpbGQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXHJcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXHJcbiAgICAgICAgICAgIGhhbGZDbG9zZTogdGhpcy5oYWxmQ2xvc2UsXHJcbiAgICAgICAgICAgIGNhbmNlbDogdGhpcy5jYW5jZWwsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlJlcXVlc3RlckJ1aWxkZXIgPSBSZXF1ZXN0ZXJCdWlsZGVyO1xyXG4vKipcclxuICogQSBMaXN0ZW5lciB3aXRoIGEgZGVmYXVsdCBwYXNzLXRocm91Z2ggaW1wbGVtZW50YXRpb24gb2YgZWFjaCBtZXRob2QuIFVzZWRcclxuICogZm9yIGZpbGxpbmcgb3V0IExpc3RlbmVycyB3aXRoIHNvbWUgbWV0aG9kcyBvbWl0dGVkLlxyXG4gKi9cclxuY29uc3QgZGVmYXVsdExpc3RlbmVyID0ge1xyXG4gICAgb25SZWNlaXZlTWV0YWRhdGE6IChtZXRhZGF0YSwgbmV4dCkgPT4ge1xyXG4gICAgICAgIG5leHQobWV0YWRhdGEpO1xyXG4gICAgfSxcclxuICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XHJcbiAgICAgICAgbmV4dChtZXNzYWdlKTtcclxuICAgIH0sXHJcbiAgICBvblJlY2VpdmVTdGF0dXM6IChzdGF0dXMsIG5leHQpID0+IHtcclxuICAgICAgICBuZXh0KHN0YXR1cyk7XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuICogQSBSZXF1ZXN0ZXIgd2l0aCBhIGRlZmF1bHQgcGFzcy10aHJvdWdoIGltcGxlbWVudGF0aW9uIG9mIGVhY2ggbWV0aG9kLiBVc2VkXHJcbiAqIGZvciBmaWxsaW5nIG91dCBSZXF1ZXN0ZXJzIHdpdGggc29tZSBtZXRob2RzIG9taXR0ZWQuXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0UmVxdWVzdGVyID0ge1xyXG4gICAgc3RhcnQ6IChtZXRhZGF0YSwgbGlzdGVuZXIsIG5leHQpID0+IHtcclxuICAgICAgICBuZXh0KG1ldGFkYXRhLCBsaXN0ZW5lcik7XHJcbiAgICB9LFxyXG4gICAgc2VuZE1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XHJcbiAgICAgICAgbmV4dChtZXNzYWdlKTtcclxuICAgIH0sXHJcbiAgICBoYWxmQ2xvc2U6IG5leHQgPT4ge1xyXG4gICAgICAgIG5leHQoKTtcclxuICAgIH0sXHJcbiAgICBjYW5jZWw6IG5leHQgPT4ge1xyXG4gICAgICAgIG5leHQoKTtcclxuICAgIH0sXHJcbn07XHJcbmNsYXNzIEludGVyY2VwdGluZ0NhbGwge1xyXG4gICAgY29uc3RydWN0b3IobmV4dENhbGwsIHJlcXVlc3Rlcikge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICB0aGlzLm5leHRDYWxsID0gbmV4dENhbGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgbWV0YWRhdGEgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSByZXF1ZXN0ZXIncyBzdGFydFxyXG4gICAgICAgICAqIG1ldGhvZCBidXQgaXQgaGFzIG5vdCBiZWVuIHBhc3NlZCB0byB0aGUgY29ycmVzcG9uZGluZyBuZXh0IGNhbGxiYWNrXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZXNzYWdlIGNvbnRleHQgZm9yIGEgcGVuZGluZyBtZXNzYWdlIHRoYXQgaXMgd2FpdGluZyBmb3JcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYSBtZXNzYWdlIGhhcyBiZWVuIHBhc3NlZCB0byB0aGUgcmVxdWVzdGVyJ3Mgc2VuZE1lc3NhZ2VcclxuICAgICAgICAgKiBtZXRob2QgYnV0IGl0IGhhcyBub3QgYmVlbiBwYXNzZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgbmV4dCBjYWxsYmFja1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIHN0YXR1cyB3YXMgcmVjZWl2ZWQgYnV0IGNvdWxkIG5vdCBiZSBwcm9wYWdhdGVkIGJlY2F1c2VcclxuICAgICAgICAgKiBhIG1lc3NhZ2Ugd2FzIHN0aWxsIGJlaW5nIHByb2Nlc3NlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSBmYWxzZTtcclxuICAgICAgICBpZiAocmVxdWVzdGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVyID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IChfYSA9IHJlcXVlc3Rlci5zdGFydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdFJlcXVlc3Rlci5zdGFydCxcclxuICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlOiAoX2IgPSByZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRSZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICBoYWxmQ2xvc2U6IChfYyA9IHJlcXVlc3Rlci5oYWxmQ2xvc2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRSZXF1ZXN0ZXIuaGFsZkNsb3NlLFxyXG4gICAgICAgICAgICAgICAgY2FuY2VsOiAoX2QgPSByZXF1ZXN0ZXIuY2FuY2VsKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0UmVxdWVzdGVyLmNhbmNlbCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVyID0gZGVmYXVsdFJlcXVlc3RlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xyXG4gICAgICAgIHRoaXMucmVxdWVzdGVyLmNhbmNlbCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0UGVlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2FsbC5nZXRQZWVyKCk7XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzUGVuZGluZ01lc3NhZ2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLmhhbGZDbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0KG1ldGFkYXRhLCBpbnRlcmNlcHRpbmdMaXN0ZW5lcikge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAgIGNvbnN0IGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IHtcclxuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChfYiA9IChfYSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQoaW50ZXJjZXB0aW5nTGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAobWV0YWRhdGEgPT4geyB9KSxcclxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9kID0gKF9jID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iaW5kKGludGVyY2VwdGluZ0xpc3RlbmVyKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKG1lc3NhZ2UgPT4geyB9KSxcclxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiAoX2YgPSAoX2UgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYmluZChpbnRlcmNlcHRpbmdMaXN0ZW5lcikpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IChzdGF0dXMgPT4geyB9KSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJlcXVlc3Rlci5zdGFydChtZXRhZGF0YSwgZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyLCAobWQsIGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lcjtcclxuICAgICAgICAgICAgaWYgKCgwLCBjYWxsX2ludGVyZmFjZV8xLmlzSW50ZXJjZXB0aW5nTGlzdGVuZXIpKGxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbExpc3RlbmVyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAoX2EgPSBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdExpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChfYiA9IGxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKF9jID0gbGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0TGlzdGVuZXIub25SZWNlaXZlU3RhdHVzLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGZpbmFsSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSBuZXcgY2FsbF9pbnRlcmZhY2VfMS5JbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwoZnVsbExpc3RlbmVyLCBmdWxsSW50ZXJjZXB0aW5nTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc3RhcnQobWQsIGZpbmFsSW50ZXJjZXB0aW5nTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSwgZmluYWxNZXNzYWdlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGZpbmFsTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHt9LCBtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIHN0YXJ0UmVhZCgpIHtcclxuICAgICAgICB0aGlzLm5leHRDYWxsLnN0YXJ0UmVhZCgpO1xyXG4gICAgfVxyXG4gICAgaGFsZkNsb3NlKCkge1xyXG4gICAgICAgIHRoaXMucmVxdWVzdGVyLmhhbGZDbG9zZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSB8fCB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5oYWxmQ2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuSW50ZXJjZXB0aW5nQ2FsbCA9IEludGVyY2VwdGluZ0NhbGw7XHJcbmZ1bmN0aW9uIGdldENhbGwoY2hhbm5lbCwgcGF0aCwgb3B0aW9ucykge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGNvbnN0IGRlYWRsaW5lID0gKF9hID0gb3B0aW9ucy5kZWFkbGluZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogSW5maW5pdHk7XHJcbiAgICBjb25zdCBob3N0ID0gb3B0aW9ucy5ob3N0O1xyXG4gICAgY29uc3QgcGFyZW50ID0gKF9iID0gb3B0aW9ucy5wYXJlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XHJcbiAgICBjb25zdCBwcm9wYWdhdGVGbGFncyA9IG9wdGlvbnMucHJvcGFnYXRlX2ZsYWdzO1xyXG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzO1xyXG4gICAgY29uc3QgY2FsbCA9IGNoYW5uZWwuY3JlYXRlQ2FsbChwYXRoLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50LCBwcm9wYWdhdGVGbGFncyk7XHJcbiAgICBpZiAoY3JlZGVudGlhbHMpIHtcclxuICAgICAgICBjYWxsLnNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYWxsO1xyXG59XHJcbi8qKlxyXG4gKiBJbnRlcmNlcHRpbmdDYWxsIGltcGxlbWVudGF0aW9uIHRoYXQgZGlyZWN0bHkgb3ducyB0aGUgdW5kZXJseWluZyBDYWxsXHJcbiAqIG9iamVjdCBhbmQgaGFuZGxlcyBzZXJpYWxpemF0aW9uIGFuZCBkZXNlcmFpemxpYXRpb24uXHJcbiAqL1xyXG5jbGFzcyBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBtZXRob2REZWZpbml0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcclxuICAgICAgICB0aGlzLm1ldGhvZERlZmluaXRpb24gPSBtZXRob2REZWZpbml0aW9uO1xyXG4gICAgfVxyXG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcclxuICAgICAgICB0aGlzLmNhbGwuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xyXG4gICAgfVxyXG4gICAgZ2V0UGVlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcclxuICAgICAgICBsZXQgc2VyaWFsaXplZDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBzZXJpYWxpemVkID0gdGhpcy5tZXRob2REZWZpbml0aW9uLnJlcXVlc3RTZXJpYWxpemUobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgYFJlcXVlc3QgbWVzc2FnZSBzZXJpYWxpemF0aW9uIGZhaWx1cmU6ICR7KDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlKX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBzZXJpYWxpemVkKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHt9LCBtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIHN0YXJ0KG1ldGFkYXRhLCBpbnRlcmNlcHRpbmdMaXN0ZW5lcikge1xyXG4gICAgICAgIGxldCByZWFkRXJyb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2FsbC5zdGFydChtZXRhZGF0YSwge1xyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbnRlcmNlcHRpbmdMaXN0ZW5lciwgbWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiBtZXNzYWdlID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICBsZXQgZGVzZXJpYWxpemVkO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZWQgPSB0aGlzLm1ldGhvZERlZmluaXRpb24ucmVzcG9uc2VEZXNlcmlhbGl6ZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZEVycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZXNwb25zZSBtZXNzYWdlIHBhcnNpbmcgZXJyb3I6ICR7KDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlKX1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHJlYWRFcnJvci5jb2RlLCByZWFkRXJyb3IuZGV0YWlscyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBkZXNlcmlhbGl6ZWQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHN0YXR1cyA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlYWRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCByZWFkRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGFydFJlYWQoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0UmVhZCgpO1xyXG4gICAgfVxyXG4gICAgaGFsZkNsb3NlKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbC5oYWxmQ2xvc2UoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQmFzZUludGVyY2VwdGluZ0NhbGwgd2l0aCBzcGVjaWFsLWNhc2VkIGJlaGF2aW9yIGZvciBtZXRob2RzIHdpdGggdW5hcnlcclxuICogcmVzcG9uc2VzLlxyXG4gKi9cclxuY2xhc3MgQmFzZVVuYXJ5SW50ZXJjZXB0aW5nQ2FsbCBleHRlbmRzIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBtZXRob2REZWZpbml0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbik7XHJcbiAgICB9XHJcbiAgICBzdGFydChtZXRhZGF0YSwgbGlzdGVuZXIpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGxldCByZWNlaXZlZE1lc3NhZ2UgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB3cmFwcGVyTGlzdGVuZXIgPSB7XHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAoX2IgPSAoX2EgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKGxpc3RlbmVyKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKG1ldGFkYXRhID0+IHsgfSksXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZE1lc3NhZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgKF9hID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGxpc3RlbmVyLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiAoc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZWNlaXZlZE1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobGlzdGVuZXIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKF9iID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwobGlzdGVuZXIsIHN0YXR1cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBzdXBlci5zdGFydChtZXRhZGF0YSwgd3JhcHBlckxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLmNhbGwuc3RhcnRSZWFkKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHdpdGggc3BlY2lhbC1jYXNlZCBiZWhhdmlvciBmb3IgbWV0aG9kcyB3aXRoIHN0cmVhbWluZ1xyXG4gKiByZXNwb25zZXMuXHJcbiAqL1xyXG5jbGFzcyBCYXNlU3RyZWFtaW5nSW50ZXJjZXB0aW5nQ2FsbCBleHRlbmRzIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHtcclxufVxyXG5mdW5jdGlvbiBnZXRCb3R0b21JbnRlcmNlcHRpbmdDYWxsKGNoYW5uZWwsIG9wdGlvbnMsIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5tZXRob2REZWZpbml0aW9uKSB7XHJcbiAgICBjb25zdCBjYWxsID0gZ2V0Q2FsbChjaGFubmVsLCBtZXRob2REZWZpbml0aW9uLnBhdGgsIG9wdGlvbnMpO1xyXG4gICAgaWYgKG1ldGhvZERlZmluaXRpb24ucmVzcG9uc2VTdHJlYW0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJhc2VTdHJlYW1pbmdJbnRlcmNlcHRpbmdDYWxsKGNhbGwsIG1ldGhvZERlZmluaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlVW5hcnlJbnRlcmNlcHRpbmdDYWxsKGNhbGwsIG1ldGhvZERlZmluaXRpb24pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEludGVyY2VwdGluZ0NhbGwoaW50ZXJjZXB0b3JBcmdzLCBcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxubWV0aG9kRGVmaW5pdGlvbiwgb3B0aW9ucywgY2hhbm5lbCkge1xyXG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvcnMubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgIGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvclByb3ZpZGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yKCdCb3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JfcHJvdmlkZXJzIHdlcmUgcGFzc2VkIGFzIG9wdGlvbnMgJyArXHJcbiAgICAgICAgICAgICd0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yLiBPbmx5IG9uZSBvZiB0aGVzZSBpcyBhbGxvd2VkLicpO1xyXG4gICAgfVxyXG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICBpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IoJ0JvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvcl9wcm92aWRlcnMgd2VyZSBwYXNzZWQgYXMgY2FsbCAnICtcclxuICAgICAgICAgICAgJ29wdGlvbnMuIE9ubHkgb25lIG9mIHRoZXNlIGlzIGFsbG93ZWQuJyk7XHJcbiAgICB9XHJcbiAgICBsZXQgaW50ZXJjZXB0b3JzID0gW107XHJcbiAgICAvLyBJbnRlcmNlcHRvcnMgcGFzc2VkIHRvIHRoZSBjYWxsIG92ZXJyaWRlIGludGVyY2VwdG9ycyBwYXNzZWQgdG8gdGhlIGNsaWVudCBjb25zdHJ1Y3RvclxyXG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgfHxcclxuICAgICAgICBpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBpbnRlcmNlcHRvcnMgPSBbXVxyXG4gICAgICAgICAgICAuY29uY2F0KGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLCBpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzLm1hcChwcm92aWRlciA9PiBwcm92aWRlcihtZXRob2REZWZpbml0aW9uKSkpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoaW50ZXJjZXB0b3IgPT4gaW50ZXJjZXB0b3IpO1xyXG4gICAgICAgIC8vIEZpbHRlciBvdXQgZmFsc3kgdmFsdWVzIHdoZW4gcHJvdmlkZXJzIHJldHVybiBub3RoaW5nXHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpbnRlcmNlcHRvcnMgPSBbXVxyXG4gICAgICAgICAgICAuY29uY2F0KGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvcnMsIGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvclByb3ZpZGVycy5tYXAocHJvdmlkZXIgPT4gcHJvdmlkZXIobWV0aG9kRGVmaW5pdGlvbikpKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGludGVyY2VwdG9yID0+IGludGVyY2VwdG9yKTtcclxuICAgICAgICAvLyBGaWx0ZXIgb3V0IGZhbHN5IHZhbHVlcyB3aGVuIHByb3ZpZGVycyByZXR1cm4gbm90aGluZ1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW50ZXJjZXB0b3JPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xyXG4gICAgICAgIG1ldGhvZF9kZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxyXG4gICAgfSk7XHJcbiAgICAvKiBGb3IgZWFjaCBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgdGhlIG5leHRDYWxsIGZ1bmN0aW9uIHBhc3NlZCB0byBpdCBpc1xyXG4gICAgICogYmFzZWQgb24gdGhlIG5leHQgaW50ZXJjZXB0b3IgaW4gdGhlIGxpc3QsIHVzaW5nIGEgbmV4dENhbGwgZnVuY3Rpb25cclxuICAgICAqIGNvbnN0cnVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgYW5kIHNvIG9uLiBUaGVcclxuICAgICAqIGluaXRpYWxWYWx1ZSwgd2hpY2ggaXMgZWZmZWN0aXZlbHkgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCwgaXMgYSBuZXh0Q2FsbFxyXG4gICAgICogZnVuY3Rpb24gdGhhdCBpbnZva2VzIGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwsIHRoZSByZXN1bHQgb2Ygd2hpY2hcclxuICAgICAqIGhhbmRsZXMgKGRlKXNlcmlhbGl6YXRpb24gYW5kIGFsc28gZ2V0cyB0aGUgdW5kZXJseWluZyBjYWxsIGZyb20gdGhlXHJcbiAgICAgKiBjaGFubmVsLiAqL1xyXG4gICAgY29uc3QgZ2V0Q2FsbCA9IGludGVyY2VwdG9ycy5yZWR1Y2VSaWdodCgobmV4dENhbGwsIG5leHRJbnRlcmNlcHRvcikgPT4ge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50T3B0aW9ucyA9PiBuZXh0SW50ZXJjZXB0b3IoY3VycmVudE9wdGlvbnMsIG5leHRDYWxsKTtcclxuICAgIH0sIChmaW5hbE9wdGlvbnMpID0+IGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwoY2hhbm5lbCwgZmluYWxPcHRpb25zLCBtZXRob2REZWZpbml0aW9uKSk7XHJcbiAgICByZXR1cm4gZ2V0Q2FsbChpbnRlcmNlcHRvck9wdGlvbnMpO1xyXG59XHJcbmV4cG9ydHMuZ2V0SW50ZXJjZXB0aW5nQ2FsbCA9IGdldEludGVyY2VwdGluZ0NhbGw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC1pbnRlcmNlcHRvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Client = void 0;\r\nconst call_1 = __webpack_require__(/*! ./call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call.js\");\r\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\r\nconst CHANNEL_SYMBOL = Symbol();\r\nconst INTERCEPTOR_SYMBOL = Symbol();\r\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\r\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\r\nfunction isFunction(arg) {\r\n    return typeof arg === 'function';\r\n}\r\nfunction getErrorStackString(error) {\r\n    return error.stack.split('\\n').slice(1).join('\\n');\r\n}\r\n/**\r\n * A generic gRPC client. Primarily useful as a base class for all generated\r\n * clients.\r\n */\r\nclass Client {\r\n    constructor(address, credentials, options = {}) {\r\n        var _a, _b;\r\n        options = Object.assign({}, options);\r\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\r\n        delete options.interceptors;\r\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\r\n        delete options.interceptor_providers;\r\n        if (this[INTERCEPTOR_SYMBOL].length > 0 &&\r\n            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\r\n            throw new Error('Both interceptors and interceptor_providers were passed as options ' +\r\n                'to the client constructor. Only one of these is allowed.');\r\n        }\r\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =\r\n            options.callInvocationTransformer;\r\n        delete options.callInvocationTransformer;\r\n        if (options.channelOverride) {\r\n            this[CHANNEL_SYMBOL] = options.channelOverride;\r\n        }\r\n        else if (options.channelFactoryOverride) {\r\n            const channelFactoryOverride = options.channelFactoryOverride;\r\n            delete options.channelFactoryOverride;\r\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\r\n        }\r\n        else {\r\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\r\n        }\r\n    }\r\n    close() {\r\n        this[CHANNEL_SYMBOL].close();\r\n    }\r\n    getChannel() {\r\n        return this[CHANNEL_SYMBOL];\r\n    }\r\n    waitForReady(deadline, callback) {\r\n        const checkState = (err) => {\r\n            if (err) {\r\n                callback(new Error('Failed to connect before the deadline'));\r\n                return;\r\n            }\r\n            let newState;\r\n            try {\r\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\r\n            }\r\n            catch (e) {\r\n                callback(new Error('The channel has been closed'));\r\n                return;\r\n            }\r\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\r\n                callback();\r\n            }\r\n            else {\r\n                try {\r\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\r\n                }\r\n                catch (e) {\r\n                    callback(new Error('The channel has been closed'));\r\n                }\r\n            }\r\n        };\r\n        setImmediate(checkState);\r\n    }\r\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\r\n        if (isFunction(arg1)) {\r\n            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };\r\n        }\r\n        else if (isFunction(arg2)) {\r\n            if (arg1 instanceof metadata_1.Metadata) {\r\n                return { metadata: arg1, options: {}, callback: arg2 };\r\n            }\r\n            else {\r\n                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };\r\n            }\r\n        }\r\n        else {\r\n            if (!(arg1 instanceof metadata_1.Metadata &&\r\n                arg2 instanceof Object &&\r\n                isFunction(arg3))) {\r\n                throw new Error('Incorrect arguments passed');\r\n            }\r\n            return { metadata: arg1, options: arg2, callback: arg3 };\r\n        }\r\n    }\r\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\r\n        var _a, _b;\r\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\r\n        const methodDefinition = {\r\n            path: method,\r\n            requestStream: false,\r\n            responseStream: false,\r\n            requestSerialize: serialize,\r\n            responseDeserialize: deserialize,\r\n        };\r\n        let callProperties = {\r\n            argument: argument,\r\n            metadata: checkedArguments.metadata,\r\n            call: new call_1.ClientUnaryCallImpl(),\r\n            channel: this[CHANNEL_SYMBOL],\r\n            methodDefinition: methodDefinition,\r\n            callOptions: checkedArguments.options,\r\n            callback: checkedArguments.callback,\r\n        };\r\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\r\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\r\n        }\r\n        const emitter = callProperties.call;\r\n        const interceptorArgs = {\r\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\r\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\r\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\r\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\r\n        };\r\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\r\n        /* This needs to happen before the emitter is used. Unfortunately we can't\r\n         * enforce this with the type system. We need to construct this emitter\r\n         * before calling the CallInvocationTransformer, and we need to create the\r\n         * call after that. */\r\n        emitter.call = call;\r\n        let responseMessage = null;\r\n        let receivedStatus = false;\r\n        let callerStackError = new Error();\r\n        call.start(callProperties.metadata, {\r\n            onReceiveMetadata: metadata => {\r\n                emitter.emit('metadata', metadata);\r\n            },\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            onReceiveMessage(message) {\r\n                if (responseMessage !== null) {\r\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\r\n                }\r\n                responseMessage = message;\r\n            },\r\n            onReceiveStatus(status) {\r\n                if (receivedStatus) {\r\n                    return;\r\n                }\r\n                receivedStatus = true;\r\n                if (status.code === constants_1.Status.OK) {\r\n                    if (responseMessage === null) {\r\n                        const callerStack = getErrorStackString(callerStackError);\r\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\r\n                            code: constants_1.Status.INTERNAL,\r\n                            details: 'No message received',\r\n                            metadata: status.metadata,\r\n                        }, callerStack));\r\n                    }\r\n                    else {\r\n                        callProperties.callback(null, responseMessage);\r\n                    }\r\n                }\r\n                else {\r\n                    const callerStack = getErrorStackString(callerStackError);\r\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\r\n                }\r\n                /* Avoid retaining the callerStackError object in the call context of\r\n                 * the status event handler. */\r\n                callerStackError = null;\r\n                emitter.emit('status', status);\r\n            },\r\n        });\r\n        call.sendMessage(argument);\r\n        call.halfClose();\r\n        return emitter;\r\n    }\r\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\r\n        var _a, _b;\r\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\r\n        const methodDefinition = {\r\n            path: method,\r\n            requestStream: true,\r\n            responseStream: false,\r\n            requestSerialize: serialize,\r\n            responseDeserialize: deserialize,\r\n        };\r\n        let callProperties = {\r\n            metadata: checkedArguments.metadata,\r\n            call: new call_1.ClientWritableStreamImpl(serialize),\r\n            channel: this[CHANNEL_SYMBOL],\r\n            methodDefinition: methodDefinition,\r\n            callOptions: checkedArguments.options,\r\n            callback: checkedArguments.callback,\r\n        };\r\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\r\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\r\n        }\r\n        const emitter = callProperties.call;\r\n        const interceptorArgs = {\r\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\r\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\r\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\r\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\r\n        };\r\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\r\n        /* This needs to happen before the emitter is used. Unfortunately we can't\r\n         * enforce this with the type system. We need to construct this emitter\r\n         * before calling the CallInvocationTransformer, and we need to create the\r\n         * call after that. */\r\n        emitter.call = call;\r\n        let responseMessage = null;\r\n        let receivedStatus = false;\r\n        let callerStackError = new Error();\r\n        call.start(callProperties.metadata, {\r\n            onReceiveMetadata: metadata => {\r\n                emitter.emit('metadata', metadata);\r\n            },\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            onReceiveMessage(message) {\r\n                if (responseMessage !== null) {\r\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\r\n                }\r\n                responseMessage = message;\r\n            },\r\n            onReceiveStatus(status) {\r\n                if (receivedStatus) {\r\n                    return;\r\n                }\r\n                receivedStatus = true;\r\n                if (status.code === constants_1.Status.OK) {\r\n                    if (responseMessage === null) {\r\n                        const callerStack = getErrorStackString(callerStackError);\r\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\r\n                            code: constants_1.Status.INTERNAL,\r\n                            details: 'No message received',\r\n                            metadata: status.metadata,\r\n                        }, callerStack));\r\n                    }\r\n                    else {\r\n                        callProperties.callback(null, responseMessage);\r\n                    }\r\n                }\r\n                else {\r\n                    const callerStack = getErrorStackString(callerStackError);\r\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\r\n                }\r\n                /* Avoid retaining the callerStackError object in the call context of\r\n                 * the status event handler. */\r\n                callerStackError = null;\r\n                emitter.emit('status', status);\r\n            },\r\n        });\r\n        return emitter;\r\n    }\r\n    checkMetadataAndOptions(arg1, arg2) {\r\n        let metadata;\r\n        let options;\r\n        if (arg1 instanceof metadata_1.Metadata) {\r\n            metadata = arg1;\r\n            if (arg2) {\r\n                options = arg2;\r\n            }\r\n            else {\r\n                options = {};\r\n            }\r\n        }\r\n        else {\r\n            if (arg1) {\r\n                options = arg1;\r\n            }\r\n            else {\r\n                options = {};\r\n            }\r\n            metadata = new metadata_1.Metadata();\r\n        }\r\n        return { metadata, options };\r\n    }\r\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\r\n        var _a, _b;\r\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\r\n        const methodDefinition = {\r\n            path: method,\r\n            requestStream: false,\r\n            responseStream: true,\r\n            requestSerialize: serialize,\r\n            responseDeserialize: deserialize,\r\n        };\r\n        let callProperties = {\r\n            argument: argument,\r\n            metadata: checkedArguments.metadata,\r\n            call: new call_1.ClientReadableStreamImpl(deserialize),\r\n            channel: this[CHANNEL_SYMBOL],\r\n            methodDefinition: methodDefinition,\r\n            callOptions: checkedArguments.options,\r\n        };\r\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\r\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\r\n        }\r\n        const stream = callProperties.call;\r\n        const interceptorArgs = {\r\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\r\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\r\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\r\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\r\n        };\r\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\r\n        /* This needs to happen before the emitter is used. Unfortunately we can't\r\n         * enforce this with the type system. We need to construct this emitter\r\n         * before calling the CallInvocationTransformer, and we need to create the\r\n         * call after that. */\r\n        stream.call = call;\r\n        let receivedStatus = false;\r\n        let callerStackError = new Error();\r\n        call.start(callProperties.metadata, {\r\n            onReceiveMetadata(metadata) {\r\n                stream.emit('metadata', metadata);\r\n            },\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            onReceiveMessage(message) {\r\n                stream.push(message);\r\n            },\r\n            onReceiveStatus(status) {\r\n                if (receivedStatus) {\r\n                    return;\r\n                }\r\n                receivedStatus = true;\r\n                stream.push(null);\r\n                if (status.code !== constants_1.Status.OK) {\r\n                    const callerStack = getErrorStackString(callerStackError);\r\n                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\r\n                }\r\n                /* Avoid retaining the callerStackError object in the call context of\r\n                 * the status event handler. */\r\n                callerStackError = null;\r\n                stream.emit('status', status);\r\n            },\r\n        });\r\n        call.sendMessage(argument);\r\n        call.halfClose();\r\n        return stream;\r\n    }\r\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\r\n        var _a, _b;\r\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\r\n        const methodDefinition = {\r\n            path: method,\r\n            requestStream: true,\r\n            responseStream: true,\r\n            requestSerialize: serialize,\r\n            responseDeserialize: deserialize,\r\n        };\r\n        let callProperties = {\r\n            metadata: checkedArguments.metadata,\r\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\r\n            channel: this[CHANNEL_SYMBOL],\r\n            methodDefinition: methodDefinition,\r\n            callOptions: checkedArguments.options,\r\n        };\r\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\r\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\r\n        }\r\n        const stream = callProperties.call;\r\n        const interceptorArgs = {\r\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\r\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\r\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\r\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\r\n        };\r\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\r\n        /* This needs to happen before the emitter is used. Unfortunately we can't\r\n         * enforce this with the type system. We need to construct this emitter\r\n         * before calling the CallInvocationTransformer, and we need to create the\r\n         * call after that. */\r\n        stream.call = call;\r\n        let receivedStatus = false;\r\n        let callerStackError = new Error();\r\n        call.start(callProperties.metadata, {\r\n            onReceiveMetadata(metadata) {\r\n                stream.emit('metadata', metadata);\r\n            },\r\n            onReceiveMessage(message) {\r\n                stream.push(message);\r\n            },\r\n            onReceiveStatus(status) {\r\n                if (receivedStatus) {\r\n                    return;\r\n                }\r\n                receivedStatus = true;\r\n                stream.push(null);\r\n                if (status.code !== constants_1.Status.OK) {\r\n                    const callerStack = getErrorStackString(callerStackError);\r\n                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\r\n                }\r\n                /* Avoid retaining the callerStackError object in the call context of\r\n                 * the status event handler. */\r\n                callerStackError = null;\r\n                stream.emit('status', status);\r\n            },\r\n        });\r\n        return stream;\r\n    }\r\n}\r\nexports.Client = Client;\r\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGVBQWUsbUJBQU8sQ0FBQyxvRUFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQywwRUFBVztBQUNyQyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsOEJBQThCLG1CQUFPLENBQUMsa0dBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0RBQWdEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jbGllbnQuanM/OTQ0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5DbGllbnQgPSB2b2lkIDA7XHJcbmNvbnN0IGNhbGxfMSA9IHJlcXVpcmUoXCIuL2NhbGxcIik7XHJcbmNvbnN0IGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XHJcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xyXG5jb25zdCBjbGllbnRfaW50ZXJjZXB0b3JzXzEgPSByZXF1aXJlKFwiLi9jbGllbnQtaW50ZXJjZXB0b3JzXCIpO1xyXG5jb25zdCBDSEFOTkVMX1NZTUJPTCA9IFN5bWJvbCgpO1xyXG5jb25zdCBJTlRFUkNFUFRPUl9TWU1CT0wgPSBTeW1ib2woKTtcclxuY29uc3QgSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MID0gU3ltYm9sKCk7XHJcbmNvbnN0IENBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0wgPSBTeW1ib2woKTtcclxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcclxuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVycm9yU3RhY2tTdHJpbmcoZXJyb3IpIHtcclxuICAgIHJldHVybiBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMSkuam9pbignXFxuJyk7XHJcbn1cclxuLyoqXHJcbiAqIEEgZ2VuZXJpYyBnUlBDIGNsaWVudC4gUHJpbWFyaWx5IHVzZWZ1bCBhcyBhIGJhc2UgY2xhc3MgZm9yIGFsbCBnZW5lcmF0ZWRcclxuICogY2xpZW50cy5cclxuICovXHJcbmNsYXNzIENsaWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdID0gKF9hID0gb3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xyXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmludGVyY2VwdG9ycztcclxuICAgICAgICB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0gPSAoX2IgPSBvcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XHJcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzO1xyXG4gICAgICAgIGlmICh0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0ubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICAgICB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvcl9wcm92aWRlcnMgd2VyZSBwYXNzZWQgYXMgb3B0aW9ucyAnICtcclxuICAgICAgICAgICAgICAgICd0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yLiBPbmx5IG9uZSBvZiB0aGVzZSBpcyBhbGxvd2VkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdID1cclxuICAgICAgICAgICAgb3B0aW9ucy5jYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyO1xyXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmNhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXI7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbm5lbE92ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gb3B0aW9ucy5jaGFubmVsT3ZlcnJpZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY2hhbm5lbEZhY3RvcnlPdmVycmlkZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGFubmVsRmFjdG9yeU92ZXJyaWRlID0gb3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlO1xyXG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlO1xyXG4gICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXSA9IGNoYW5uZWxGYWN0b3J5T3ZlcnJpZGUoYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0gPSBuZXcgY2hhbm5lbF8xLkNoYW5uZWxJbXBsZW1lbnRhdGlvbihhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0uY2xvc2UoKTtcclxuICAgIH1cclxuICAgIGdldENoYW5uZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNbQ0hBTk5FTF9TWU1CT0xdO1xyXG4gICAgfVxyXG4gICAgd2FpdEZvclJlYWR5KGRlYWRsaW5lLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IGNoZWNrU3RhdGUgPSAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbm5lY3QgYmVmb3JlIHRoZSBkZWFkbGluZScpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbmV3U3RhdGU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLmdldENvbm5lY3Rpdml0eVN0YXRlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ1RoZSBjaGFubmVsIGhhcyBiZWVuIGNsb3NlZCcpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXS53YXRjaENvbm5lY3Rpdml0eVN0YXRlKG5ld1N0YXRlLCBkZWFkbGluZSwgY2hlY2tTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignVGhlIGNoYW5uZWwgaGFzIGJlZW4gY2xvc2VkJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzZXRJbW1lZGlhdGUoY2hlY2tTdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBjaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhhcmcxLCBhcmcyLCBhcmczKSB7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksIG9wdGlvbnM6IHt9LCBjYWxsYmFjazogYXJnMSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGFyZzIpKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5NZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IGFyZzEsIG9wdGlvbnM6IHt9LCBjYWxsYmFjazogYXJnMiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksIG9wdGlvbnM6IGFyZzEsIGNhbGxiYWNrOiBhcmcyIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghKGFyZzEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk1ldGFkYXRhICYmXHJcbiAgICAgICAgICAgICAgICBhcmcyIGluc3RhbmNlb2YgT2JqZWN0ICYmXHJcbiAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGFyZzMpKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgYXJndW1lbnRzIHBhc3NlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBhcmcxLCBvcHRpb25zOiBhcmcyLCBjYWxsYmFjazogYXJnMyB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1ha2VVbmFyeVJlcXVlc3QobWV0aG9kLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBhcmd1bWVudCwgbWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xyXG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcclxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxyXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxyXG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcclxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnRVbmFyeUNhbGxJbXBsKCksXHJcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxyXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxyXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogY2hlY2tlZEFyZ3VtZW50cy5jYWxsYmFjayxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XHJcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjYWxsUHJvcGVydGllcy5jYWxsO1xyXG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcclxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXHJcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXHJcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXHJcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGNhbGwgPSAoMCwgY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwpKGludGVyY2VwdG9yQXJncywgY2FsbFByb3BlcnRpZXMubWV0aG9kRGVmaW5pdGlvbiwgY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMsIGNhbGxQcm9wZXJ0aWVzLmNoYW5uZWwpO1xyXG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XHJcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcclxuICAgICAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGUgQ2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciwgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoZVxyXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cclxuICAgICAgICBlbWl0dGVyLmNhbGwgPSBjYWxsO1xyXG4gICAgICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBudWxsO1xyXG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XHJcbiAgICAgICAgY2FsbC5zdGFydChjYWxsUHJvcGVydGllcy5tZXRhZGF0YSwge1xyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgJ1RvbyBtYW55IHJlc3BvbnNlcyByZWNlaXZlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnTm8gbWVzc2FnZSByZWNlaXZlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjYWxsZXJTdGFjaykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VNZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKShzdGF0dXMsIGNhbGxlclN0YWNrKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKiBBdm9pZCByZXRhaW5pbmcgdGhlIGNhbGxlclN0YWNrRXJyb3Igb2JqZWN0IGluIHRoZSBjYWxsIGNvbnRleHQgb2ZcclxuICAgICAgICAgICAgICAgICAqIHRoZSBzdGF0dXMgZXZlbnQgaGFuZGxlci4gKi9cclxuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdzdGF0dXMnLCBzdGF0dXMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNhbGwuc2VuZE1lc3NhZ2UoYXJndW1lbnQpO1xyXG4gICAgICAgIGNhbGwuaGFsZkNsb3NlKCk7XHJcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XHJcbiAgICB9XHJcbiAgICBtYWtlQ2xpZW50U3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgY2hlY2tlZEFyZ3VtZW50cyA9IHRoaXMuY2hlY2tPcHRpb25hbFVuYXJ5UmVzcG9uc2VBcmd1bWVudHMobWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcclxuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xyXG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXHJcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IHRydWUsXHJcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxyXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXHJcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsKHNlcmlhbGl6ZSksXHJcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxyXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxyXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogY2hlY2tlZEFyZ3VtZW50cy5jYWxsYmFjayxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XHJcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjYWxsUHJvcGVydGllcy5jYWxsO1xyXG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcclxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXHJcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXHJcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXHJcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGNhbGwgPSAoMCwgY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwpKGludGVyY2VwdG9yQXJncywgY2FsbFByb3BlcnRpZXMubWV0aG9kRGVmaW5pdGlvbiwgY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMsIGNhbGxQcm9wZXJ0aWVzLmNoYW5uZWwpO1xyXG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XHJcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcclxuICAgICAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGUgQ2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciwgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoZVxyXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cclxuICAgICAgICBlbWl0dGVyLmNhbGwgPSBjYWxsO1xyXG4gICAgICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBudWxsO1xyXG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XHJcbiAgICAgICAgY2FsbC5zdGFydChjYWxsUHJvcGVydGllcy5tZXRhZGF0YSwge1xyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgJ1RvbyBtYW55IHJlc3BvbnNlcyByZWNlaXZlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnTm8gbWVzc2FnZSByZWNlaXZlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjYWxsZXJTdGFjaykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VNZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKShzdGF0dXMsIGNhbGxlclN0YWNrKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKiBBdm9pZCByZXRhaW5pbmcgdGhlIGNhbGxlclN0YWNrRXJyb3Igb2JqZWN0IGluIHRoZSBjYWxsIGNvbnRleHQgb2ZcclxuICAgICAgICAgICAgICAgICAqIHRoZSBzdGF0dXMgZXZlbnQgaGFuZGxlci4gKi9cclxuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdzdGF0dXMnLCBzdGF0dXMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBlbWl0dGVyO1xyXG4gICAgfVxyXG4gICAgY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMoYXJnMSwgYXJnMikge1xyXG4gICAgICAgIGxldCBtZXRhZGF0YTtcclxuICAgICAgICBsZXQgb3B0aW9ucztcclxuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgbWV0YWRhdGEgPSBhcmcxO1xyXG4gICAgICAgICAgICBpZiAoYXJnMikge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChhcmcxKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IG1ldGFkYXRhLCBvcHRpb25zIH07XHJcbiAgICB9XHJcbiAgICBtYWtlU2VydmVyU3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIGFyZ3VtZW50LCBtZXRhZGF0YSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgY2hlY2tlZEFyZ3VtZW50cyA9IHRoaXMuY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMobWV0YWRhdGEsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcclxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxyXG4gICAgICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBzZXJpYWxpemUsXHJcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IGNhbGxQcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnQsXHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxyXG4gICAgICAgICAgICBjYWxsOiBuZXcgY2FsbF8xLkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbChkZXNlcmlhbGl6ZSksXHJcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxyXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxyXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcclxuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcclxuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XHJcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxyXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxyXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxyXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcclxuICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIGVtaXR0ZXIgaXMgdXNlZC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndFxyXG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXHJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcclxuICAgICAgICAgKiBjYWxsIGFmdGVyIHRoYXQuICovXHJcbiAgICAgICAgc3RyZWFtLmNhbGwgPSBjYWxsO1xyXG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XHJcbiAgICAgICAgY2FsbC5zdGFydChjYWxsUHJvcGVydGllcy5tZXRhZGF0YSwge1xyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ21ldGFkYXRhJywgbWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsICgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3RhdHVzIGV2ZW50IGhhbmRsZXIuICovXHJcbiAgICAgICAgICAgICAgICBjYWxsZXJTdGFja0Vycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdzdGF0dXMnLCBzdGF0dXMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNhbGwuc2VuZE1lc3NhZ2UoYXJndW1lbnQpO1xyXG4gICAgICAgIGNhbGwuaGFsZkNsb3NlKCk7XHJcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcclxuICAgIH1cclxuICAgIG1ha2VCaWRpU3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIG1ldGFkYXRhLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja01ldGFkYXRhQW5kT3B0aW9ucyhtZXRhZGF0YSwgb3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcclxuICAgICAgICAgICAgcGF0aDogbWV0aG9kLFxyXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtOiB0cnVlLFxyXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbTogdHJ1ZSxcclxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxyXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXHJcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbChzZXJpYWxpemUsIGRlc2VyaWFsaXplKSxcclxuICAgICAgICAgICAgY2hhbm5lbDogdGhpc1tDSEFOTkVMX1NZTUJPTF0sXHJcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXHJcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xyXG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjYWxsUHJvcGVydGllcy5jYWxsO1xyXG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcclxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXHJcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXHJcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXHJcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGNhbGwgPSAoMCwgY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwpKGludGVyY2VwdG9yQXJncywgY2FsbFByb3BlcnRpZXMubWV0aG9kRGVmaW5pdGlvbiwgY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMsIGNhbGxQcm9wZXJ0aWVzLmNoYW5uZWwpO1xyXG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XHJcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcclxuICAgICAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGUgQ2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciwgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoZVxyXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cclxuICAgICAgICBzdHJlYW0uY2FsbCA9IGNhbGw7XHJcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGNhbGxlclN0YWNrRXJyb3IgPSBuZXcgRXJyb3IoKTtcclxuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKShzdGF0dXMsIGNhbGxlclN0YWNrKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKiBBdm9pZCByZXRhaW5pbmcgdGhlIGNhbGxlclN0YWNrRXJyb3Igb2JqZWN0IGluIHRoZSBjYWxsIGNvbnRleHQgb2ZcclxuICAgICAgICAgICAgICAgICAqIHRoZSBzdGF0dXMgZXZlbnQgaGFuZGxlci4gKi9cclxuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2021 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.CompressionAlgorithms = void 0;\r\nvar CompressionAlgorithms;\r\n(function (CompressionAlgorithms) {\r\n    CompressionAlgorithms[CompressionAlgorithms[\"identity\"] = 0] = \"identity\";\r\n    CompressionAlgorithms[CompressionAlgorithms[\"deflate\"] = 1] = \"deflate\";\r\n    CompressionAlgorithms[CompressionAlgorithms[\"gzip\"] = 2] = \"gzip\";\r\n})(CompressionAlgorithms || (exports.CompressionAlgorithms = CompressionAlgorithms = {}));\r\n//# sourceMappingURL=compression-algorithms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEIsNkJBQTZCLDZCQUE2QjtBQUN2RiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcz8xNGU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkNvbXByZXNzaW9uQWxnb3JpdGhtcyA9IHZvaWQgMDtcclxudmFyIENvbXByZXNzaW9uQWxnb3JpdGhtcztcclxuKGZ1bmN0aW9uIChDb21wcmVzc2lvbkFsZ29yaXRobXMpIHtcclxuICAgIENvbXByZXNzaW9uQWxnb3JpdGhtc1tDb21wcmVzc2lvbkFsZ29yaXRobXNbXCJpZGVudGl0eVwiXSA9IDBdID0gXCJpZGVudGl0eVwiO1xyXG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImRlZmxhdGVcIl0gPSAxXSA9IFwiZGVmbGF0ZVwiO1xyXG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImd6aXBcIl0gPSAyXSA9IFwiZ3ppcFwiO1xyXG59KShDb21wcmVzc2lvbkFsZ29yaXRobXMgfHwgKGV4cG9ydHMuQ29tcHJlc3Npb25BbGdvcml0aG1zID0gQ29tcHJlc3Npb25BbGdvcml0aG1zID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\r\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\r\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst isCompressionAlgorithmKey = (key) => {\r\n    return (typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string');\r\n};\r\nclass CompressionHandler {\r\n    /**\r\n     * @param message Raw uncompressed message bytes\r\n     * @param compress Indicates whether the message should be compressed\r\n     * @return Framed message, compressed if applicable\r\n     */\r\n    async writeMessage(message, compress) {\r\n        let messageBuffer = message;\r\n        if (compress) {\r\n            messageBuffer = await this.compressMessage(messageBuffer);\r\n        }\r\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\r\n        output.writeUInt8(compress ? 1 : 0, 0);\r\n        output.writeUInt32BE(messageBuffer.length, 1);\r\n        messageBuffer.copy(output, 5);\r\n        return output;\r\n    }\r\n    /**\r\n     * @param data Framed message, possibly compressed\r\n     * @return Uncompressed message\r\n     */\r\n    async readMessage(data) {\r\n        const compressed = data.readUInt8(0) === 1;\r\n        let messageBuffer = data.slice(5);\r\n        if (compressed) {\r\n            messageBuffer = await this.decompressMessage(messageBuffer);\r\n        }\r\n        return messageBuffer;\r\n    }\r\n}\r\nclass IdentityHandler extends CompressionHandler {\r\n    async compressMessage(message) {\r\n        return message;\r\n    }\r\n    async writeMessage(message, compress) {\r\n        const output = Buffer.allocUnsafe(message.length + 5);\r\n        /* With \"identity\" compression, messages should always be marked as\r\n         * uncompressed */\r\n        output.writeUInt8(0, 0);\r\n        output.writeUInt32BE(message.length, 1);\r\n        message.copy(output, 5);\r\n        return output;\r\n    }\r\n    decompressMessage(message) {\r\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\r\n    }\r\n}\r\nclass DeflateHandler extends CompressionHandler {\r\n    constructor(maxRecvMessageLength) {\r\n        super();\r\n        this.maxRecvMessageLength = maxRecvMessageLength;\r\n    }\r\n    compressMessage(message) {\r\n        return new Promise((resolve, reject) => {\r\n            zlib.deflate(message, (err, output) => {\r\n                if (err) {\r\n                    reject(err);\r\n                }\r\n                else {\r\n                    resolve(output);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    decompressMessage(message) {\r\n        return new Promise((resolve, reject) => {\r\n            let totalLength = 0;\r\n            const messageParts = [];\r\n            const decompresser = zlib.createInflate();\r\n            decompresser.on('data', (chunk) => {\r\n                messageParts.push(chunk);\r\n                totalLength += chunk.byteLength;\r\n                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\r\n                    decompresser.destroy();\r\n                    reject({\r\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\r\n                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\r\n                    });\r\n                }\r\n            });\r\n            decompresser.on('end', () => {\r\n                resolve(Buffer.concat(messageParts));\r\n            });\r\n            decompresser.write(message);\r\n            decompresser.end();\r\n        });\r\n    }\r\n}\r\nclass GzipHandler extends CompressionHandler {\r\n    constructor(maxRecvMessageLength) {\r\n        super();\r\n        this.maxRecvMessageLength = maxRecvMessageLength;\r\n    }\r\n    compressMessage(message) {\r\n        return new Promise((resolve, reject) => {\r\n            zlib.gzip(message, (err, output) => {\r\n                if (err) {\r\n                    reject(err);\r\n                }\r\n                else {\r\n                    resolve(output);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    decompressMessage(message) {\r\n        return new Promise((resolve, reject) => {\r\n            let totalLength = 0;\r\n            const messageParts = [];\r\n            const decompresser = zlib.createGunzip();\r\n            decompresser.on('data', (chunk) => {\r\n                messageParts.push(chunk);\r\n                totalLength += chunk.byteLength;\r\n                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\r\n                    decompresser.destroy();\r\n                    reject({\r\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\r\n                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\r\n                    });\r\n                }\r\n            });\r\n            decompresser.on('end', () => {\r\n                resolve(Buffer.concat(messageParts));\r\n            });\r\n            decompresser.write(message);\r\n            decompresser.end();\r\n        });\r\n    }\r\n}\r\nclass UnknownHandler extends CompressionHandler {\r\n    constructor(compressionName) {\r\n        super();\r\n        this.compressionName = compressionName;\r\n    }\r\n    compressMessage(message) {\r\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\r\n    }\r\n    decompressMessage(message) {\r\n        // This should be unreachable\r\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\r\n    }\r\n}\r\nfunction getCompressionHandler(compressionName, maxReceiveMessageSize) {\r\n    switch (compressionName) {\r\n        case 'identity':\r\n            return new IdentityHandler();\r\n        case 'deflate':\r\n            return new DeflateHandler(maxReceiveMessageSize);\r\n        case 'gzip':\r\n            return new GzipHandler(maxReceiveMessageSize);\r\n        default:\r\n            return new UnknownHandler(compressionName);\r\n    }\r\n}\r\nclass CompressionFilter extends filter_1.BaseFilter {\r\n    constructor(channelOptions, sharedFilterConfig) {\r\n        var _a, _b;\r\n        super();\r\n        this.sharedFilterConfig = sharedFilterConfig;\r\n        this.sendCompression = new IdentityHandler();\r\n        this.receiveCompression = new IdentityHandler();\r\n        this.currentCompressionAlgorithm = 'identity';\r\n        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];\r\n        this.maxReceiveMessageLength = (_a = channelOptions['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\r\n        if (compressionAlgorithmKey !== undefined) {\r\n            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\r\n                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\r\n                const serverSupportedEncodings = (_b = sharedFilterConfig.serverSupportedEncodingHeader) === null || _b === void 0 ? void 0 : _b.split(',');\r\n                /**\r\n                 * There are two possible situations here:\r\n                 * 1) We don't have any info yet from the server about what compression it supports\r\n                 *    In that case we should just use what the client tells us to use\r\n                 * 2) We've previously received a response from the server including a grpc-accept-encoding header\r\n                 *    In that case we only want to use the encoding chosen by the client if the server supports it\r\n                 */\r\n                if (!serverSupportedEncodings ||\r\n                    serverSupportedEncodings.includes(clientSelectedEncoding)) {\r\n                    this.currentCompressionAlgorithm = clientSelectedEncoding;\r\n                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);\r\n                }\r\n            }\r\n            else {\r\n                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\r\n            }\r\n        }\r\n    }\r\n    async sendMetadata(metadata) {\r\n        const headers = await metadata;\r\n        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\r\n        headers.set('accept-encoding', 'identity');\r\n        // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\r\n        if (this.currentCompressionAlgorithm === 'identity') {\r\n            headers.remove('grpc-encoding');\r\n        }\r\n        else {\r\n            headers.set('grpc-encoding', this.currentCompressionAlgorithm);\r\n        }\r\n        return headers;\r\n    }\r\n    receiveMetadata(metadata) {\r\n        const receiveEncoding = metadata.get('grpc-encoding');\r\n        if (receiveEncoding.length > 0) {\r\n            const encoding = receiveEncoding[0];\r\n            if (typeof encoding === 'string') {\r\n                this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);\r\n            }\r\n        }\r\n        metadata.remove('grpc-encoding');\r\n        /* Check to see if the compression we're using to send messages is supported by the server\r\n         * If not, reset the sendCompression filter and have it use the default IdentityHandler */\r\n        const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];\r\n        if (serverSupportedEncodingsHeader) {\r\n            this.sharedFilterConfig.serverSupportedEncodingHeader =\r\n                serverSupportedEncodingsHeader;\r\n            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');\r\n            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\r\n                this.sendCompression = new IdentityHandler();\r\n                this.currentCompressionAlgorithm = 'identity';\r\n            }\r\n        }\r\n        metadata.remove('grpc-accept-encoding');\r\n        return metadata;\r\n    }\r\n    async sendMessage(message) {\r\n        var _a;\r\n        /* This filter is special. The input message is the bare message bytes,\r\n         * and the output is a framed and possibly compressed message. For this\r\n         * reason, this filter should be at the bottom of the filter stack */\r\n        const resolvedMessage = await message;\r\n        let compress;\r\n        if (this.sendCompression instanceof IdentityHandler) {\r\n            compress = false;\r\n        }\r\n        else {\r\n            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* WriteFlags.NoCompress */) === 0;\r\n        }\r\n        return {\r\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\r\n            flags: resolvedMessage.flags,\r\n        };\r\n    }\r\n    async receiveMessage(message) {\r\n        /* This filter is also special. The input message is framed and possibly\r\n         * compressed, and the output message is deframed and uncompressed. So\r\n         * this is another reason that this filter should be at the bottom of the\r\n         * filter stack. */\r\n        return this.receiveCompression.readMessage(await message);\r\n    }\r\n}\r\nexports.CompressionFilter = CompressionFilter;\r\nclass CompressionFilterFactory {\r\n    constructor(channel, options) {\r\n        this.options = options;\r\n        this.sharedFilterConfig = {};\r\n    }\r\n    createFilter() {\r\n        return new CompressionFilter(this.options, this.sharedFilterConfig);\r\n    }\r\n}\r\nexports.CompressionFilterFactory = CompressionFilterFactory;\r\n//# sourceMappingURL=compression-filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLEdBQUcseUJBQXlCO0FBQzVELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixpQ0FBaUMsbUJBQU8sQ0FBQyx3R0FBMEI7QUFDbkUsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDBCQUEwQjtBQUN2SCxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RiwwQkFBMEI7QUFDdkgscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHFCQUFxQjtBQUNoSTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUscUJBQXFCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFJQUFxSSx3QkFBd0I7QUFDN0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1maWx0ZXIuanM/MTM3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkNvbXByZXNzaW9uRmlsdGVyID0gdm9pZCAwO1xyXG5jb25zdCB6bGliID0gcmVxdWlyZShcInpsaWJcIik7XHJcbmNvbnN0IGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWFsZ29yaXRobXNcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlclwiKTtcclxuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IGlzQ29tcHJlc3Npb25BbGdvcml0aG1LZXkgPSAoa2V5KSA9PiB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBrZXkgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zW2tleV0gPT09ICdzdHJpbmcnKTtcclxufTtcclxuY2xhc3MgQ29tcHJlc3Npb25IYW5kbGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgUmF3IHVuY29tcHJlc3NlZCBtZXNzYWdlIGJ5dGVzXHJcbiAgICAgKiBAcGFyYW0gY29tcHJlc3MgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1lc3NhZ2Ugc2hvdWxkIGJlIGNvbXByZXNzZWRcclxuICAgICAqIEByZXR1cm4gRnJhbWVkIG1lc3NhZ2UsIGNvbXByZXNzZWQgaWYgYXBwbGljYWJsZVxyXG4gICAgICovXHJcbiAgICBhc3luYyB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgY29tcHJlc3MpIHtcclxuICAgICAgICBsZXQgbWVzc2FnZUJ1ZmZlciA9IG1lc3NhZ2U7XHJcbiAgICAgICAgaWYgKGNvbXByZXNzKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VCdWZmZXIgPSBhd2FpdCB0aGlzLmNvbXByZXNzTWVzc2FnZShtZXNzYWdlQnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lc3NhZ2VCdWZmZXIubGVuZ3RoICsgNSk7XHJcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDgoY29tcHJlc3MgPyAxIDogMCwgMCk7XHJcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDMyQkUobWVzc2FnZUJ1ZmZlci5sZW5ndGgsIDEpO1xyXG4gICAgICAgIG1lc3NhZ2VCdWZmZXIuY29weShvdXRwdXQsIDUpO1xyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBkYXRhIEZyYW1lZCBtZXNzYWdlLCBwb3NzaWJseSBjb21wcmVzc2VkXHJcbiAgICAgKiBAcmV0dXJuIFVuY29tcHJlc3NlZCBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWRNZXNzYWdlKGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjb21wcmVzc2VkID0gZGF0YS5yZWFkVUludDgoMCkgPT09IDE7XHJcbiAgICAgICAgbGV0IG1lc3NhZ2VCdWZmZXIgPSBkYXRhLnNsaWNlKDUpO1xyXG4gICAgICAgIGlmIChjb21wcmVzc2VkKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VCdWZmZXIgPSBhd2FpdCB0aGlzLmRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2VCdWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWVzc2FnZUJ1ZmZlcjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBJZGVudGl0eUhhbmRsZXIgZXh0ZW5kcyBDb21wcmVzc2lvbkhhbmRsZXIge1xyXG4gICAgYXN5bmMgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgIH1cclxuICAgIGFzeW5jIHdyaXRlTWVzc2FnZShtZXNzYWdlLCBjb21wcmVzcykge1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXNzYWdlLmxlbmd0aCArIDUpO1xyXG4gICAgICAgIC8qIFdpdGggXCJpZGVudGl0eVwiIGNvbXByZXNzaW9uLCBtZXNzYWdlcyBzaG91bGQgYWx3YXlzIGJlIG1hcmtlZCBhc1xyXG4gICAgICAgICAqIHVuY29tcHJlc3NlZCAqL1xyXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KDAsIDApO1xyXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKG1lc3NhZ2UubGVuZ3RoLCAxKTtcclxuICAgICAgICBtZXNzYWdlLmNvcHkob3V0cHV0LCA1KTtcclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1JlY2VpdmVkIGNvbXByZXNzZWQgbWVzc2FnZSBidXQgXCJncnBjLWVuY29kaW5nXCIgaGVhZGVyIHdhcyBpZGVudGl0eScpKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBEZWZsYXRlSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYXhSZWN2TWVzc2FnZUxlbmd0aCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCA9IG1heFJlY3ZNZXNzYWdlTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB6bGliLmRlZmxhdGUobWVzc2FnZSwgKGVyciwgb3V0cHV0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0b3RhbExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VQYXJ0cyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBkZWNvbXByZXNzZXIgPSB6bGliLmNyZWF0ZUluZmxhdGUoKTtcclxuICAgICAgICAgICAgZGVjb21wcmVzc2VyLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaChjaHVuayk7XHJcbiAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGggIT09IC0xICYmIHRvdGFsTGVuZ3RoID4gdGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIG1lc3NhZ2UgdGhhdCBkZWNvbXByZXNzZXMgdG8gYSBzaXplIGxhcmdlciB0aGFuICR7dGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aH1gXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2VuZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoQnVmZmVyLmNvbmNhdChtZXNzYWdlUGFydHMpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci53cml0ZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgZGVjb21wcmVzc2VyLmVuZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEd6aXBIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG1heFJlY3ZNZXNzYWdlTGVuZ3RoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RoID0gbWF4UmVjdk1lc3NhZ2VMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHpsaWIuZ3ppcChtZXNzYWdlLCAoZXJyLCBvdXRwdXQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVBhcnRzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlciA9IHpsaWIuY3JlYXRlR3VuemlwKCk7XHJcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5vbignZGF0YScsIChjaHVuaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY2h1bmspO1xyXG4gICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RoICE9PSAtMSAmJiB0b3RhbExlbmd0aCA+IHRoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIHRoYXQgZGVjb21wcmVzc2VzIHRvIGEgc2l6ZSBsYXJnZXIgdGhhbiAke3RoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGh9YFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGVjb21wcmVzc2VyLm9uKCdlbmQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKEJ1ZmZlci5jb25jYXQobWVzc2FnZVBhcnRzKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkZWNvbXByZXNzZXIud3JpdGUobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5lbmQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBVbmtub3duSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb21wcmVzc2lvbk5hbWUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY29tcHJlc3Npb25OYW1lID0gY29tcHJlc3Npb25OYW1lO1xyXG4gICAgfVxyXG4gICAgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBSZWNlaXZlZCBtZXNzYWdlIGNvbXByZXNzZWQgd2l0aCB1bnN1cHBvcnRlZCBjb21wcmVzc2lvbiBtZXRob2QgJHt0aGlzLmNvbXByZXNzaW9uTmFtZX1gKSk7XHJcbiAgICB9XHJcbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGVcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBDb21wcmVzc2lvbiBtZXRob2Qgbm90IHN1cHBvcnRlZDogJHt0aGlzLmNvbXByZXNzaW9uTmFtZX1gKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKGNvbXByZXNzaW9uTmFtZSwgbWF4UmVjZWl2ZU1lc3NhZ2VTaXplKSB7XHJcbiAgICBzd2l0Y2ggKGNvbXByZXNzaW9uTmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ2lkZW50aXR5JzpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZGVudGl0eUhhbmRsZXIoKTtcclxuICAgICAgICBjYXNlICdkZWZsYXRlJzpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWZsYXRlSGFuZGxlcihtYXhSZWNlaXZlTWVzc2FnZVNpemUpO1xyXG4gICAgICAgIGNhc2UgJ2d6aXAnOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEd6aXBIYW5kbGVyKG1heFJlY2VpdmVNZXNzYWdlU2l6ZSk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmtub3duSGFuZGxlcihjb21wcmVzc2lvbk5hbWUpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENvbXByZXNzaW9uRmlsdGVyIGV4dGVuZHMgZmlsdGVyXzEuQmFzZUZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsT3B0aW9ucywgc2hhcmVkRmlsdGVyQ29uZmlnKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnID0gc2hhcmVkRmlsdGVyQ29uZmlnO1xyXG4gICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gbmV3IElkZW50aXR5SGFuZGxlcigpO1xyXG4gICAgICAgIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uID0gbmV3IElkZW50aXR5SGFuZGxlcigpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID0gJ2lkZW50aXR5JztcclxuICAgICAgICBjb25zdCBjb21wcmVzc2lvbkFsZ29yaXRobUtleSA9IGNoYW5uZWxPcHRpb25zWydncnBjLmRlZmF1bHRfY29tcHJlc3Npb25fYWxnb3JpdGhtJ107XHJcbiAgICAgICAgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZUxlbmd0aCA9IChfYSA9IGNoYW5uZWxPcHRpb25zWydncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJ10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEg7XHJcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3Npb25BbGdvcml0aG1LZXkoY29tcHJlc3Npb25BbGdvcml0aG1LZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRTZWxlY3RlZEVuY29kaW5nID0gY29tcHJlc3Npb25fYWxnb3JpdGhtc18xLkNvbXByZXNzaW9uQWxnb3JpdGhtc1tjb21wcmVzc2lvbkFsZ29yaXRobUtleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MgPSAoX2IgPSBzaGFyZWRGaWx0ZXJDb25maWcuc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdIZWFkZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNpdHVhdGlvbnMgaGVyZTpcclxuICAgICAgICAgICAgICAgICAqIDEpIFdlIGRvbid0IGhhdmUgYW55IGluZm8geWV0IGZyb20gdGhlIHNlcnZlciBhYm91dCB3aGF0IGNvbXByZXNzaW9uIGl0IHN1cHBvcnRzXHJcbiAgICAgICAgICAgICAgICAgKiAgICBJbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIGp1c3QgdXNlIHdoYXQgdGhlIGNsaWVudCB0ZWxscyB1cyB0byB1c2VcclxuICAgICAgICAgICAgICAgICAqIDIpIFdlJ3ZlIHByZXZpb3VzbHkgcmVjZWl2ZWQgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgaW5jbHVkaW5nIGEgZ3JwYy1hY2NlcHQtZW5jb2RpbmcgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgKiAgICBJbiB0aGF0IGNhc2Ugd2Ugb25seSB3YW50IHRvIHVzZSB0aGUgZW5jb2RpbmcgY2hvc2VuIGJ5IHRoZSBjbGllbnQgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBpdFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncy5pbmNsdWRlcyhjbGllbnRTZWxlY3RlZEVuY29kaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID0gY2xpZW50U2VsZWN0ZWRFbmNvZGluZztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRDb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uSGFuZGxlcih0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSwgLTEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBgSW52YWxpZCB2YWx1ZSBwcm92aWRlZCBmb3IgZ3JwYy5kZWZhdWx0X2NvbXByZXNzaW9uX2FsZ29yaXRobSBvcHRpb246ICR7Y29tcHJlc3Npb25BbGdvcml0aG1LZXl9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgbWV0YWRhdGE7XHJcbiAgICAgICAgaGVhZGVycy5zZXQoJ2dycGMtYWNjZXB0LWVuY29kaW5nJywgJ2lkZW50aXR5LGRlZmxhdGUsZ3ppcCcpO1xyXG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQtZW5jb2RpbmcnLCAnaWRlbnRpdHknKTtcclxuICAgICAgICAvLyBObyBuZWVkIHRvIHNlbmQgdGhlIGhlYWRlciBpZiBpdCdzIFwiaWRlbnRpdHlcIiAtICBiZWhhdmlvciBpcyBpZGVudGljYWw7IHNhdmUgdGhlIGJhbmR3aWR0aFxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9PT0gJ2lkZW50aXR5Jykge1xyXG4gICAgICAgICAgICBoZWFkZXJzLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ2dycGMtZW5jb2RpbmcnLCB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xyXG4gICAgfVxyXG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgcmVjZWl2ZUVuY29kaW5nID0gbWV0YWRhdGEuZ2V0KCdncnBjLWVuY29kaW5nJyk7XHJcbiAgICAgICAgaWYgKHJlY2VpdmVFbmNvZGluZy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kaW5nID0gcmVjZWl2ZUVuY29kaW5nWzBdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlQ29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvbkhhbmRsZXIoZW5jb2RpbmcsIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VMZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xyXG4gICAgICAgIC8qIENoZWNrIHRvIHNlZSBpZiB0aGUgY29tcHJlc3Npb24gd2UncmUgdXNpbmcgdG8gc2VuZCBtZXNzYWdlcyBpcyBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlclxyXG4gICAgICAgICAqIElmIG5vdCwgcmVzZXQgdGhlIHNlbmRDb21wcmVzc2lvbiBmaWx0ZXIgYW5kIGhhdmUgaXQgdXNlIHRoZSBkZWZhdWx0IElkZW50aXR5SGFuZGxlciAqL1xyXG4gICAgICAgIGNvbnN0IHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlciA9IG1ldGFkYXRhLmdldCgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKVswXTtcclxuICAgICAgICBpZiAoc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnLnNlcnZlclN1cHBvcnRlZEVuY29kaW5nSGVhZGVyID1cclxuICAgICAgICAgICAgICAgIHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlcjtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzID0gc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzSGVhZGVyLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgIGlmICghc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzLmluY2x1ZGVzKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9ICdpZGVudGl0eSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLWFjY2VwdC1lbmNvZGluZycpO1xyXG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcclxuICAgIH1cclxuICAgIGFzeW5jIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLyogVGhpcyBmaWx0ZXIgaXMgc3BlY2lhbC4gVGhlIGlucHV0IG1lc3NhZ2UgaXMgdGhlIGJhcmUgbWVzc2FnZSBieXRlcyxcclxuICAgICAgICAgKiBhbmQgdGhlIG91dHB1dCBpcyBhIGZyYW1lZCBhbmQgcG9zc2libHkgY29tcHJlc3NlZCBtZXNzYWdlLiBGb3IgdGhpc1xyXG4gICAgICAgICAqIHJlYXNvbiwgdGhpcyBmaWx0ZXIgc2hvdWxkIGJlIGF0IHRoZSBib3R0b20gb2YgdGhlIGZpbHRlciBzdGFjayAqL1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkTWVzc2FnZSA9IGF3YWl0IG1lc3NhZ2U7XHJcbiAgICAgICAgbGV0IGNvbXByZXNzO1xyXG4gICAgICAgIGlmICh0aGlzLnNlbmRDb21wcmVzc2lvbiBpbnN0YW5jZW9mIElkZW50aXR5SGFuZGxlcikge1xyXG4gICAgICAgICAgICBjb21wcmVzcyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29tcHJlc3MgPSAoKChfYSA9IHJlc29sdmVkTWVzc2FnZS5mbGFncykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgJiAyIC8qIFdyaXRlRmxhZ3MuTm9Db21wcmVzcyAqLykgPT09IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHRoaXMuc2VuZENvbXByZXNzaW9uLndyaXRlTWVzc2FnZShyZXNvbHZlZE1lc3NhZ2UubWVzc2FnZSwgY29tcHJlc3MpLFxyXG4gICAgICAgICAgICBmbGFnczogcmVzb2x2ZWRNZXNzYWdlLmZsYWdzLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyByZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XHJcbiAgICAgICAgLyogVGhpcyBmaWx0ZXIgaXMgYWxzbyBzcGVjaWFsLiBUaGUgaW5wdXQgbWVzc2FnZSBpcyBmcmFtZWQgYW5kIHBvc3NpYmx5XHJcbiAgICAgICAgICogY29tcHJlc3NlZCwgYW5kIHRoZSBvdXRwdXQgbWVzc2FnZSBpcyBkZWZyYW1lZCBhbmQgdW5jb21wcmVzc2VkLiBTb1xyXG4gICAgICAgICAqIHRoaXMgaXMgYW5vdGhlciByZWFzb24gdGhhdCB0aGlzIGZpbHRlciBzaG91bGQgYmUgYXQgdGhlIGJvdHRvbSBvZiB0aGVcclxuICAgICAgICAgKiBmaWx0ZXIgc3RhY2suICovXHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uLnJlYWRNZXNzYWdlKGF3YWl0IG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXIgPSBDb21wcmVzc2lvbkZpbHRlcjtcclxuY2xhc3MgQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5IHtcclxuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnID0ge307XHJcbiAgICB9XHJcbiAgICBjcmVhdGVGaWx0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wcmVzc2lvbkZpbHRlcih0aGlzLm9wdGlvbnMsIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSA9IENvbXByZXNzaW9uRmlsdGVyRmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcHJlc3Npb24tZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/connectivity-state.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2021 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ConnectivityState = void 0;\r\nvar ConnectivityState;\r\n(function (ConnectivityState) {\r\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\r\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\r\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\r\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\r\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\r\n})(ConnectivityState || (exports.ConnectivityState = ConnectivityState = {}));\r\n//# sourceMappingURL=connectivity-state.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IseUJBQXlCLHlCQUF5QjtBQUMzRSIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzP2I5ODMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ29ubmVjdGl2aXR5U3RhdGUgPSB2b2lkIDA7XHJcbnZhciBDb25uZWN0aXZpdHlTdGF0ZTtcclxuKGZ1bmN0aW9uIChDb25uZWN0aXZpdHlTdGF0ZSkge1xyXG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJJRExFXCJdID0gMF0gPSBcIklETEVcIjtcclxuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiQ09OTkVDVElOR1wiXSA9IDFdID0gXCJDT05ORUNUSU5HXCI7XHJcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIlJFQURZXCJdID0gMl0gPSBcIlJFQURZXCI7XHJcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIlRSQU5TSUVOVF9GQUlMVVJFXCJdID0gM10gPSBcIlRSQU5TSUVOVF9GQUlMVVJFXCI7XHJcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIlNIVVRET1dOXCJdID0gNF0gPSBcIlNIVVRET1dOXCI7XHJcbn0pKENvbm5lY3Rpdml0eVN0YXRlIHx8IChleHBvcnRzLkNvbm5lY3Rpdml0eVN0YXRlID0gQ29ubmVjdGl2aXR5U3RhdGUgPSB7fSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aXZpdHktc3RhdGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;\r\nvar Status;\r\n(function (Status) {\r\n    Status[Status[\"OK\"] = 0] = \"OK\";\r\n    Status[Status[\"CANCELLED\"] = 1] = \"CANCELLED\";\r\n    Status[Status[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\r\n    Status[Status[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\r\n    Status[Status[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\r\n    Status[Status[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\r\n    Status[Status[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\r\n    Status[Status[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\r\n    Status[Status[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\r\n    Status[Status[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\r\n    Status[Status[\"ABORTED\"] = 10] = \"ABORTED\";\r\n    Status[Status[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\r\n    Status[Status[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\r\n    Status[Status[\"INTERNAL\"] = 13] = \"INTERNAL\";\r\n    Status[Status[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\r\n    Status[Status[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\r\n    Status[Status[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\r\n})(Status || (exports.Status = Status = {}));\r\nvar LogVerbosity;\r\n(function (LogVerbosity) {\r\n    LogVerbosity[LogVerbosity[\"DEBUG\"] = 0] = \"DEBUG\";\r\n    LogVerbosity[LogVerbosity[\"INFO\"] = 1] = \"INFO\";\r\n    LogVerbosity[LogVerbosity[\"ERROR\"] = 2] = \"ERROR\";\r\n    LogVerbosity[LogVerbosity[\"NONE\"] = 3] = \"NONE\";\r\n})(LogVerbosity || (exports.LogVerbosity = LogVerbosity = {}));\r\n/**\r\n * NOTE: This enum is not currently used in any implemented API in this\r\n * library. It is included only for type parity with the other implementation.\r\n */\r\nvar Propagate;\r\n(function (Propagate) {\r\n    Propagate[Propagate[\"DEADLINE\"] = 1] = \"DEADLINE\";\r\n    Propagate[Propagate[\"CENSUS_STATS_CONTEXT\"] = 2] = \"CENSUS_STATS_CONTEXT\";\r\n    Propagate[Propagate[\"CENSUS_TRACING_CONTEXT\"] = 4] = \"CENSUS_TRACING_CONTEXT\";\r\n    Propagate[Propagate[\"CANCELLATION\"] = 8] = \"CANCELLATION\";\r\n    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43\r\n    Propagate[Propagate[\"DEFAULTS\"] = 65535] = \"DEFAULTS\";\r\n})(Propagate || (exports.Propagate = Propagate = {}));\r\n// -1 means unlimited\r\nexports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;\r\n// 4 MB default\r\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;\r\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMENBQTBDLEdBQUcsdUNBQXVDLEdBQUcsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcsY0FBYztBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYSxjQUFjLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUIsb0JBQW9CLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQkFBaUIsaUJBQWlCO0FBQ25EO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsMENBQTBDO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25zdGFudHMuanM/NzM0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIID0gZXhwb3J0cy5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIID0gZXhwb3J0cy5Qcm9wYWdhdGUgPSBleHBvcnRzLkxvZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuU3RhdHVzID0gdm9pZCAwO1xyXG52YXIgU3RhdHVzO1xyXG4oZnVuY3Rpb24gKFN0YXR1cykge1xyXG4gICAgU3RhdHVzW1N0YXR1c1tcIk9LXCJdID0gMF0gPSBcIk9LXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiQ0FOQ0VMTEVEXCJdID0gMV0gPSBcIkNBTkNFTExFRFwiO1xyXG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOS05PV05cIl0gPSAyXSA9IFwiVU5LTk9XTlwiO1xyXG4gICAgU3RhdHVzW1N0YXR1c1tcIklOVkFMSURfQVJHVU1FTlRcIl0gPSAzXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xyXG4gICAgU3RhdHVzW1N0YXR1c1tcIkRFQURMSU5FX0VYQ0VFREVEXCJdID0gNF0gPSBcIkRFQURMSU5FX0VYQ0VFREVEXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiTk9UX0ZPVU5EXCJdID0gNV0gPSBcIk5PVF9GT1VORFwiO1xyXG4gICAgU3RhdHVzW1N0YXR1c1tcIkFMUkVBRFlfRVhJU1RTXCJdID0gNl0gPSBcIkFMUkVBRFlfRVhJU1RTXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiUEVSTUlTU0lPTl9ERU5JRURcIl0gPSA3XSA9IFwiUEVSTUlTU0lPTl9ERU5JRURcIjtcclxuICAgIFN0YXR1c1tTdGF0dXNbXCJSRVNPVVJDRV9FWEhBVVNURURcIl0gPSA4XSA9IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiRkFJTEVEX1BSRUNPTkRJVElPTlwiXSA9IDldID0gXCJGQUlMRURfUFJFQ09ORElUSU9OXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiQUJPUlRFRFwiXSA9IDEwXSA9IFwiQUJPUlRFRFwiO1xyXG4gICAgU3RhdHVzW1N0YXR1c1tcIk9VVF9PRl9SQU5HRVwiXSA9IDExXSA9IFwiT1VUX09GX1JBTkdFXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5JTVBMRU1FTlRFRFwiXSA9IDEyXSA9IFwiVU5JTVBMRU1FTlRFRFwiO1xyXG4gICAgU3RhdHVzW1N0YXR1c1tcIklOVEVSTkFMXCJdID0gMTNdID0gXCJJTlRFUk5BTFwiO1xyXG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOQVZBSUxBQkxFXCJdID0gMTRdID0gXCJVTkFWQUlMQUJMRVwiO1xyXG4gICAgU3RhdHVzW1N0YXR1c1tcIkRBVEFfTE9TU1wiXSA9IDE1XSA9IFwiREFUQV9MT1NTXCI7XHJcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5BVVRIRU5USUNBVEVEXCJdID0gMTZdID0gXCJVTkFVVEhFTlRJQ0FURURcIjtcclxufSkoU3RhdHVzIHx8IChleHBvcnRzLlN0YXR1cyA9IFN0YXR1cyA9IHt9KSk7XHJcbnZhciBMb2dWZXJib3NpdHk7XHJcbihmdW5jdGlvbiAoTG9nVmVyYm9zaXR5KSB7XHJcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiREVCVUdcIl0gPSAwXSA9IFwiREVCVUdcIjtcclxuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJJTkZPXCJdID0gMV0gPSBcIklORk9cIjtcclxuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJFUlJPUlwiXSA9IDJdID0gXCJFUlJPUlwiO1xyXG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIk5PTkVcIl0gPSAzXSA9IFwiTk9ORVwiO1xyXG59KShMb2dWZXJib3NpdHkgfHwgKGV4cG9ydHMuTG9nVmVyYm9zaXR5ID0gTG9nVmVyYm9zaXR5ID0ge30pKTtcclxuLyoqXHJcbiAqIE5PVEU6IFRoaXMgZW51bSBpcyBub3QgY3VycmVudGx5IHVzZWQgaW4gYW55IGltcGxlbWVudGVkIEFQSSBpbiB0aGlzXHJcbiAqIGxpYnJhcnkuIEl0IGlzIGluY2x1ZGVkIG9ubHkgZm9yIHR5cGUgcGFyaXR5IHdpdGggdGhlIG90aGVyIGltcGxlbWVudGF0aW9uLlxyXG4gKi9cclxudmFyIFByb3BhZ2F0ZTtcclxuKGZ1bmN0aW9uIChQcm9wYWdhdGUpIHtcclxuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJERUFETElORVwiXSA9IDFdID0gXCJERUFETElORVwiO1xyXG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19TVEFUU19DT05URVhUXCJdID0gMl0gPSBcIkNFTlNVU19TVEFUU19DT05URVhUXCI7XHJcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiQ0VOU1VTX1RSQUNJTkdfQ09OVEVYVFwiXSA9IDRdID0gXCJDRU5TVVNfVFJBQ0lOR19DT05URVhUXCI7XHJcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiQ0FOQ0VMTEFUSU9OXCJdID0gOF0gPSBcIkNBTkNFTExBVElPTlwiO1xyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9pbmNsdWRlL2dycGMvaW1wbC9jb2RlZ2VuL3Byb3BhZ2F0aW9uX2JpdHMuaCNMNDNcclxuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJERUZBVUxUU1wiXSA9IDY1NTM1XSA9IFwiREVGQVVMVFNcIjtcclxufSkoUHJvcGFnYXRlIHx8IChleHBvcnRzLlByb3BhZ2F0ZSA9IFByb3BhZ2F0ZSA9IHt9KSk7XHJcbi8vIC0xIG1lYW5zIHVubGltaXRlZFxyXG5leHBvcnRzLkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEggPSAtMTtcclxuLy8gNCBNQiBkZWZhdWx0XHJcbmV4cG9ydHMuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCA9IDQgKiAxMDI0ICogMTAyNDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/control-plane-status.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.restrictControlPlaneStatusCode = void 0;\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [\r\n    constants_1.Status.OK,\r\n    constants_1.Status.INVALID_ARGUMENT,\r\n    constants_1.Status.NOT_FOUND,\r\n    constants_1.Status.ALREADY_EXISTS,\r\n    constants_1.Status.FAILED_PRECONDITION,\r\n    constants_1.Status.ABORTED,\r\n    constants_1.Status.OUT_OF_RANGE,\r\n    constants_1.Status.DATA_LOSS,\r\n];\r\nfunction restrictControlPlaneStatusCode(code, details) {\r\n    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\r\n        return {\r\n            code: constants_1.Status.INTERNAL,\r\n            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`,\r\n        };\r\n    }\r\n    else {\r\n        return { code, details };\r\n    }\r\n}\r\nexports.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;\r\n//# sourceMappingURL=control-plane-status.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29udHJvbC1wbGFuZS1zdGF0dXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0M7QUFDdEMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxNQUFNLEVBQUUsMEJBQTBCLEVBQUUsUUFBUTtBQUN2RztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29udHJvbC1wbGFuZS1zdGF0dXMuanM/NTk3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUgPSB2b2lkIDA7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBJTkFQUFJPUFJJQVRFX0NPTlRST0xfUExBTkVfQ09ERVMgPSBbXHJcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuT0ssXHJcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuSU5WQUxJRF9BUkdVTUVOVCxcclxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXHJcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuQUxSRUFEWV9FWElTVFMsXHJcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuRkFJTEVEX1BSRUNPTkRJVElPTixcclxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5BQk9SVEVELFxyXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk9VVF9PRl9SQU5HRSxcclxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5EQVRBX0xPU1MsXHJcbl07XHJcbmZ1bmN0aW9uIHJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZShjb2RlLCBkZXRhaWxzKSB7XHJcbiAgICBpZiAoSU5BUFBST1BSSUFURV9DT05UUk9MX1BMQU5FX0NPREVTLmluY2x1ZGVzKGNvZGUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxyXG4gICAgICAgICAgICBkZXRhaWxzOiBgSW52YWxpZCBzdGF0dXMgZnJvbSBjb250cm9sIHBsYW5lOiAke2NvZGV9ICR7Y29uc3RhbnRzXzEuU3RhdHVzW2NvZGVdfSAke2RldGFpbHN9YCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgY29kZSwgZGV0YWlscyB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlID0gcmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cm9sLXBsYW5lLXN0YXR1cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/deadline.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.deadlineToString = exports.getRelativeTimeout = exports.getDeadlineTimeoutString = exports.minDeadline = void 0;\r\nfunction minDeadline(...deadlineList) {\r\n    let minValue = Infinity;\r\n    for (const deadline of deadlineList) {\r\n        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\r\n        if (deadlineMsecs < minValue) {\r\n            minValue = deadlineMsecs;\r\n        }\r\n    }\r\n    return minValue;\r\n}\r\nexports.minDeadline = minDeadline;\r\nconst units = [\r\n    ['m', 1],\r\n    ['S', 1000],\r\n    ['M', 60 * 1000],\r\n    ['H', 60 * 60 * 1000],\r\n];\r\nfunction getDeadlineTimeoutString(deadline) {\r\n    const now = new Date().getTime();\r\n    if (deadline instanceof Date) {\r\n        deadline = deadline.getTime();\r\n    }\r\n    const timeoutMs = Math.max(deadline - now, 0);\r\n    for (const [unit, factor] of units) {\r\n        const amount = timeoutMs / factor;\r\n        if (amount < 1e8) {\r\n            return String(Math.ceil(amount)) + unit;\r\n        }\r\n    }\r\n    throw new Error('Deadline is too far in the future');\r\n}\r\nexports.getDeadlineTimeoutString = getDeadlineTimeoutString;\r\n/**\r\n * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\r\n * In particular, \"When delay is larger than 2147483647 or less than 1, the\r\n * delay will be set to 1. Non-integer delays are truncated to an integer.\"\r\n * This number of milliseconds is almost 25 days.\r\n */\r\nconst MAX_TIMEOUT_TIME = 2147483647;\r\n/**\r\n * Get the timeout value that should be passed to setTimeout now for the timer\r\n * to end at the deadline. For any deadline before now, the timer should end\r\n * immediately, represented by a value of 0. For any deadline more than\r\n * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will\r\n * end at that time, so it is treated as infinitely far in the future.\r\n * @param deadline\r\n * @returns\r\n */\r\nfunction getRelativeTimeout(deadline) {\r\n    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;\r\n    const now = new Date().getTime();\r\n    const timeout = deadlineMs - now;\r\n    if (timeout < 0) {\r\n        return 0;\r\n    }\r\n    else if (timeout > MAX_TIMEOUT_TIME) {\r\n        return Infinity;\r\n    }\r\n    else {\r\n        return timeout;\r\n    }\r\n}\r\nexports.getRelativeTimeout = getRelativeTimeout;\r\nfunction deadlineToString(deadline) {\r\n    if (deadline instanceof Date) {\r\n        return deadline.toISOString();\r\n    }\r\n    else {\r\n        const dateDeadline = new Date(deadline);\r\n        if (Number.isNaN(dateDeadline.getTime())) {\r\n            return '' + deadline;\r\n        }\r\n        else {\r\n            return dateDeadline.toISOString();\r\n        }\r\n    }\r\n}\r\nexports.deadlineToString = deadlineToString;\r\n//# sourceMappingURL=deadline.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyxnQ0FBZ0MsR0FBRyxtQkFBbUI7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUuanM/YjQxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5kZWFkbGluZVRvU3RyaW5nID0gZXhwb3J0cy5nZXRSZWxhdGl2ZVRpbWVvdXQgPSBleHBvcnRzLmdldERlYWRsaW5lVGltZW91dFN0cmluZyA9IGV4cG9ydHMubWluRGVhZGxpbmUgPSB2b2lkIDA7XHJcbmZ1bmN0aW9uIG1pbkRlYWRsaW5lKC4uLmRlYWRsaW5lTGlzdCkge1xyXG4gICAgbGV0IG1pblZhbHVlID0gSW5maW5pdHk7XHJcbiAgICBmb3IgKGNvbnN0IGRlYWRsaW5lIG9mIGRlYWRsaW5lTGlzdCkge1xyXG4gICAgICAgIGNvbnN0IGRlYWRsaW5lTXNlY3MgPSBkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUgPyBkZWFkbGluZS5nZXRUaW1lKCkgOiBkZWFkbGluZTtcclxuICAgICAgICBpZiAoZGVhZGxpbmVNc2VjcyA8IG1pblZhbHVlKSB7XHJcbiAgICAgICAgICAgIG1pblZhbHVlID0gZGVhZGxpbmVNc2VjcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWluVmFsdWU7XHJcbn1cclxuZXhwb3J0cy5taW5EZWFkbGluZSA9IG1pbkRlYWRsaW5lO1xyXG5jb25zdCB1bml0cyA9IFtcclxuICAgIFsnbScsIDFdLFxyXG4gICAgWydTJywgMTAwMF0sXHJcbiAgICBbJ00nLCA2MCAqIDEwMDBdLFxyXG4gICAgWydIJywgNjAgKiA2MCAqIDEwMDBdLFxyXG5dO1xyXG5mdW5jdGlvbiBnZXREZWFkbGluZVRpbWVvdXRTdHJpbmcoZGVhZGxpbmUpIHtcclxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgaWYgKGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgIGRlYWRsaW5lID0gZGVhZGxpbmUuZ2V0VGltZSgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGltZW91dE1zID0gTWF0aC5tYXgoZGVhZGxpbmUgLSBub3csIDApO1xyXG4gICAgZm9yIChjb25zdCBbdW5pdCwgZmFjdG9yXSBvZiB1bml0cykge1xyXG4gICAgICAgIGNvbnN0IGFtb3VudCA9IHRpbWVvdXRNcyAvIGZhY3RvcjtcclxuICAgICAgICBpZiAoYW1vdW50IDwgMWU4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoTWF0aC5jZWlsKGFtb3VudCkpICsgdW5pdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlYWRsaW5lIGlzIHRvbyBmYXIgaW4gdGhlIGZ1dHVyZScpO1xyXG59XHJcbmV4cG9ydHMuZ2V0RGVhZGxpbmVUaW1lb3V0U3RyaW5nID0gZ2V0RGVhZGxpbmVUaW1lb3V0U3RyaW5nO1xyXG4vKipcclxuICogU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjc2V0dGltZW91dGNhbGxiYWNrLWRlbGF5LWFyZ3NcclxuICogSW4gcGFydGljdWxhciwgXCJXaGVuIGRlbGF5IGlzIGxhcmdlciB0aGFuIDIxNDc0ODM2NDcgb3IgbGVzcyB0aGFuIDEsIHRoZVxyXG4gKiBkZWxheSB3aWxsIGJlIHNldCB0byAxLiBOb24taW50ZWdlciBkZWxheXMgYXJlIHRydW5jYXRlZCB0byBhbiBpbnRlZ2VyLlwiXHJcbiAqIFRoaXMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpcyBhbG1vc3QgMjUgZGF5cy5cclxuICovXHJcbmNvbnN0IE1BWF9USU1FT1VUX1RJTUUgPSAyMTQ3NDgzNjQ3O1xyXG4vKipcclxuICogR2V0IHRoZSB0aW1lb3V0IHZhbHVlIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byBzZXRUaW1lb3V0IG5vdyBmb3IgdGhlIHRpbWVyXHJcbiAqIHRvIGVuZCBhdCB0aGUgZGVhZGxpbmUuIEZvciBhbnkgZGVhZGxpbmUgYmVmb3JlIG5vdywgdGhlIHRpbWVyIHNob3VsZCBlbmRcclxuICogaW1tZWRpYXRlbHksIHJlcHJlc2VudGVkIGJ5IGEgdmFsdWUgb2YgMC4gRm9yIGFueSBkZWFkbGluZSBtb3JlIHRoYW5cclxuICogTUFYX1RJTUVPVVRfVElNRSBtaWxsaXNlY29uZHMgaW4gdGhlIGZ1dHVyZSwgYSB0aW1lciBjYW5ub3QgYmUgc2V0IHRoYXQgd2lsbFxyXG4gKiBlbmQgYXQgdGhhdCB0aW1lLCBzbyBpdCBpcyB0cmVhdGVkIGFzIGluZmluaXRlbHkgZmFyIGluIHRoZSBmdXR1cmUuXHJcbiAqIEBwYXJhbSBkZWFkbGluZVxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVUaW1lb3V0KGRlYWRsaW5lKSB7XHJcbiAgICBjb25zdCBkZWFkbGluZU1zID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUuZ2V0VGltZSgpIDogZGVhZGxpbmU7XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBkZWFkbGluZU1zIC0gbm93O1xyXG4gICAgaWYgKHRpbWVvdXQgPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aW1lb3V0ID4gTUFYX1RJTUVPVVRfVElNRSkge1xyXG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aW1lb3V0O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZ2V0UmVsYXRpdmVUaW1lb3V0ID0gZ2V0UmVsYXRpdmVUaW1lb3V0O1xyXG5mdW5jdGlvbiBkZWFkbGluZVRvU3RyaW5nKGRlYWRsaW5lKSB7XHJcbiAgICBpZiAoZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlYWRsaW5lLnRvSVNPU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBkYXRlRGVhZGxpbmUgPSBuZXcgRGF0ZShkZWFkbGluZSk7XHJcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihkYXRlRGVhZGxpbmUuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJycgKyBkZWFkbGluZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRGVhZGxpbmUudG9JU09TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5kZWFkbGluZVRvU3RyaW5nID0gZGVhZGxpbmVUb1N0cmluZztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVhZGxpbmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/duration.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.isDuration = exports.durationToMs = exports.msToDuration = void 0;\r\nfunction msToDuration(millis) {\r\n    return {\r\n        seconds: (millis / 1000) | 0,\r\n        nanos: ((millis % 1000) * 1000000) | 0,\r\n    };\r\n}\r\nexports.msToDuration = msToDuration;\r\nfunction durationToMs(duration) {\r\n    return (duration.seconds * 1000 + duration.nanos / 1000000) | 0;\r\n}\r\nexports.durationToMs = durationToMs;\r\nfunction isDuration(value) {\r\n    return typeof value.seconds === 'number' && typeof value.nanos === 'number';\r\n}\r\nexports.isDuration = isDuration;\r\n//# sourceMappingURL=duration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2R1cmF0aW9uLmpzP2YwYjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuaXNEdXJhdGlvbiA9IGV4cG9ydHMuZHVyYXRpb25Ub01zID0gZXhwb3J0cy5tc1RvRHVyYXRpb24gPSB2b2lkIDA7XHJcbmZ1bmN0aW9uIG1zVG9EdXJhdGlvbihtaWxsaXMpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2Vjb25kczogKG1pbGxpcyAvIDEwMDApIHwgMCxcclxuICAgICAgICBuYW5vczogKChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDApIHwgMCxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5tc1RvRHVyYXRpb24gPSBtc1RvRHVyYXRpb247XHJcbmZ1bmN0aW9uIGR1cmF0aW9uVG9NcyhkdXJhdGlvbikge1xyXG4gICAgcmV0dXJuIChkdXJhdGlvbi5zZWNvbmRzICogMTAwMCArIGR1cmF0aW9uLm5hbm9zIC8gMTAwMDAwMCkgfCAwO1xyXG59XHJcbmV4cG9ydHMuZHVyYXRpb25Ub01zID0gZHVyYXRpb25Ub01zO1xyXG5mdW5jdGlvbiBpc0R1cmF0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnNlY29uZHMgPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZS5uYW5vcyA9PT0gJ251bWJlcic7XHJcbn1cclxuZXhwb3J0cy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHVyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/error.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getErrorCode = exports.getErrorMessage = void 0;\r\nfunction getErrorMessage(error) {\r\n    if (error instanceof Error) {\r\n        return error.message;\r\n    }\r\n    else {\r\n        return String(error);\r\n    }\r\n}\r\nexports.getErrorMessage = getErrorMessage;\r\nfunction getErrorCode(error) {\r\n    if (typeof error === 'object' &&\r\n        error !== null &&\r\n        'code' in error &&\r\n        typeof error.code === 'number') {\r\n        return error.code;\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nexports.getErrorCode = getErrorCode;\r\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyx1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9lcnJvci5qcz8yNDA2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmdldEVycm9yQ29kZSA9IGV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlID0gdm9pZCAwO1xyXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcclxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGVycm9yKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTtcclxuZnVuY3Rpb24gZ2V0RXJyb3JDb2RlKGVycm9yKSB7XHJcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgIGVycm9yICE9PSBudWxsICYmXHJcbiAgICAgICAgJ2NvZGUnIGluIGVycm9yICYmXHJcbiAgICAgICAgdHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGVycm9yLmNvZGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdldEVycm9yQ29kZSA9IGdldEVycm9yQ29kZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/experimental.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.OutlierDetectionLoadBalancingConfig = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.subchannelAddressToString = exports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.durationToMs = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = void 0;\r\nvar logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nObject.defineProperty(exports, \"trace\", ({ enumerable: true, get: function () { return logging_1.trace; } }));\r\nObject.defineProperty(exports, \"log\", ({ enumerable: true, get: function () { return logging_1.log; } }));\r\nvar resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nObject.defineProperty(exports, \"registerResolver\", ({ enumerable: true, get: function () { return resolver_1.registerResolver; } }));\r\nObject.defineProperty(exports, \"createResolver\", ({ enumerable: true, get: function () { return resolver_1.createResolver; } }));\r\nvar uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nObject.defineProperty(exports, \"uriToString\", ({ enumerable: true, get: function () { return uri_parser_1.uriToString; } }));\r\nvar duration_1 = __webpack_require__(/*! ./duration */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\r\nObject.defineProperty(exports, \"durationToMs\", ({ enumerable: true, get: function () { return duration_1.durationToMs; } }));\r\nvar backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\r\nObject.defineProperty(exports, \"BackoffTimeout\", ({ enumerable: true, get: function () { return backoff_timeout_1.BackoffTimeout; } }));\r\nvar load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\nObject.defineProperty(exports, \"createChildChannelControlHelper\", ({ enumerable: true, get: function () { return load_balancer_1.createChildChannelControlHelper; } }));\r\nObject.defineProperty(exports, \"registerLoadBalancerType\", ({ enumerable: true, get: function () { return load_balancer_1.registerLoadBalancerType; } }));\r\nObject.defineProperty(exports, \"getFirstUsableConfig\", ({ enumerable: true, get: function () { return load_balancer_1.getFirstUsableConfig; } }));\r\nObject.defineProperty(exports, \"validateLoadBalancingConfig\", ({ enumerable: true, get: function () { return load_balancer_1.validateLoadBalancingConfig; } }));\r\nvar subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nObject.defineProperty(exports, \"subchannelAddressToString\", ({ enumerable: true, get: function () { return subchannel_address_1.subchannelAddressToString; } }));\r\nvar load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\r\nObject.defineProperty(exports, \"ChildLoadBalancerHandler\", ({ enumerable: true, get: function () { return load_balancer_child_handler_1.ChildLoadBalancerHandler; } }));\r\nvar picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nObject.defineProperty(exports, \"UnavailablePicker\", ({ enumerable: true, get: function () { return picker_1.UnavailablePicker; } }));\r\nObject.defineProperty(exports, \"QueuePicker\", ({ enumerable: true, get: function () { return picker_1.QueuePicker; } }));\r\nObject.defineProperty(exports, \"PickResultType\", ({ enumerable: true, get: function () { return picker_1.PickResultType; } }));\r\nvar filter_1 = __webpack_require__(/*! ./filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\r\nObject.defineProperty(exports, \"BaseFilter\", ({ enumerable: true, get: function () { return filter_1.BaseFilter; } }));\r\nvar filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\r\nObject.defineProperty(exports, \"FilterStackFactory\", ({ enumerable: true, get: function () { return filter_stack_1.FilterStackFactory; } }));\r\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\r\nObject.defineProperty(exports, \"registerAdminService\", ({ enumerable: true, get: function () { return admin_1.registerAdminService; } }));\r\nvar subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\r\nObject.defineProperty(exports, \"BaseSubchannelWrapper\", ({ enumerable: true, get: function () { return subchannel_interface_1.BaseSubchannelWrapper; } }));\r\nvar load_balancer_outlier_detection_1 = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\r\nObject.defineProperty(exports, \"OutlierDetectionLoadBalancingConfig\", ({ enumerable: true, get: function () { return load_balancer_outlier_detection_1.OutlierDetectionLoadBalancingConfig; } }));\r\n//# sourceMappingURL=experimental.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXhwZXJpbWVudGFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJDQUEyQyxHQUFHLDZCQUE2QixHQUFHLDRCQUE0QixHQUFHLDBCQUEwQixHQUFHLGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLHlCQUF5QixHQUFHLGdDQUFnQyxHQUFHLGlDQUFpQyxHQUFHLG1DQUFtQyxHQUFHLDRCQUE0QixHQUFHLGdDQUFnQyxHQUFHLHVDQUF1QyxHQUFHLHNCQUFzQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLFdBQVcsR0FBRyxhQUFhO0FBQ3hsQixnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQyx5Q0FBd0MsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDM0csdUNBQXNDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3ZHLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3JDLG9EQUFtRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNsSSxrREFBaUQsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDOUgsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWM7QUFDekMsK0NBQThDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzFILGlCQUFpQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3JDLGdEQUErQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMxSCx3QkFBd0IsbUJBQU8sQ0FBQywwRkFBbUI7QUFDbkQsa0RBQWlELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQ3JJLHNCQUFzQixtQkFBTyxDQUFDLHNGQUFpQjtBQUMvQyxtRUFBa0UsRUFBRSxxQ0FBcUMsMkRBQTJELEVBQUM7QUFDckssNERBQTJELEVBQUUscUNBQXFDLG9EQUFvRCxFQUFDO0FBQ3ZKLHdEQUF1RCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUMvSSwrREFBOEQsRUFBRSxxQ0FBcUMsdURBQXVELEVBQUM7QUFDN0osMkJBQTJCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQ3pELDZEQUE0RCxFQUFFLHFDQUFxQywwREFBMEQsRUFBQztBQUM5SixvQ0FBb0MsbUJBQU8sQ0FBQyxrSEFBK0I7QUFDM0UsNERBQTJELEVBQUUscUNBQXFDLGtFQUFrRSxFQUFDO0FBQ3JLLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxxREFBb0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDbEksK0NBQThDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3RILGtEQUFpRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUM1SCxlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsOENBQTZDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ3BILHFCQUFxQixtQkFBTyxDQUFDLG9GQUFnQjtBQUM3QyxzREFBcUQsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDMUksY0FBYyxtQkFBTyxDQUFDLHNFQUFTO0FBQy9CLHdEQUF1RCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUN2SSw2QkFBNkIsbUJBQU8sQ0FBQyxvR0FBd0I7QUFDN0QseURBQXdELEVBQUUscUNBQXFDLHdEQUF3RCxFQUFDO0FBQ3hKLHdDQUF3QyxtQkFBTyxDQUFDLDBIQUFtQztBQUNuRix1RUFBc0UsRUFBRSxxQ0FBcUMsaUZBQWlGLEVBQUM7QUFDL0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2V4cGVyaW1lbnRhbC5qcz9lMGQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcgPSBleHBvcnRzLkJhc2VTdWJjaGFubmVsV3JhcHBlciA9IGV4cG9ydHMucmVnaXN0ZXJBZG1pblNlcnZpY2UgPSBleHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUZpbHRlciA9IGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSBleHBvcnRzLlF1ZXVlUGlja2VyID0gZXhwb3J0cy5VbmF2YWlsYWJsZVBpY2tlciA9IGV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gZXhwb3J0cy52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcgPSBleHBvcnRzLmdldEZpcnN0VXNhYmxlQ29uZmlnID0gZXhwb3J0cy5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUgPSBleHBvcnRzLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIgPSBleHBvcnRzLkJhY2tvZmZUaW1lb3V0ID0gZXhwb3J0cy5kdXJhdGlvblRvTXMgPSBleHBvcnRzLnVyaVRvU3RyaW5nID0gZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IGV4cG9ydHMubG9nID0gZXhwb3J0cy50cmFjZSA9IHZvaWQgMDtcclxudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRyYWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2dnaW5nXzEudHJhY2U7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2luZ18xLmxvZzsgfSB9KTtcclxudmFyIHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJSZXNvbHZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVSZXNvbHZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcjsgfSB9KTtcclxudmFyIHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVyaVRvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmc7IH0gfSk7XHJcbnZhciBkdXJhdGlvbl8xID0gcmVxdWlyZShcIi4vZHVyYXRpb25cIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImR1cmF0aW9uVG9Nc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHVyYXRpb25fMS5kdXJhdGlvblRvTXM7IH0gfSk7XHJcbnZhciBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFja29mZlRpbWVvdXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0OyB9IH0pO1xyXG52YXIgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXI7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Rmlyc3RVc2FibGVDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfMS5nZXRGaXJzdFVzYWJsZUNvbmZpZzsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnOyB9IH0pO1xyXG52YXIgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmc7IH0gfSk7XHJcbnZhciBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlclwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXI7IH0gfSk7XHJcbnZhciBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5hdmFpbGFibGVQaWNrZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRdWV1ZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUXVldWVQaWNrZXI7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBpY2tSZXN1bHRUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZTsgfSB9KTtcclxudmFyIGZpbHRlcl8xID0gcmVxdWlyZShcIi4vZmlsdGVyXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlRmlsdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfMS5CYXNlRmlsdGVyOyB9IH0pO1xyXG52YXIgZmlsdGVyX3N0YWNrXzEgPSByZXF1aXJlKFwiLi9maWx0ZXItc3RhY2tcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpbHRlclN0YWNrRmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlsdGVyX3N0YWNrXzEuRmlsdGVyU3RhY2tGYWN0b3J5OyB9IH0pO1xyXG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdpc3RlckFkbWluU2VydmljZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRtaW5fMS5yZWdpc3RlckFkbWluU2VydmljZTsgfSB9KTtcclxudmFyIHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWludGVyZmFjZVwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZVN1YmNoYW5uZWxXcmFwcGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlcjsgfSB9KTtcclxudmFyIGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb25cIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uXzEuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWc7IH0gfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cGVyaW1lbnRhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter-stack.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.FilterStackFactory = exports.FilterStack = void 0;\r\nclass FilterStack {\r\n    constructor(filters) {\r\n        this.filters = filters;\r\n    }\r\n    sendMetadata(metadata) {\r\n        let result = metadata;\r\n        for (let i = 0; i < this.filters.length; i++) {\r\n            result = this.filters[i].sendMetadata(result);\r\n        }\r\n        return result;\r\n    }\r\n    receiveMetadata(metadata) {\r\n        let result = metadata;\r\n        for (let i = this.filters.length - 1; i >= 0; i--) {\r\n            result = this.filters[i].receiveMetadata(result);\r\n        }\r\n        return result;\r\n    }\r\n    sendMessage(message) {\r\n        let result = message;\r\n        for (let i = 0; i < this.filters.length; i++) {\r\n            result = this.filters[i].sendMessage(result);\r\n        }\r\n        return result;\r\n    }\r\n    receiveMessage(message) {\r\n        let result = message;\r\n        for (let i = this.filters.length - 1; i >= 0; i--) {\r\n            result = this.filters[i].receiveMessage(result);\r\n        }\r\n        return result;\r\n    }\r\n    receiveTrailers(status) {\r\n        let result = status;\r\n        for (let i = this.filters.length - 1; i >= 0; i--) {\r\n            result = this.filters[i].receiveTrailers(result);\r\n        }\r\n        return result;\r\n    }\r\n    push(filters) {\r\n        this.filters.unshift(...filters);\r\n    }\r\n    getFilters() {\r\n        return this.filters;\r\n    }\r\n}\r\nexports.FilterStack = FilterStack;\r\nclass FilterStackFactory {\r\n    constructor(factories) {\r\n        this.factories = factories;\r\n    }\r\n    push(filterFactories) {\r\n        this.factories.unshift(...filterFactories);\r\n    }\r\n    clone() {\r\n        return new FilterStackFactory([...this.factories]);\r\n    }\r\n    createFilter() {\r\n        return new FilterStack(this.factories.map(factory => factory.createFilter()));\r\n    }\r\n}\r\nexports.FilterStackFactory = FilterStackFactory;\r\n//# sourceMappingURL=filter-stack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2ZpbHRlci1zdGFjay5qcz8xOGI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IGV4cG9ydHMuRmlsdGVyU3RhY2sgPSB2b2lkIDA7XHJcbmNsYXNzIEZpbHRlclN0YWNrIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpbHRlcnMpIHtcclxuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xyXG4gICAgfVxyXG4gICAgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5zZW5kTWV0YWRhdGEocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBtZXRhZGF0YTtcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5yZWNlaXZlTWV0YWRhdGEocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbWVzc2FnZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0uc2VuZE1lc3NhZ2UocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbWVzc2FnZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5yZWNlaXZlTWVzc2FnZShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBzdGF0dXM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0ucmVjZWl2ZVRyYWlsZXJzKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBwdXNoKGZpbHRlcnMpIHtcclxuICAgICAgICB0aGlzLmZpbHRlcnMudW5zaGlmdCguLi5maWx0ZXJzKTtcclxuICAgIH1cclxuICAgIGdldEZpbHRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkZpbHRlclN0YWNrID0gRmlsdGVyU3RhY2s7XHJcbmNsYXNzIEZpbHRlclN0YWNrRmFjdG9yeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3JpZXMpIHtcclxuICAgICAgICB0aGlzLmZhY3RvcmllcyA9IGZhY3RvcmllcztcclxuICAgIH1cclxuICAgIHB1c2goZmlsdGVyRmFjdG9yaWVzKSB7XHJcbiAgICAgICAgdGhpcy5mYWN0b3JpZXMudW5zaGlmdCguLi5maWx0ZXJGYWN0b3JpZXMpO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJTdGFja0ZhY3RvcnkoWy4uLnRoaXMuZmFjdG9yaWVzXSk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVGaWx0ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJTdGFjayh0aGlzLmZhY3Rvcmllcy5tYXAoZmFjdG9yeSA9PiBmYWN0b3J5LmNyZWF0ZUZpbHRlcigpKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5GaWx0ZXJTdGFja0ZhY3RvcnkgPSBGaWx0ZXJTdGFja0ZhY3Rvcnk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci1zdGFjay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BaseFilter = void 0;\r\nclass BaseFilter {\r\n    async sendMetadata(metadata) {\r\n        return metadata;\r\n    }\r\n    receiveMetadata(metadata) {\r\n        return metadata;\r\n    }\r\n    async sendMessage(message) {\r\n        return message;\r\n    }\r\n    async receiveMessage(message) {\r\n        return message;\r\n    }\r\n    receiveTrailers(status) {\r\n        return status;\r\n    }\r\n}\r\nexports.BaseFilter = BaseFilter;\r\n//# sourceMappingURL=filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2ZpbHRlci5qcz8zMjhmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkJhc2VGaWx0ZXIgPSB2b2lkIDA7XHJcbmNsYXNzIEJhc2VGaWx0ZXIge1xyXG4gICAgYXN5bmMgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xyXG4gICAgfVxyXG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xyXG4gICAgICAgIHJldHVybiBzdGF0dXM7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5CYXNlRmlsdGVyID0gQmFzZUZpbHRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/filter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/http_proxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getProxiedConnection = exports.mapProxyName = void 0;\r\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst http = __webpack_require__(/*! http */ \"http\");\r\nconst tls = __webpack_require__(/*! tls */ \"tls\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst url_1 = __webpack_require__(/*! url */ \"url\");\r\nconst resolver_dns_1 = __webpack_require__(/*! ./resolver-dns */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\r\nconst TRACER_NAME = 'proxy';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nfunction getProxyInfo() {\r\n    let proxyEnv = '';\r\n    let envVar = '';\r\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\r\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\r\n     * fallback behavior can be removed if there's a demand for it.\r\n     */\r\n    if (process.env.grpc_proxy) {\r\n        envVar = 'grpc_proxy';\r\n        proxyEnv = process.env.grpc_proxy;\r\n    }\r\n    else if (process.env.https_proxy) {\r\n        envVar = 'https_proxy';\r\n        proxyEnv = process.env.https_proxy;\r\n    }\r\n    else if (process.env.http_proxy) {\r\n        envVar = 'http_proxy';\r\n        proxyEnv = process.env.http_proxy;\r\n    }\r\n    else {\r\n        return {};\r\n    }\r\n    let proxyUrl;\r\n    try {\r\n        proxyUrl = new url_1.URL(proxyEnv);\r\n    }\r\n    catch (e) {\r\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\r\n        return {};\r\n    }\r\n    if (proxyUrl.protocol !== 'http:') {\r\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\r\n        return {};\r\n    }\r\n    let userCred = null;\r\n    if (proxyUrl.username) {\r\n        if (proxyUrl.password) {\r\n            (0, logging_1.log)(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\r\n            userCred = `${proxyUrl.username}:${proxyUrl.password}`;\r\n        }\r\n        else {\r\n            userCred = proxyUrl.username;\r\n        }\r\n    }\r\n    const hostname = proxyUrl.hostname;\r\n    let port = proxyUrl.port;\r\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\r\n     * 80. We need to set that explicitly here if it is omitted because otherwise\r\n     * it will use gRPC's default port 443. */\r\n    if (port === '') {\r\n        port = '80';\r\n    }\r\n    const result = {\r\n        address: `${hostname}:${port}`,\r\n    };\r\n    if (userCred) {\r\n        result.creds = userCred;\r\n    }\r\n    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\r\n    return result;\r\n}\r\nfunction getNoProxyHostList() {\r\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\r\n    let noProxyStr = process.env.no_grpc_proxy;\r\n    let envVar = 'no_grpc_proxy';\r\n    if (!noProxyStr) {\r\n        noProxyStr = process.env.no_proxy;\r\n        envVar = 'no_proxy';\r\n    }\r\n    if (noProxyStr) {\r\n        trace('No proxy server list set by environment variable ' + envVar);\r\n        return noProxyStr.split(',');\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\nfunction mapProxyName(target, options) {\r\n    var _a;\r\n    const noProxyResult = {\r\n        target: target,\r\n        extraOptions: {},\r\n    };\r\n    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\r\n        return noProxyResult;\r\n    }\r\n    if (target.scheme === 'unix') {\r\n        return noProxyResult;\r\n    }\r\n    const proxyInfo = getProxyInfo();\r\n    if (!proxyInfo.address) {\r\n        return noProxyResult;\r\n    }\r\n    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\r\n    if (!hostPort) {\r\n        return noProxyResult;\r\n    }\r\n    const serverHost = hostPort.host;\r\n    for (const host of getNoProxyHostList()) {\r\n        if (host === serverHost) {\r\n            trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1.uriToString)(target));\r\n            return noProxyResult;\r\n        }\r\n    }\r\n    const extraOptions = {\r\n        'grpc.http_connect_target': (0, uri_parser_1.uriToString)(target),\r\n    };\r\n    if (proxyInfo.creds) {\r\n        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\r\n    }\r\n    return {\r\n        target: {\r\n            scheme: 'dns',\r\n            path: proxyInfo.address,\r\n        },\r\n        extraOptions: extraOptions,\r\n    };\r\n}\r\nexports.mapProxyName = mapProxyName;\r\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\r\n    var _a;\r\n    if (!('grpc.http_connect_target' in channelOptions)) {\r\n        return Promise.resolve({});\r\n    }\r\n    const realTarget = channelOptions['grpc.http_connect_target'];\r\n    const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);\r\n    if (parsedTarget === null) {\r\n        return Promise.resolve({});\r\n    }\r\n    const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);\r\n    if (splitHostPost === null) {\r\n        return Promise.resolve({});\r\n    }\r\n    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== void 0 ? _a : resolver_dns_1.DEFAULT_PORT}`;\r\n    const options = {\r\n        method: 'CONNECT',\r\n        path: hostPort,\r\n    };\r\n    const headers = {\r\n        Host: hostPort,\r\n    };\r\n    // Connect to the subchannel address as a proxy\r\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\r\n        options.host = address.host;\r\n        options.port = address.port;\r\n    }\r\n    else {\r\n        options.socketPath = address.path;\r\n    }\r\n    if ('grpc.http_connect_creds' in channelOptions) {\r\n        headers['Proxy-Authorization'] =\r\n            'Basic ' +\r\n                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\r\n    }\r\n    options.headers = headers;\r\n    const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);\r\n    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\r\n    return new Promise((resolve, reject) => {\r\n        const request = http.request(options);\r\n        request.once('connect', (res, socket, head) => {\r\n            var _a;\r\n            request.removeAllListeners();\r\n            socket.removeAllListeners();\r\n            if (res.statusCode === 200) {\r\n                trace('Successfully connected to ' +\r\n                    options.path +\r\n                    ' through proxy ' +\r\n                    proxyAddressString);\r\n                if ('secureContext' in connectionOptions) {\r\n                    /* The proxy is connecting to a TLS server, so upgrade this socket\r\n                     * connection to a TLS connection.\r\n                     * This is a workaround for https://github.com/nodejs/node/issues/32922\r\n                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\r\n                    const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);\r\n                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\r\n                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\r\n                    const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket: socket }, connectionOptions), () => {\r\n                        trace('Successfully established a TLS connection to ' +\r\n                            options.path +\r\n                            ' through proxy ' +\r\n                            proxyAddressString);\r\n                        resolve({ socket: cts, realTarget: parsedTarget });\r\n                    });\r\n                    cts.on('error', (error) => {\r\n                        trace('Failed to establish a TLS connection to ' +\r\n                            options.path +\r\n                            ' through proxy ' +\r\n                            proxyAddressString +\r\n                            ' with error ' +\r\n                            error.message);\r\n                        reject();\r\n                    });\r\n                }\r\n                else {\r\n                    trace('Successfully established a plaintext connection to ' +\r\n                        options.path +\r\n                        ' through proxy ' +\r\n                        proxyAddressString);\r\n                    resolve({\r\n                        socket,\r\n                        realTarget: parsedTarget,\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +\r\n                    options.path +\r\n                    ' through proxy ' +\r\n                    proxyAddressString +\r\n                    ' with status ' +\r\n                    res.statusCode);\r\n                reject();\r\n            }\r\n        });\r\n        request.once('error', err => {\r\n            request.removeAllListeners();\r\n            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +\r\n                proxyAddressString +\r\n                ' with error ' +\r\n                err.message);\r\n            reject();\r\n        });\r\n        request.end();\r\n    });\r\n}\r\nexports.getProxiedConnection = getProxiedConnection;\r\n//# sourceMappingURL=http_proxy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaHR0cF9wcm94eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLG9CQUFvQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsdUJBQXVCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLE9BQU87QUFDNUY7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGtCQUFrQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUyxHQUFHLEtBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx3QkFBd0IsbUJBQW1CLEdBQUcsdUZBQXVGO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwREFBMEQ7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUNBQXVDO0FBQ3pFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9odHRwX3Byb3h5LmpzP2FiYjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZ2V0UHJveGllZENvbm5lY3Rpb24gPSBleHBvcnRzLm1hcFByb3h5TmFtZSA9IHZvaWQgMDtcclxuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcclxuY29uc3QgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xyXG5jb25zdCB0bHMgPSByZXF1aXJlKFwidGxzXCIpO1xyXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XHJcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XHJcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcclxuY29uc3QgcmVzb2x2ZXJfZG5zXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlci1kbnNcIik7XHJcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3Byb3h5JztcclxuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xyXG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcclxufVxyXG5mdW5jdGlvbiBnZXRQcm94eUluZm8oKSB7XHJcbiAgICBsZXQgcHJveHlFbnYgPSAnJztcclxuICAgIGxldCBlbnZWYXIgPSAnJztcclxuICAgIC8qIFByZWZlciB1c2luZyAnZ3JwY19wcm94eScuIEZhbGxiYWNrIG9uICdodHRwX3Byb3h5JyBpZiBpdCBpcyBub3Qgc2V0LlxyXG4gICAgICogQWxzbyBwcmVmZXIgdXNpbmcgJ2h0dHBzX3Byb3h5JyB3aXRoIGZhbGxiYWNrIG9uICdodHRwX3Byb3h5Jy4gVGhlXHJcbiAgICAgKiBmYWxsYmFjayBiZWhhdmlvciBjYW4gYmUgcmVtb3ZlZCBpZiB0aGVyZSdzIGEgZGVtYW5kIGZvciBpdC5cclxuICAgICAqL1xyXG4gICAgaWYgKHByb2Nlc3MuZW52LmdycGNfcHJveHkpIHtcclxuICAgICAgICBlbnZWYXIgPSAnZ3JwY19wcm94eSc7XHJcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5ncnBjX3Byb3h5O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkpIHtcclxuICAgICAgICBlbnZWYXIgPSAnaHR0cHNfcHJveHknO1xyXG4gICAgICAgIHByb3h5RW52ID0gcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5odHRwX3Byb3h5KSB7XHJcbiAgICAgICAgZW52VmFyID0gJ2h0dHBfcHJveHknO1xyXG4gICAgICAgIHByb3h5RW52ID0gcHJvY2Vzcy5lbnYuaHR0cF9wcm94eTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIGxldCBwcm94eVVybDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcHJveHlVcmwgPSBuZXcgdXJsXzEuVVJMKHByb3h5RW52KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYGNhbm5vdCBwYXJzZSB2YWx1ZSBvZiBcIiR7ZW52VmFyfVwiIGVudiB2YXJgKTtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICBpZiAocHJveHlVcmwucHJvdG9jb2wgIT09ICdodHRwOicpIHtcclxuICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBgXCIke3Byb3h5VXJsLnByb3RvY29sfVwiIHNjaGVtZSBub3Qgc3VwcG9ydGVkIGluIHByb3h5IFVSSWApO1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIGxldCB1c2VyQ3JlZCA9IG51bGw7XHJcbiAgICBpZiAocHJveHlVcmwudXNlcm5hbWUpIHtcclxuICAgICAgICBpZiAocHJveHlVcmwucGFzc3dvcmQpIHtcclxuICAgICAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPLCAndXNlcmluZm8gZm91bmQgaW4gcHJveHkgVVJJJyk7XHJcbiAgICAgICAgICAgIHVzZXJDcmVkID0gYCR7cHJveHlVcmwudXNlcm5hbWV9OiR7cHJveHlVcmwucGFzc3dvcmR9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVzZXJDcmVkID0gcHJveHlVcmwudXNlcm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgaG9zdG5hbWUgPSBwcm94eVVybC5ob3N0bmFtZTtcclxuICAgIGxldCBwb3J0ID0gcHJveHlVcmwucG9ydDtcclxuICAgIC8qIFRoZSBwcm94eSBVUkwgdXNlcyB0aGUgc2NoZW1lIFwiaHR0cDpcIiwgd2hpY2ggaGFzIGEgZGVmYXVsdCBwb3J0IG51bWJlciBvZlxyXG4gICAgICogODAuIFdlIG5lZWQgdG8gc2V0IHRoYXQgZXhwbGljaXRseSBoZXJlIGlmIGl0IGlzIG9taXR0ZWQgYmVjYXVzZSBvdGhlcndpc2VcclxuICAgICAqIGl0IHdpbGwgdXNlIGdSUEMncyBkZWZhdWx0IHBvcnQgNDQzLiAqL1xyXG4gICAgaWYgKHBvcnQgPT09ICcnKSB7XHJcbiAgICAgICAgcG9ydCA9ICc4MCc7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgICAgYWRkcmVzczogYCR7aG9zdG5hbWV9OiR7cG9ydH1gLFxyXG4gICAgfTtcclxuICAgIGlmICh1c2VyQ3JlZCkge1xyXG4gICAgICAgIHJlc3VsdC5jcmVkcyA9IHVzZXJDcmVkO1xyXG4gICAgfVxyXG4gICAgdHJhY2UoJ1Byb3h5IHNlcnZlciAnICsgcmVzdWx0LmFkZHJlc3MgKyAnIHNldCBieSBlbnZpcm9ubWVudCB2YXJpYWJsZSAnICsgZW52VmFyKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Tm9Qcm94eUhvc3RMaXN0KCkge1xyXG4gICAgLyogUHJlZmVyIHVzaW5nICdub19ncnBjX3Byb3h5Jy4gRmFsbGJhY2sgb24gJ25vX3Byb3h5JyBpZiBpdCBpcyBub3Qgc2V0LiAqL1xyXG4gICAgbGV0IG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19ncnBjX3Byb3h5O1xyXG4gICAgbGV0IGVudlZhciA9ICdub19ncnBjX3Byb3h5JztcclxuICAgIGlmICghbm9Qcm94eVN0cikge1xyXG4gICAgICAgIG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19wcm94eTtcclxuICAgICAgICBlbnZWYXIgPSAnbm9fcHJveHknO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vUHJveHlTdHIpIHtcclxuICAgICAgICB0cmFjZSgnTm8gcHJveHkgc2VydmVyIGxpc3Qgc2V0IGJ5IGVudmlyb25tZW50IHZhcmlhYmxlICcgKyBlbnZWYXIpO1xyXG4gICAgICAgIHJldHVybiBub1Byb3h5U3RyLnNwbGl0KCcsJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWFwUHJveHlOYW1lKHRhcmdldCwgb3B0aW9ucykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3Qgbm9Qcm94eVJlc3VsdCA9IHtcclxuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcclxuICAgICAgICBleHRyYU9wdGlvbnM6IHt9LFxyXG4gICAgfTtcclxuICAgIGlmICgoKF9hID0gb3B0aW9uc1snZ3JwYy5lbmFibGVfaHR0cF9wcm94eSddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC5zY2hlbWUgPT09ICd1bml4Jykge1xyXG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJveHlJbmZvID0gZ2V0UHJveHlJbmZvKCk7XHJcbiAgICBpZiAoIXByb3h5SW5mby5hZGRyZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0LnBhdGgpO1xyXG4gICAgaWYgKCFob3N0UG9ydCkge1xyXG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VydmVySG9zdCA9IGhvc3RQb3J0Lmhvc3Q7XHJcbiAgICBmb3IgKGNvbnN0IGhvc3Qgb2YgZ2V0Tm9Qcm94eUhvc3RMaXN0KCkpIHtcclxuICAgICAgICBpZiAoaG9zdCA9PT0gc2VydmVySG9zdCkge1xyXG4gICAgICAgICAgICB0cmFjZSgnTm90IHVzaW5nIHByb3h5IGZvciB0YXJnZXQgaW4gbm9fcHJveHkgbGlzdDogJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBleHRyYU9wdGlvbnMgPSB7XHJcbiAgICAgICAgJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCc6ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCksXHJcbiAgICB9O1xyXG4gICAgaWYgKHByb3h5SW5mby5jcmVkcykge1xyXG4gICAgICAgIGV4dHJhT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfY3JlZHMnXSA9IHByb3h5SW5mby5jcmVkcztcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdGFyZ2V0OiB7XHJcbiAgICAgICAgICAgIHNjaGVtZTogJ2RucycsXHJcbiAgICAgICAgICAgIHBhdGg6IHByb3h5SW5mby5hZGRyZXNzLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXh0cmFPcHRpb25zOiBleHRyYU9wdGlvbnMsXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMubWFwUHJveHlOYW1lID0gbWFwUHJveHlOYW1lO1xyXG5mdW5jdGlvbiBnZXRQcm94aWVkQ29ubmVjdGlvbihhZGRyZXNzLCBjaGFubmVsT3B0aW9ucywgY29ubmVjdGlvbk9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmICghKCdncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnIGluIGNoYW5uZWxPcHRpb25zKSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVhbFRhcmdldCA9IGNoYW5uZWxPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnXTtcclxuICAgIGNvbnN0IHBhcnNlZFRhcmdldCA9ICgwLCB1cmlfcGFyc2VyXzEucGFyc2VVcmkpKHJlYWxUYXJnZXQpO1xyXG4gICAgaWYgKHBhcnNlZFRhcmdldCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3BsaXRIb3N0UG9zdCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkocGFyc2VkVGFyZ2V0LnBhdGgpO1xyXG4gICAgaWYgKHNwbGl0SG9zdFBvc3QgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGhvc3RQb3J0ID0gYCR7c3BsaXRIb3N0UG9zdC5ob3N0fTokeyhfYSA9IHNwbGl0SG9zdFBvc3QucG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVzb2x2ZXJfZG5zXzEuREVGQVVMVF9QT1JUfWA7XHJcbiAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgIG1ldGhvZDogJ0NPTk5FQ1QnLFxyXG4gICAgICAgIHBhdGg6IGhvc3RQb3J0LFxyXG4gICAgfTtcclxuICAgIGNvbnN0IGhlYWRlcnMgPSB7XHJcbiAgICAgICAgSG9zdDogaG9zdFBvcnQsXHJcbiAgICB9O1xyXG4gICAgLy8gQ29ubmVjdCB0byB0aGUgc3ViY2hhbm5lbCBhZGRyZXNzIGFzIGEgcHJveHlcclxuICAgIGlmICgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcykoYWRkcmVzcykpIHtcclxuICAgICAgICBvcHRpb25zLmhvc3QgPSBhZGRyZXNzLmhvc3Q7XHJcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gYWRkcmVzcy5wb3J0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gYWRkcmVzcy5wYXRoO1xyXG4gICAgfVxyXG4gICAgaWYgKCdncnBjLmh0dHBfY29ubmVjdF9jcmVkcycgaW4gY2hhbm5lbE9wdGlvbnMpIHtcclxuICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPVxyXG4gICAgICAgICAgICAnQmFzaWMgJyArXHJcbiAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShjaGFubmVsT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfY3JlZHMnXSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG4gICAgfVxyXG4gICAgb3B0aW9ucy5oZWFkZXJzID0gaGVhZGVycztcclxuICAgIGNvbnN0IHByb3h5QWRkcmVzc1N0cmluZyA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKTtcclxuICAgIHRyYWNlKCdVc2luZyBwcm94eSAnICsgcHJveHlBZGRyZXNzU3RyaW5nICsgJyB0byBjb25uZWN0IHRvICcgKyBvcHRpb25zLnBhdGgpO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KG9wdGlvbnMpO1xyXG4gICAgICAgIHJlcXVlc3Qub25jZSgnY29ubmVjdCcsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDApIHtcclxuICAgICAgICAgICAgICAgIHRyYWNlKCdTdWNjZXNzZnVsbHkgY29ubmVjdGVkIHRvICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoJ3NlY3VyZUNvbnRleHQnIGluIGNvbm5lY3Rpb25PcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogVGhlIHByb3h5IGlzIGNvbm5lY3RpbmcgdG8gYSBUTFMgc2VydmVyLCBzbyB1cGdyYWRlIHRoaXMgc29ja2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICogY29ubmVjdGlvbiB0byBhIFRMUyBjb25uZWN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzMyOTIyXHJcbiAgICAgICAgICAgICAgICAgICAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMtbm9kZS9wdWxsLzEzNjkgZm9yIG1vcmUgaW5mby4gKi9cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkocGFyc2VkVGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0UGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlSG9zdCA9IChfYSA9IGhvc3RQb3J0ID09PSBudWxsIHx8IGhvc3RQb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3N0UG9ydC5ob3N0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0YXJnZXRQYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0cyA9IHRscy5jb25uZWN0KE9iamVjdC5hc3NpZ24oeyBob3N0OiByZW1vdGVIb3N0LCBzZXJ2ZXJuYW1lOiByZW1vdGVIb3N0LCBzb2NrZXQ6IHNvY2tldCB9LCBjb25uZWN0aW9uT3B0aW9ucyksICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCBhIFRMUyBjb25uZWN0aW9uIHRvICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBzb2NrZXQ6IGN0cywgcmVhbFRhcmdldDogcGFyc2VkVGFyZ2V0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0cy5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ0ZhaWxlZCB0byBlc3RhYmxpc2ggYSBUTFMgY29ubmVjdGlvbiB0byAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHRocm91Z2ggcHJveHkgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCBhIHBsYWludGV4dCBjb25uZWN0aW9uIHRvICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnIHRocm91Z2ggcHJveHkgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhbFRhcmdldDogcGFyc2VkVGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgJ0ZhaWxlZCB0byBjb25uZWN0IHRvICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyB3aXRoIHN0YXR1cyAnICtcclxuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzQ29kZSk7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlcXVlc3Qub25jZSgnZXJyb3InLCBlcnIgPT4ge1xyXG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRmFpbGVkIHRvIGNvbm5lY3QgdG8gcHJveHkgJyArXHJcbiAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcgK1xyXG4gICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xyXG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXF1ZXN0LmVuZCgpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5nZXRQcm94aWVkQ29ubmVjdGlvbiA9IGdldFByb3hpZWRDb25uZWN0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwX3Byb3h5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.experimental = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;\r\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\r\nObject.defineProperty(exports, \"CallCredentials\", ({ enumerable: true, get: function () { return call_credentials_1.CallCredentials; } }));\r\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\r\nObject.defineProperty(exports, \"Channel\", ({ enumerable: true, get: function () { return channel_1.ChannelImplementation; } }));\r\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\r\nObject.defineProperty(exports, \"compressionAlgorithms\", ({ enumerable: true, get: function () { return compression_algorithms_1.CompressionAlgorithms; } }));\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nObject.defineProperty(exports, \"connectivityState\", ({ enumerable: true, get: function () { return connectivity_state_1.ConnectivityState; } }));\r\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\r\nObject.defineProperty(exports, \"ChannelCredentials\", ({ enumerable: true, get: function () { return channel_credentials_1.ChannelCredentials; } }));\r\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js\");\r\nObject.defineProperty(exports, \"Client\", ({ enumerable: true, get: function () { return client_1.Client; } }));\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nObject.defineProperty(exports, \"logVerbosity\", ({ enumerable: true, get: function () { return constants_1.LogVerbosity; } }));\r\nObject.defineProperty(exports, \"status\", ({ enumerable: true, get: function () { return constants_1.Status; } }));\r\nObject.defineProperty(exports, \"propagate\", ({ enumerable: true, get: function () { return constants_1.Propagate; } }));\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\r\nObject.defineProperty(exports, \"loadPackageDefinition\", ({ enumerable: true, get: function () { return make_client_1.loadPackageDefinition; } }));\r\nObject.defineProperty(exports, \"makeClientConstructor\", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));\r\nObject.defineProperty(exports, \"makeGenericClientConstructor\", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nObject.defineProperty(exports, \"Metadata\", ({ enumerable: true, get: function () { return metadata_1.Metadata; } }));\r\nconst server_1 = __webpack_require__(/*! ./server */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server.js\");\r\nObject.defineProperty(exports, \"Server\", ({ enumerable: true, get: function () { return server_1.Server; } }));\r\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\r\nObject.defineProperty(exports, \"ServerCredentials\", ({ enumerable: true, get: function () { return server_credentials_1.ServerCredentials; } }));\r\nconst status_builder_1 = __webpack_require__(/*! ./status-builder */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\");\r\nObject.defineProperty(exports, \"StatusBuilder\", ({ enumerable: true, get: function () { return status_builder_1.StatusBuilder; } }));\r\n/**** Client Credentials ****/\r\n// Using assign only copies enumerable properties, which is what we want\r\nexports.credentials = {\r\n    /**\r\n     * Combine a ChannelCredentials with any number of CallCredentials into a\r\n     * single ChannelCredentials object.\r\n     * @param channelCredentials The ChannelCredentials object.\r\n     * @param callCredentials Any number of CallCredentials objects.\r\n     * @return The resulting ChannelCredentials object.\r\n     */\r\n    combineChannelCredentials: (channelCredentials, ...callCredentials) => {\r\n        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);\r\n    },\r\n    /**\r\n     * Combine any number of CallCredentials into a single CallCredentials\r\n     * object.\r\n     * @param first The first CallCredentials object.\r\n     * @param additional Any number of additional CallCredentials objects.\r\n     * @return The resulting CallCredentials object.\r\n     */\r\n    combineCallCredentials: (first, ...additional) => {\r\n        return additional.reduce((acc, other) => acc.compose(other), first);\r\n    },\r\n    // from channel-credentials.ts\r\n    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,\r\n    createSsl: channel_credentials_1.ChannelCredentials.createSsl,\r\n    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,\r\n    // from call-credentials.ts\r\n    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,\r\n    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,\r\n    createEmpty: call_credentials_1.CallCredentials.createEmpty,\r\n};\r\n/**\r\n * Close a Client object.\r\n * @param client The client to close.\r\n */\r\nconst closeClient = (client) => client.close();\r\nexports.closeClient = closeClient;\r\nconst waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);\r\nexports.waitForClientReady = waitForClientReady;\r\n/* eslint-enable @typescript-eslint/no-explicit-any */\r\n/**** Unimplemented function stubs ****/\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nconst loadObject = (value, options) => {\r\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\r\n};\r\nexports.loadObject = loadObject;\r\nconst load = (filename, format, options) => {\r\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\r\n};\r\nexports.load = load;\r\nconst setLogger = (logger) => {\r\n    logging.setLogger(logger);\r\n};\r\nexports.setLogger = setLogger;\r\nconst setLogVerbosity = (verbosity) => {\r\n    logging.setLoggerVerbosity(verbosity);\r\n};\r\nexports.setLogVerbosity = setLogVerbosity;\r\nconst getClientChannel = (client) => {\r\n    return client_1.Client.prototype.getChannel.call(client);\r\n};\r\nexports.getClientChannel = getClientChannel;\r\nvar client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\r\nObject.defineProperty(exports, \"ListenerBuilder\", ({ enumerable: true, get: function () { return client_interceptors_1.ListenerBuilder; } }));\r\nObject.defineProperty(exports, \"RequesterBuilder\", ({ enumerable: true, get: function () { return client_interceptors_1.RequesterBuilder; } }));\r\nObject.defineProperty(exports, \"InterceptingCall\", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptingCall; } }));\r\nObject.defineProperty(exports, \"InterceptorConfigurationError\", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptorConfigurationError; } }));\r\nvar channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\r\nObject.defineProperty(exports, \"getChannelzServiceDefinition\", ({ enumerable: true, get: function () { return channelz_1.getChannelzServiceDefinition; } }));\r\nObject.defineProperty(exports, \"getChannelzHandlers\", ({ enumerable: true, get: function () { return channelz_1.getChannelzHandlers; } }));\r\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\r\nObject.defineProperty(exports, \"addAdminServicesToServer\", ({ enumerable: true, get: function () { return admin_1.addAdminServicesToServer; } }));\r\nconst experimental = __webpack_require__(/*! ./experimental */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\r\nexports.experimental = experimental;\r\nconst resolver_dns = __webpack_require__(/*! ./resolver-dns */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\r\nconst resolver_uds = __webpack_require__(/*! ./resolver-uds */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\");\r\nconst resolver_ip = __webpack_require__(/*! ./resolver-ip */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\");\r\nconst load_balancer_pick_first = __webpack_require__(/*! ./load-balancer-pick-first */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\r\nconst load_balancer_round_robin = __webpack_require__(/*! ./load-balancer-round-robin */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\");\r\nconst load_balancer_outlier_detection = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\r\nconst channelz = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\r\n(() => {\r\n    resolver_dns.setup();\r\n    resolver_uds.setup();\r\n    resolver_ip.setup();\r\n    load_balancer_pick_first.setup();\r\n    load_balancer_round_robin.setup();\r\n    load_balancer_outlier_detection.setup();\r\n    channelz.setup();\r\n})();\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkIsR0FBRyxvQ0FBb0MsR0FBRyxxQ0FBcUMsR0FBRyx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyxjQUFjLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLGtCQUFrQixHQUFHLHVCQUF1QixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxvQ0FBb0MsR0FBRyw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRyxjQUFjLEdBQUcsNkJBQTZCLEdBQUcsaUJBQWlCLEdBQUcseUJBQXlCLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQjtBQUMzekIsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZELG1EQUFrRCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUN4SSxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBVztBQUNyQywyQ0FBMEMsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDN0gsaUNBQWlDLG1CQUFPLENBQUMsd0dBQTBCO0FBQ25FLHlEQUF3RCxFQUFFLHFDQUFxQywwREFBMEQsRUFBQztBQUMxSiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QscURBQW9ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzlJLDhCQUE4QixtQkFBTyxDQUFDLGtHQUF1QjtBQUM3RCxzREFBcUQsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDakosaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCwwQ0FBeUMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDL0csNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDLHlEQUF3RCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUMvSSx5REFBd0QsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDL0ksZ0VBQStELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQ3RKLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELHFEQUFvRCxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUM5SSx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsaURBQWdELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ2xJO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsNEJBQTRCLG1CQUFPLENBQUMsa0dBQXVCO0FBQzNELG1EQUFrRCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUMzSSxvREFBbUQsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDN0ksb0RBQW1ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzdJLGlFQUFnRSxFQUFFLHFDQUFxQywrREFBK0QsRUFBQztBQUN2SyxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUNyQyxnRUFBK0QsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDMUosdURBQXNELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ3hJLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUztBQUMvQiw0REFBMkQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDL0kscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQzdDLG9CQUFvQjtBQUNwQixxQkFBcUIsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQzdDLG9CQUFvQixtQkFBTyxDQUFDLGtGQUFlO0FBQzNDLGlDQUFpQyxtQkFBTyxDQUFDLDRHQUE0QjtBQUNyRSxrQ0FBa0MsbUJBQU8sQ0FBQyw4R0FBNkI7QUFDdkUsd0NBQXdDLG1CQUFPLENBQUMsMEhBQW1DO0FBQ25GLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2luZGV4LmpzP2Y1ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZXhwZXJpbWVudGFsID0gZXhwb3J0cy5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIgPSBleHBvcnRzLmdldENoYW5uZWx6SGFuZGxlcnMgPSBleHBvcnRzLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24gPSBleHBvcnRzLkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yID0gZXhwb3J0cy5JbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5SZXF1ZXN0ZXJCdWlsZGVyID0gZXhwb3J0cy5MaXN0ZW5lckJ1aWxkZXIgPSBleHBvcnRzLlN0YXR1c0J1aWxkZXIgPSBleHBvcnRzLmdldENsaWVudENoYW5uZWwgPSBleHBvcnRzLlNlcnZlckNyZWRlbnRpYWxzID0gZXhwb3J0cy5TZXJ2ZXIgPSBleHBvcnRzLnNldExvZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuc2V0TG9nZ2VyID0gZXhwb3J0cy5sb2FkID0gZXhwb3J0cy5sb2FkT2JqZWN0ID0gZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHMgPSBleHBvcnRzLkNoYW5uZWxDcmVkZW50aWFscyA9IGV4cG9ydHMud2FpdEZvckNsaWVudFJlYWR5ID0gZXhwb3J0cy5jbG9zZUNsaWVudCA9IGV4cG9ydHMuQ2hhbm5lbCA9IGV4cG9ydHMubWFrZUdlbmVyaWNDbGllbnRDb25zdHJ1Y3RvciA9IGV4cG9ydHMubWFrZUNsaWVudENvbnN0cnVjdG9yID0gZXhwb3J0cy5sb2FkUGFja2FnZURlZmluaXRpb24gPSBleHBvcnRzLkNsaWVudCA9IGV4cG9ydHMuY29tcHJlc3Npb25BbGdvcml0aG1zID0gZXhwb3J0cy5wcm9wYWdhdGUgPSBleHBvcnRzLmNvbm5lY3Rpdml0eVN0YXRlID0gZXhwb3J0cy5zdGF0dXMgPSBleHBvcnRzLmxvZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuTWV0YWRhdGEgPSBleHBvcnRzLmNyZWRlbnRpYWxzID0gdm9pZCAwO1xyXG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsQ3JlZGVudGlhbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHM7IH0gfSk7XHJcbmNvbnN0IGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoYW5uZWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYW5uZWxfMS5DaGFubmVsSW1wbGVtZW50YXRpb247IH0gfSk7XHJcbmNvbnN0IGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWFsZ29yaXRobXNcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXByZXNzaW9uQWxnb3JpdGhtc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcHJlc3Npb25fYWxnb3JpdGhtc18xLkNvbXByZXNzaW9uQWxnb3JpdGhtczsgfSB9KTtcclxuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbm5lY3Rpdml0eVN0YXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZTsgfSB9KTtcclxuY29uc3QgY2hhbm5lbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1jcmVkZW50aWFsc1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hhbm5lbENyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzOyB9IH0pO1xyXG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfMS5DbGllbnQ7IH0gfSk7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2dWZXJib3NpdHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eTsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RhdHVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5TdGF0dXM7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByb3BhZ2F0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuUHJvcGFnYXRlOyB9IH0pO1xyXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3QgbWFrZV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL21ha2UtY2xpZW50XCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2FkUGFja2FnZURlZmluaXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubG9hZFBhY2thZ2VEZWZpbml0aW9uOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlQ2xpZW50Q29uc3RydWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubWFrZUNsaWVudENvbnN0cnVjdG9yOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlR2VuZXJpY0NsaWVudENvbnN0cnVjdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYWtlX2NsaWVudF8xLm1ha2VDbGllbnRDb25zdHJ1Y3RvcjsgfSB9KTtcclxuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXRhZGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWV0YWRhdGFfMS5NZXRhZGF0YTsgfSB9KTtcclxuY29uc3Qgc2VydmVyXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXJcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyXzEuU2VydmVyOyB9IH0pO1xyXG5jb25zdCBzZXJ2ZXJfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jcmVkZW50aWFsc1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyQ3JlZGVudGlhbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZlcl9jcmVkZW50aWFsc18xLlNlcnZlckNyZWRlbnRpYWxzOyB9IH0pO1xyXG5jb25zdCBzdGF0dXNfYnVpbGRlcl8xID0gcmVxdWlyZShcIi4vc3RhdHVzLWJ1aWxkZXJcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0YXR1c0J1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXR1c19idWlsZGVyXzEuU3RhdHVzQnVpbGRlcjsgfSB9KTtcclxuLyoqKiogQ2xpZW50IENyZWRlbnRpYWxzICoqKiovXHJcbi8vIFVzaW5nIGFzc2lnbiBvbmx5IGNvcGllcyBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIHdoaWNoIGlzIHdoYXQgd2Ugd2FudFxyXG5leHBvcnRzLmNyZWRlbnRpYWxzID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21iaW5lIGEgQ2hhbm5lbENyZWRlbnRpYWxzIHdpdGggYW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgaW50byBhXHJcbiAgICAgKiBzaW5nbGUgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBjaGFubmVsQ3JlZGVudGlhbHMgVGhlIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gY2FsbENyZWRlbnRpYWxzIEFueSBudW1iZXIgb2YgQ2FsbENyZWRlbnRpYWxzIG9iamVjdHMuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgY29tYmluZUNoYW5uZWxDcmVkZW50aWFsczogKGNoYW5uZWxDcmVkZW50aWFscywgLi4uY2FsbENyZWRlbnRpYWxzKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxDcmVkZW50aWFscy5yZWR1Y2UoKGFjYywgb3RoZXIpID0+IGFjYy5jb21wb3NlKG90aGVyKSwgY2hhbm5lbENyZWRlbnRpYWxzKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmUgYW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgaW50byBhIHNpbmdsZSBDYWxsQ3JlZGVudGlhbHNcclxuICAgICAqIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgQ2FsbENyZWRlbnRpYWxzIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsIEFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0cy5cclxuICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBjb21iaW5lQ2FsbENyZWRlbnRpYWxzOiAoZmlyc3QsIC4uLmFkZGl0aW9uYWwpID0+IHtcclxuICAgICAgICByZXR1cm4gYWRkaXRpb25hbC5yZWR1Y2UoKGFjYywgb3RoZXIpID0+IGFjYy5jb21wb3NlKG90aGVyKSwgZmlyc3QpO1xyXG4gICAgfSxcclxuICAgIC8vIGZyb20gY2hhbm5lbC1jcmVkZW50aWFscy50c1xyXG4gICAgY3JlYXRlSW5zZWN1cmU6IGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlSW5zZWN1cmUsXHJcbiAgICBjcmVhdGVTc2w6IGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlU3NsLFxyXG4gICAgY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQ6IGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQsXHJcbiAgICAvLyBmcm9tIGNhbGwtY3JlZGVudGlhbHMudHNcclxuICAgIGNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcjogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IsXHJcbiAgICBjcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbDogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbCxcclxuICAgIGNyZWF0ZUVtcHR5OiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUVtcHR5LFxyXG59O1xyXG4vKipcclxuICogQ2xvc2UgYSBDbGllbnQgb2JqZWN0LlxyXG4gKiBAcGFyYW0gY2xpZW50IFRoZSBjbGllbnQgdG8gY2xvc2UuXHJcbiAqL1xyXG5jb25zdCBjbG9zZUNsaWVudCA9IChjbGllbnQpID0+IGNsaWVudC5jbG9zZSgpO1xyXG5leHBvcnRzLmNsb3NlQ2xpZW50ID0gY2xvc2VDbGllbnQ7XHJcbmNvbnN0IHdhaXRGb3JDbGllbnRSZWFkeSA9IChjbGllbnQsIGRlYWRsaW5lLCBjYWxsYmFjaykgPT4gY2xpZW50LndhaXRGb3JSZWFkeShkZWFkbGluZSwgY2FsbGJhY2spO1xyXG5leHBvcnRzLndhaXRGb3JDbGllbnRSZWFkeSA9IHdhaXRGb3JDbGllbnRSZWFkeTtcclxuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXHJcbi8qKioqIFVuaW1wbGVtZW50ZWQgZnVuY3Rpb24gc3R1YnMgKioqKi9cclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xyXG5jb25zdCBsb2FkT2JqZWN0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdmFpbGFibGUgaW4gdGhpcyBsaWJyYXJ5LiBVc2UgQGdycGMvcHJvdG8tbG9hZGVyIGFuZCBsb2FkUGFja2FnZURlZmluaXRpb24gaW5zdGVhZCcpO1xyXG59O1xyXG5leHBvcnRzLmxvYWRPYmplY3QgPSBsb2FkT2JqZWN0O1xyXG5jb25zdCBsb2FkID0gKGZpbGVuYW1lLCBmb3JtYXQsIG9wdGlvbnMpID0+IHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm90IGF2YWlsYWJsZSBpbiB0aGlzIGxpYnJhcnkuIFVzZSBAZ3JwYy9wcm90by1sb2FkZXIgYW5kIGxvYWRQYWNrYWdlRGVmaW5pdGlvbiBpbnN0ZWFkJyk7XHJcbn07XHJcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XHJcbmNvbnN0IHNldExvZ2dlciA9IChsb2dnZXIpID0+IHtcclxuICAgIGxvZ2dpbmcuc2V0TG9nZ2VyKGxvZ2dlcik7XHJcbn07XHJcbmV4cG9ydHMuc2V0TG9nZ2VyID0gc2V0TG9nZ2VyO1xyXG5jb25zdCBzZXRMb2dWZXJib3NpdHkgPSAodmVyYm9zaXR5KSA9PiB7XHJcbiAgICBsb2dnaW5nLnNldExvZ2dlclZlcmJvc2l0eSh2ZXJib3NpdHkpO1xyXG59O1xyXG5leHBvcnRzLnNldExvZ1ZlcmJvc2l0eSA9IHNldExvZ1ZlcmJvc2l0eTtcclxuY29uc3QgZ2V0Q2xpZW50Q2hhbm5lbCA9IChjbGllbnQpID0+IHtcclxuICAgIHJldHVybiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLmdldENoYW5uZWwuY2FsbChjbGllbnQpO1xyXG59O1xyXG5leHBvcnRzLmdldENsaWVudENoYW5uZWwgPSBnZXRDbGllbnRDaGFubmVsO1xyXG52YXIgY2xpZW50X2ludGVyY2VwdG9yc18xID0gcmVxdWlyZShcIi4vY2xpZW50LWludGVyY2VwdG9yc1wiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlzdGVuZXJCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuTGlzdGVuZXJCdWlsZGVyOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0ZXJCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuUmVxdWVzdGVyQnVpbGRlcjsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJjZXB0aW5nQ2FsbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50X2ludGVyY2VwdG9yc18xLkludGVyY2VwdGluZ0NhbGw7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3I7IH0gfSk7XHJcbnZhciBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldENoYW5uZWx6U2VydmljZURlZmluaXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYW5uZWx6XzEuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbjsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Q2hhbm5lbHpIYW5kbGVyc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbHpfMS5nZXRDaGFubmVsekhhbmRsZXJzOyB9IH0pO1xyXG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkbWluXzEuYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyOyB9IH0pO1xyXG5jb25zdCBleHBlcmltZW50YWwgPSByZXF1aXJlKFwiLi9leHBlcmltZW50YWxcIik7XHJcbmV4cG9ydHMuZXhwZXJpbWVudGFsID0gZXhwZXJpbWVudGFsO1xyXG5jb25zdCByZXNvbHZlcl9kbnMgPSByZXF1aXJlKFwiLi9yZXNvbHZlci1kbnNcIik7XHJcbmNvbnN0IHJlc29sdmVyX3VkcyA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyLXVkc1wiKTtcclxuY29uc3QgcmVzb2x2ZXJfaXAgPSByZXF1aXJlKFwiLi9yZXNvbHZlci1pcFwiKTtcclxuY29uc3QgbG9hZF9iYWxhbmNlcl9waWNrX2ZpcnN0ID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0XCIpO1xyXG5jb25zdCBsb2FkX2JhbGFuY2VyX3JvdW5kX3JvYmluID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1yb3VuZC1yb2JpblwiKTtcclxuY29uc3QgbG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbiA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb25cIik7XHJcbmNvbnN0IGNoYW5uZWx6ID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XHJcbigoKSA9PiB7XHJcbiAgICByZXNvbHZlcl9kbnMuc2V0dXAoKTtcclxuICAgIHJlc29sdmVyX3Vkcy5zZXR1cCgpO1xyXG4gICAgcmVzb2x2ZXJfaXAuc2V0dXAoKTtcclxuICAgIGxvYWRfYmFsYW5jZXJfcGlja19maXJzdC5zZXR1cCgpO1xyXG4gICAgbG9hZF9iYWxhbmNlcl9yb3VuZF9yb2Jpbi5zZXR1cCgpO1xyXG4gICAgbG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbi5zZXR1cCgpO1xyXG4gICAgY2hhbm5lbHouc2V0dXAoKTtcclxufSkoKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/internal-channel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.InternalChannel = void 0;\r\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\r\nconst resolving_load_balancer_1 = __webpack_require__(/*! ./resolving-load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\");\r\nconst subchannel_pool_1 = __webpack_require__(/*! ./subchannel-pool */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\");\r\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\r\nconst compression_filter_1 = __webpack_require__(/*! ./compression-filter */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\");\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\r\nconst load_balancing_call_1 = __webpack_require__(/*! ./load-balancing-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\");\r\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\r\nconst resolving_call_1 = __webpack_require__(/*! ./resolving-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\");\r\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\r\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\r\nconst retrying_call_1 = __webpack_require__(/*! ./retrying-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\");\r\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\r\n/**\r\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\r\n */\r\nconst MAX_TIMEOUT_TIME = 2147483647;\r\nconst MIN_IDLE_TIMEOUT_MS = 1000;\r\n// 30 minutes\r\nconst DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;\r\nconst RETRY_THROTTLER_MAP = new Map();\r\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB\r\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB\r\nclass ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\r\n    constructor(childSubchannel, channel) {\r\n        super(childSubchannel);\r\n        this.channel = channel;\r\n        this.refCount = 0;\r\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {\r\n            channel.throttleKeepalive(keepaliveTime);\r\n        };\r\n        childSubchannel.addConnectivityStateListener(this.subchannelStateListener);\r\n    }\r\n    ref() {\r\n        this.child.ref();\r\n        this.refCount += 1;\r\n    }\r\n    unref() {\r\n        this.child.unref();\r\n        this.refCount -= 1;\r\n        if (this.refCount <= 0) {\r\n            this.child.removeConnectivityStateListener(this.subchannelStateListener);\r\n            this.channel.removeWrappedSubchannel(this);\r\n        }\r\n    }\r\n}\r\nclass InternalChannel {\r\n    constructor(target, credentials, options) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h;\r\n        this.credentials = credentials;\r\n        this.options = options;\r\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\r\n        this.currentPicker = new picker_1.UnavailablePicker();\r\n        /**\r\n         * Calls queued up to get a call config. Should only be populated before the\r\n         * first time the resolver returns a result, which includes the ConfigSelector.\r\n         */\r\n        this.configSelectionQueue = [];\r\n        this.pickQueue = [];\r\n        this.connectivityStateWatchers = [];\r\n        this.configSelector = null;\r\n        /**\r\n         * This is the error from the name resolver if it failed most recently. It\r\n         * is only used to end calls that start while there is no config selector\r\n         * and the name resolver is in backoff, so it should be nulled if\r\n         * configSelector becomes set or the channel state becomes anything other\r\n         * than TRANSIENT_FAILURE.\r\n         */\r\n        this.currentResolutionError = null;\r\n        this.wrappedSubchannels = new Set();\r\n        this.callCount = 0;\r\n        this.idleTimer = null;\r\n        // Channelz info\r\n        this.channelzEnabled = true;\r\n        this.callTracker = new channelz_1.ChannelzCallTracker();\r\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\r\n        if (typeof target !== 'string') {\r\n            throw new TypeError('Channel target must be a string');\r\n        }\r\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\r\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\r\n        }\r\n        if (options) {\r\n            if (typeof options !== 'object') {\r\n                throw new TypeError('Channel options must be an object');\r\n            }\r\n        }\r\n        this.originalTarget = target;\r\n        const originalTargetUri = (0, uri_parser_1.parseUri)(target);\r\n        if (originalTargetUri === null) {\r\n            throw new Error(`Could not parse target name \"${target}\"`);\r\n        }\r\n        /* This ensures that the target has a scheme that is registered with the\r\n         * resolver */\r\n        const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);\r\n        if (defaultSchemeMapResult === null) {\r\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\r\n        }\r\n        this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);\r\n        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        if (this.options['grpc.enable_channelz'] === 0) {\r\n            this.channelzEnabled = false;\r\n        }\r\n        this.channelzTrace = new channelz_1.ChannelzTrace();\r\n        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, () => this.getChannelzInfo(), this.channelzEnabled);\r\n        if (this.channelzEnabled) {\r\n            this.channelzTrace.addTrace('CT_INFO', 'Channel created');\r\n        }\r\n        if (this.options['grpc.default_authority']) {\r\n            this.defaultAuthority = this.options['grpc.default_authority'];\r\n        }\r\n        else {\r\n            this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);\r\n        }\r\n        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);\r\n        this.target = proxyMapResult.target;\r\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\r\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\r\n         * the grpc.use_local_subchannel_pool channel option means. */\r\n        this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\r\n        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d = options['grpc.retry_buffer_size']) !== null && _d !== void 0 ? _d : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e = options['grpc.per_rpc_retry_buffer_size']) !== null && _e !== void 0 ? _e : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);\r\n        this.keepaliveTime = (_f = options['grpc.keepalive_time_ms']) !== null && _f !== void 0 ? _f : -1;\r\n        this.idleTimeoutMs = Math.max((_g = options['grpc.client_idle_timeout_ms']) !== null && _g !== void 0 ? _g : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);\r\n        const channelControlHelper = {\r\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\r\n                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\r\n                subchannel.throttleKeepalive(this.keepaliveTime);\r\n                if (this.channelzEnabled) {\r\n                    this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\r\n                }\r\n                const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);\r\n                this.wrappedSubchannels.add(wrappedSubchannel);\r\n                return wrappedSubchannel;\r\n            },\r\n            updateState: (connectivityState, picker) => {\r\n                this.currentPicker = picker;\r\n                const queueCopy = this.pickQueue.slice();\r\n                this.pickQueue = [];\r\n                if (queueCopy.length > 0) {\r\n                    this.callRefTimerUnref();\r\n                }\r\n                for (const call of queueCopy) {\r\n                    call.doPick();\r\n                }\r\n                this.updateState(connectivityState);\r\n            },\r\n            requestReresolution: () => {\r\n                // This should never be called.\r\n                throw new Error('Resolving load balancer should never call requestReresolution');\r\n            },\r\n            addChannelzChild: (child) => {\r\n                if (this.channelzEnabled) {\r\n                    this.childrenTracker.refChild(child);\r\n                }\r\n            },\r\n            removeChannelzChild: (child) => {\r\n                if (this.channelzEnabled) {\r\n                    this.childrenTracker.unrefChild(child);\r\n                }\r\n            },\r\n        };\r\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (serviceConfig, configSelector) => {\r\n            if (serviceConfig.retryThrottling) {\r\n                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));\r\n            }\r\n            else {\r\n                RETRY_THROTTLER_MAP.delete(this.getTarget());\r\n            }\r\n            if (this.channelzEnabled) {\r\n                this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\r\n            }\r\n            this.configSelector = configSelector;\r\n            this.currentResolutionError = null;\r\n            /* We process the queue asynchronously to ensure that the corresponding\r\n             * load balancer update has completed. */\r\n            process.nextTick(() => {\r\n                const localQueue = this.configSelectionQueue;\r\n                this.configSelectionQueue = [];\r\n                if (localQueue.length > 0) {\r\n                    this.callRefTimerUnref();\r\n                }\r\n                for (const call of localQueue) {\r\n                    call.getConfig();\r\n                }\r\n            });\r\n        }, status => {\r\n            if (this.channelzEnabled) {\r\n                this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' +\r\n                    status.code +\r\n                    ' and details \"' +\r\n                    status.details +\r\n                    '\"');\r\n            }\r\n            if (this.configSelectionQueue.length > 0) {\r\n                this.trace('Name resolution failed with calls queued for config selection');\r\n            }\r\n            if (this.configSelector === null) {\r\n                this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), { metadata: status.metadata });\r\n            }\r\n            const localQueue = this.configSelectionQueue;\r\n            this.configSelectionQueue = [];\r\n            if (localQueue.length > 0) {\r\n                this.callRefTimerUnref();\r\n            }\r\n            for (const call of localQueue) {\r\n                call.reportResolverError(status);\r\n            }\r\n        });\r\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\r\n            new compression_filter_1.CompressionFilterFactory(this, this.options),\r\n        ]);\r\n        this.trace('Channel constructed with options ' +\r\n            JSON.stringify(options, undefined, 2));\r\n        const error = new Error();\r\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            'Channel constructed \\n' +\r\n            ((_h = error.stack) === null || _h === void 0 ? void 0 : _h.substring(error.stack.indexOf('\\n') + 1)));\r\n        this.lastActivityTimestamp = new Date();\r\n    }\r\n    getChannelzInfo() {\r\n        return {\r\n            target: this.originalTarget,\r\n            state: this.connectivityState,\r\n            trace: this.channelzTrace,\r\n            callTracker: this.callTracker,\r\n            children: this.childrenTracker.getChildLists(),\r\n        };\r\n    }\r\n    trace(text, verbosityOverride) {\r\n        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + text);\r\n    }\r\n    callRefTimerRef() {\r\n        var _a, _b, _c, _d;\r\n        // If the hasRef function does not exist, always run the code\r\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\r\n            this.trace('callRefTimer.ref | configSelectionQueue.length=' +\r\n                this.configSelectionQueue.length +\r\n                ' pickQueue.length=' +\r\n                this.pickQueue.length);\r\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\r\n        }\r\n    }\r\n    callRefTimerUnref() {\r\n        var _a, _b;\r\n        // If the hasRef function does not exist, always run the code\r\n        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\r\n            this.trace('callRefTimer.unref | configSelectionQueue.length=' +\r\n                this.configSelectionQueue.length +\r\n                ' pickQueue.length=' +\r\n                this.pickQueue.length);\r\n            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n    }\r\n    removeConnectivityStateWatcher(watcherObject) {\r\n        const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\r\n        if (watcherIndex >= 0) {\r\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\r\n        }\r\n    }\r\n    updateState(newState) {\r\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            (0, uri_parser_1.uriToString)(this.target) +\r\n            ' ' +\r\n            connectivity_state_1.ConnectivityState[this.connectivityState] +\r\n            ' -> ' +\r\n            connectivity_state_1.ConnectivityState[newState]);\r\n        if (this.channelzEnabled) {\r\n            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\r\n        }\r\n        this.connectivityState = newState;\r\n        const watchersCopy = this.connectivityStateWatchers.slice();\r\n        for (const watcherObject of watchersCopy) {\r\n            if (newState !== watcherObject.currentState) {\r\n                if (watcherObject.timer) {\r\n                    clearTimeout(watcherObject.timer);\r\n                }\r\n                this.removeConnectivityStateWatcher(watcherObject);\r\n                watcherObject.callback();\r\n            }\r\n        }\r\n        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\r\n            this.currentResolutionError = null;\r\n        }\r\n    }\r\n    throttleKeepalive(newKeepaliveTime) {\r\n        if (newKeepaliveTime > this.keepaliveTime) {\r\n            this.keepaliveTime = newKeepaliveTime;\r\n            for (const wrappedSubchannel of this.wrappedSubchannels) {\r\n                wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\r\n            }\r\n        }\r\n    }\r\n    removeWrappedSubchannel(wrappedSubchannel) {\r\n        this.wrappedSubchannels.delete(wrappedSubchannel);\r\n    }\r\n    doPick(metadata, extraPickInfo) {\r\n        return this.currentPicker.pick({\r\n            metadata: metadata,\r\n            extraPickInfo: extraPickInfo,\r\n        });\r\n    }\r\n    queueCallForPick(call) {\r\n        this.pickQueue.push(call);\r\n        this.callRefTimerRef();\r\n    }\r\n    getConfig(method, metadata) {\r\n        this.resolvingLoadBalancer.exitIdle();\r\n        if (this.configSelector) {\r\n            return {\r\n                type: 'SUCCESS',\r\n                config: this.configSelector(method, metadata),\r\n            };\r\n        }\r\n        else {\r\n            if (this.currentResolutionError) {\r\n                return {\r\n                    type: 'ERROR',\r\n                    error: this.currentResolutionError,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: 'NONE',\r\n                };\r\n            }\r\n        }\r\n    }\r\n    queueCallForConfig(call) {\r\n        this.configSelectionQueue.push(call);\r\n        this.callRefTimerRef();\r\n    }\r\n    enterIdle() {\r\n        this.resolvingLoadBalancer.destroy();\r\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE);\r\n        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);\r\n        if (this.idleTimer) {\r\n            clearTimeout(this.idleTimer);\r\n            this.idleTimer = null;\r\n        }\r\n    }\r\n    startIdleTimeout(timeoutMs) {\r\n        var _a, _b;\r\n        this.idleTimer = setTimeout(() => {\r\n            if (this.callCount > 0) {\r\n                /* If there is currently a call, the channel will not go idle for a\r\n                 * period of at least idleTimeoutMs, so check again after that time.\r\n                 */\r\n                this.startIdleTimeout(this.idleTimeoutMs);\r\n                return;\r\n            }\r\n            const now = new Date();\r\n            const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();\r\n            if (timeSinceLastActivity >= this.idleTimeoutMs) {\r\n                this.trace('Idle timer triggered after ' +\r\n                    this.idleTimeoutMs +\r\n                    'ms of inactivity');\r\n                this.enterIdle();\r\n            }\r\n            else {\r\n                /* Whenever the timer fires with the latest activity being too recent,\r\n                 * set the timer again for the time when the time since the last\r\n                 * activity is equal to the timeout. This should result in the timer\r\n                 * firing no more than once every idleTimeoutMs/2 on average. */\r\n                this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);\r\n            }\r\n        }, timeoutMs);\r\n        (_b = (_a = this.idleTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    }\r\n    maybeStartIdleTimer() {\r\n        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN && !this.idleTimer) {\r\n            this.startIdleTimeout(this.idleTimeoutMs);\r\n        }\r\n    }\r\n    onCallStart() {\r\n        if (this.channelzEnabled) {\r\n            this.callTracker.addCallStarted();\r\n        }\r\n        this.callCount += 1;\r\n    }\r\n    onCallEnd(status) {\r\n        if (this.channelzEnabled) {\r\n            if (status.code === constants_1.Status.OK) {\r\n                this.callTracker.addCallSucceeded();\r\n            }\r\n            else {\r\n                this.callTracker.addCallFailed();\r\n            }\r\n        }\r\n        this.callCount -= 1;\r\n        this.lastActivityTimestamp = new Date();\r\n        this.maybeStartIdleTimer();\r\n    }\r\n    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {\r\n        const callNumber = (0, call_number_1.getNextCallNumber)();\r\n        this.trace('createLoadBalancingCall [' + callNumber + '] method=\"' + method + '\"');\r\n        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);\r\n    }\r\n    createRetryingCall(callConfig, method, host, credentials, deadline) {\r\n        const callNumber = (0, call_number_1.getNextCallNumber)();\r\n        this.trace('createRetryingCall [' + callNumber + '] method=\"' + method + '\"');\r\n        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));\r\n    }\r\n    createInnerCall(callConfig, method, host, credentials, deadline) {\r\n        // Create a RetryingCall if retries are enabled\r\n        if (this.options['grpc.enable_retries'] === 0) {\r\n            return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);\r\n        }\r\n        else {\r\n            return this.createRetryingCall(callConfig, method, host, credentials, deadline);\r\n        }\r\n    }\r\n    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {\r\n        const callNumber = (0, call_number_1.getNextCallNumber)();\r\n        this.trace('createResolvingCall [' +\r\n            callNumber +\r\n            '] method=\"' +\r\n            method +\r\n            '\", deadline=' +\r\n            (0, deadline_1.deadlineToString)(deadline));\r\n        const finalOptions = {\r\n            deadline: deadline,\r\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\r\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\r\n            parentCall: parentCall,\r\n        };\r\n        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);\r\n        this.onCallStart();\r\n        call.addStatusWatcher(status => {\r\n            this.onCallEnd(status);\r\n        });\r\n        return call;\r\n    }\r\n    close() {\r\n        this.resolvingLoadBalancer.destroy();\r\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\r\n        clearInterval(this.callRefTimer);\r\n        if (this.idleTimer) {\r\n            clearTimeout(this.idleTimer);\r\n        }\r\n        if (this.channelzEnabled) {\r\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\r\n        }\r\n        this.subchannelPool.unrefUnusedSubchannels();\r\n    }\r\n    getTarget() {\r\n        return (0, uri_parser_1.uriToString)(this.target);\r\n    }\r\n    getConnectivityState(tryToConnect) {\r\n        const connectivityState = this.connectivityState;\r\n        if (tryToConnect) {\r\n            this.resolvingLoadBalancer.exitIdle();\r\n            this.lastActivityTimestamp = new Date();\r\n            this.maybeStartIdleTimer();\r\n        }\r\n        return connectivityState;\r\n    }\r\n    watchConnectivityState(currentState, deadline, callback) {\r\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\r\n            throw new Error('Channel has been shut down');\r\n        }\r\n        let timer = null;\r\n        if (deadline !== Infinity) {\r\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\r\n            const now = new Date();\r\n            if (deadline === -Infinity || deadlineDate <= now) {\r\n                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\r\n                return;\r\n            }\r\n            timer = setTimeout(() => {\r\n                this.removeConnectivityStateWatcher(watcherObject);\r\n                callback(new Error('Deadline passed without connectivity state change'));\r\n            }, deadlineDate.getTime() - now.getTime());\r\n        }\r\n        const watcherObject = {\r\n            currentState,\r\n            callback,\r\n            timer,\r\n        };\r\n        this.connectivityStateWatchers.push(watcherObject);\r\n    }\r\n    /**\r\n     * Get the channelz reference object for this channel. The returned value is\r\n     * garbage if channelz is disabled for this channel.\r\n     * @returns\r\n     */\r\n    getChannelzRef() {\r\n        return this.channelzRef;\r\n    }\r\n    createCall(method, deadline, host, parentCall, propagateFlags) {\r\n        if (typeof method !== 'string') {\r\n            throw new TypeError('Channel#createCall: method must be a string');\r\n        }\r\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\r\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\r\n        }\r\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\r\n            throw new Error('Channel has been shut down');\r\n        }\r\n        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);\r\n    }\r\n}\r\nexports.InternalChannel = InternalChannel;\r\n//# sourceMappingURL=internal-channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW50ZXJuYWwtY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2Qiw4QkFBOEIsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDN0Qsa0NBQWtDLG1CQUFPLENBQUMsMEdBQTJCO0FBQ3JFLDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDL0MsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLDBFQUFXO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2Qyw4QkFBOEIsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDN0QsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsd0ZBQWtCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDLCtCQUErQixtQkFBTyxDQUFDLG9HQUF3QjtBQUMvRCx3QkFBd0IsbUJBQU8sQ0FBQyxzRkFBaUI7QUFDakQsK0JBQStCLG1CQUFPLENBQUMsb0dBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE9BQU87QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsOEZBQThGLDJCQUEyQjtBQUNyTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2ludGVybmFsLWNoYW5uZWwuanM/YThkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5JbnRlcm5hbENoYW5uZWwgPSB2b2lkIDA7XHJcbmNvbnN0IGNoYW5uZWxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWwtY3JlZGVudGlhbHNcIik7XHJcbmNvbnN0IHJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZpbmctbG9hZC1iYWxhbmNlclwiKTtcclxuY29uc3Qgc3ViY2hhbm5lbF9wb29sXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLXBvb2xcIik7XHJcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgZmlsdGVyX3N0YWNrXzEgPSByZXF1aXJlKFwiLi9maWx0ZXItc3RhY2tcIik7XHJcbmNvbnN0IGNvbXByZXNzaW9uX2ZpbHRlcl8xID0gcmVxdWlyZShcIi4vY29tcHJlc3Npb24tZmlsdGVyXCIpO1xyXG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XHJcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IGh0dHBfcHJveHlfMSA9IHJlcXVpcmUoXCIuL2h0dHBfcHJveHlcIik7XHJcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XHJcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xyXG5jb25zdCBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XHJcbmNvbnN0IGxvYWRfYmFsYW5jaW5nX2NhbGxfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jaW5nLWNhbGxcIik7XHJcbmNvbnN0IGRlYWRsaW5lXzEgPSByZXF1aXJlKFwiLi9kZWFkbGluZVwiKTtcclxuY29uc3QgcmVzb2x2aW5nX2NhbGxfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmluZy1jYWxsXCIpO1xyXG5jb25zdCBjYWxsX251bWJlcl8xID0gcmVxdWlyZShcIi4vY2FsbC1udW1iZXJcIik7XHJcbmNvbnN0IGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEgPSByZXF1aXJlKFwiLi9jb250cm9sLXBsYW5lLXN0YXR1c1wiKTtcclxuY29uc3QgcmV0cnlpbmdfY2FsbF8xID0gcmVxdWlyZShcIi4vcmV0cnlpbmctY2FsbFwiKTtcclxuY29uc3Qgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xyXG4vKipcclxuICogU2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZXJzX3NldGludGVydmFsX2NhbGxiYWNrX2RlbGF5X2FyZ3NcclxuICovXHJcbmNvbnN0IE1BWF9USU1FT1VUX1RJTUUgPSAyMTQ3NDgzNjQ3O1xyXG5jb25zdCBNSU5fSURMRV9USU1FT1VUX01TID0gMTAwMDtcclxuLy8gMzAgbWludXRlc1xyXG5jb25zdCBERUZBVUxUX0lETEVfVElNRU9VVF9NUyA9IDMwICogNjAgKiAxMDAwO1xyXG5jb25zdCBSRVRSWV9USFJPVFRMRVJfTUFQID0gbmV3IE1hcCgpO1xyXG5jb25zdCBERUZBVUxUX1JFVFJZX0JVRkZFUl9TSVpFX0JZVEVTID0gMSA8PCAyNDsgLy8gMTYgTUJcclxuY29uc3QgREVGQVVMVF9QRVJfUlBDX1JFVFJZX0JVRkZFUl9TSVpFX0JZVEVTID0gMSA8PCAyMDsgLy8gMSBNQlxyXG5jbGFzcyBDaGFubmVsU3ViY2hhbm5lbFdyYXBwZXIgZXh0ZW5kcyBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGlsZFN1YmNoYW5uZWwsIGNoYW5uZWwpIHtcclxuICAgICAgICBzdXBlcihjaGlsZFN1YmNoYW5uZWwpO1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XHJcbiAgICAgICAgdGhpcy5yZWZDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lciA9IChzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwga2VlcGFsaXZlVGltZSkgPT4ge1xyXG4gICAgICAgICAgICBjaGFubmVsLnRocm90dGxlS2VlcGFsaXZlKGtlZXBhbGl2ZVRpbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY2hpbGRTdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICByZWYoKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZC5yZWYoKTtcclxuICAgICAgICB0aGlzLnJlZkNvdW50ICs9IDE7XHJcbiAgICB9XHJcbiAgICB1bnJlZigpIHtcclxuICAgICAgICB0aGlzLmNoaWxkLnVucmVmKCk7XHJcbiAgICAgICAgdGhpcy5yZWZDb3VudCAtPSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlZkNvdW50IDw9IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwucmVtb3ZlV3JhcHBlZFN1YmNoYW5uZWwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIEludGVybmFsQ2hhbm5lbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNyZWRlbnRpYWxzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcclxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxscyBxdWV1ZWQgdXAgdG8gZ2V0IGEgY2FsbCBjb25maWcuIFNob3VsZCBvbmx5IGJlIHBvcHVsYXRlZCBiZWZvcmUgdGhlXHJcbiAgICAgICAgICogZmlyc3QgdGltZSB0aGUgcmVzb2x2ZXIgcmV0dXJucyBhIHJlc3VsdCwgd2hpY2ggaW5jbHVkZXMgdGhlIENvbmZpZ1NlbGVjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUgPSBbXTtcclxuICAgICAgICB0aGlzLnBpY2tRdWV1ZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0b3IgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGVycm9yIGZyb20gdGhlIG5hbWUgcmVzb2x2ZXIgaWYgaXQgZmFpbGVkIG1vc3QgcmVjZW50bHkuIEl0XHJcbiAgICAgICAgICogaXMgb25seSB1c2VkIHRvIGVuZCBjYWxscyB0aGF0IHN0YXJ0IHdoaWxlIHRoZXJlIGlzIG5vIGNvbmZpZyBzZWxlY3RvclxyXG4gICAgICAgICAqIGFuZCB0aGUgbmFtZSByZXNvbHZlciBpcyBpbiBiYWNrb2ZmLCBzbyBpdCBzaG91bGQgYmUgbnVsbGVkIGlmXHJcbiAgICAgICAgICogY29uZmlnU2VsZWN0b3IgYmVjb21lcyBzZXQgb3IgdGhlIGNoYW5uZWwgc3RhdGUgYmVjb21lcyBhbnl0aGluZyBvdGhlclxyXG4gICAgICAgICAqIHRoYW4gVFJBTlNJRU5UX0ZBSUxVUkUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLndyYXBwZWRTdWJjaGFubmVscyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmNhbGxDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xyXG4gICAgICAgIC8vIENoYW5uZWx6IGluZm9cclxuICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jYWxsVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgdGFyZ2V0IG11c3QgYmUgYSBzdHJpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoY3JlZGVudGlhbHMgaW5zdGFuY2VvZiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIGNyZWRlbnRpYWxzIG11c3QgYmUgYSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUYXJnZXRVcmkgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKSh0YXJnZXQpO1xyXG4gICAgICAgIGlmIChvcmlnaW5hbFRhcmdldFVyaSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSB0YXJnZXQgbmFtZSBcIiR7dGFyZ2V0fVwiYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSB0YXJnZXQgaGFzIGEgc2NoZW1lIHRoYXQgaXMgcmVnaXN0ZXJlZCB3aXRoIHRoZVxyXG4gICAgICAgICAqIHJlc29sdmVyICovXHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCA9ICgwLCByZXNvbHZlcl8xLm1hcFVyaURlZmF1bHRTY2hlbWUpKG9yaWdpbmFsVGFyZ2V0VXJpKTtcclxuICAgICAgICBpZiAoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgZGVmYXVsdCBzY2hlbWUgZm9yIHRhcmdldCBuYW1lIFwiJHt0YXJnZXR9XCJgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsUmVmVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7IH0sIE1BWF9USU1FT1VUX1RJTUUpO1xyXG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZSgpO1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCkodGFyZ2V0LCAoKSA9PiB0aGlzLmdldENoYW5uZWx6SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDaGFubmVsIGNyZWF0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1snZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSddKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEF1dGhvcml0eSA9IHRoaXMub3B0aW9uc1snZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QXV0aG9yaXR5ID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByb3h5TWFwUmVzdWx0ID0gKDAsIGh0dHBfcHJveHlfMS5tYXBQcm94eU5hbWUpKGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gcHJveHlNYXBSZXN1bHQudGFyZ2V0O1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcHJveHlNYXBSZXN1bHQuZXh0cmFPcHRpb25zKTtcclxuICAgICAgICAvKiBUaGUgZ2xvYmFsIGJvb2xlYW4gcGFyYW1ldGVyIHRvIGdldFN1YmNoYW5uZWxQb29sIGhhcyB0aGUgaW52ZXJzZSBtZWFuaW5nIHRvIHdoYXRcclxuICAgICAgICAgKiB0aGUgZ3JwYy51c2VfbG9jYWxfc3ViY2hhbm5lbF9wb29sIGNoYW5uZWwgb3B0aW9uIG1lYW5zLiAqL1xyXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFBvb2wgPSAoMCwgc3ViY2hhbm5lbF9wb29sXzEuZ2V0U3ViY2hhbm5lbFBvb2wpKCgoX2MgPSBvcHRpb25zWydncnBjLnVzZV9sb2NhbF9zdWJjaGFubmVsX3Bvb2wnXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCkgPT09IDApO1xyXG4gICAgICAgIHRoaXMucmV0cnlCdWZmZXJUcmFja2VyID0gbmV3IHJldHJ5aW5nX2NhbGxfMS5NZXNzYWdlQnVmZmVyVHJhY2tlcigoX2QgPSBvcHRpb25zWydncnBjLnJldHJ5X2J1ZmZlcl9zaXplJ10pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IERFRkFVTFRfUkVUUllfQlVGRkVSX1NJWkVfQllURVMsIChfZSA9IG9wdGlvbnNbJ2dycGMucGVyX3JwY19yZXRyeV9idWZmZXJfc2l6ZSddKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBERUZBVUxUX1BFUl9SUENfUkVUUllfQlVGRkVSX1NJWkVfQllURVMpO1xyXG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IChfZiA9IG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogLTE7XHJcbiAgICAgICAgdGhpcy5pZGxlVGltZW91dE1zID0gTWF0aC5tYXgoKF9nID0gb3B0aW9uc1snZ3JwYy5jbGllbnRfaWRsZV90aW1lb3V0X21zJ10pICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IERFRkFVTFRfSURMRV9USU1FT1VUX01TLCBNSU5fSURMRV9USU1FT1VUX01TKTtcclxuICAgICAgICBjb25zdCBjaGFubmVsQ29udHJvbEhlbHBlciA9IHtcclxuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbCA9IHRoaXMuc3ViY2hhbm5lbFBvb2wuZ2V0T3JDcmVhdGVTdWJjaGFubmVsKHRoaXMudGFyZ2V0LCBzdWJjaGFubmVsQWRkcmVzcywgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBzdWJjaGFubmVsQXJncyksIHRoaXMuY3JlZGVudGlhbHMpO1xyXG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbC50aHJvdHRsZUtlZXBhbGl2ZSh0aGlzLmtlZXBhbGl2ZVRpbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0NyZWF0ZWQgc3ViY2hhbm5lbCBvciB1c2VkIGV4aXN0aW5nIHN1YmNoYW5uZWwnLCBzdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZFN1YmNoYW5uZWwgPSBuZXcgQ2hhbm5lbFN1YmNoYW5uZWxXcmFwcGVyKHN1YmNoYW5uZWwsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cmFwcGVkU3ViY2hhbm5lbHMuYWRkKHdyYXBwZWRTdWJjaGFubmVsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkU3ViY2hhbm5lbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBwaWNrZXI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBxdWV1ZUNvcHkgPSB0aGlzLnBpY2tRdWV1ZS5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChxdWV1ZUNvcHkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyVW5yZWYoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBxdWV1ZUNvcHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsLmRvUGljaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb246ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZC5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzb2x2aW5nIGxvYWQgYmFsYW5jZXIgc2hvdWxkIG5ldmVyIGNhbGwgcmVxdWVzdFJlcmVzb2x1dGlvbicpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiAoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gbmV3IHJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEuUmVzb2x2aW5nTG9hZEJhbGFuY2VyKHRoaXMudGFyZ2V0LCBjaGFubmVsQ29udHJvbEhlbHBlciwgb3B0aW9ucywgKHNlcnZpY2VDb25maWcsIGNvbmZpZ1NlbGVjdG9yKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZykge1xyXG4gICAgICAgICAgICAgICAgUkVUUllfVEhST1RUTEVSX01BUC5zZXQodGhpcy5nZXRUYXJnZXQoKSwgbmV3IHJldHJ5aW5nX2NhbGxfMS5SZXRyeVRocm90dGxlcihzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZy5tYXhUb2tlbnMsIHNlcnZpY2VDb25maWcucmV0cnlUaHJvdHRsaW5nLnRva2VuUmF0aW8sIFJFVFJZX1RIUk9UVExFUl9NQVAuZ2V0KHRoaXMuZ2V0VGFyZ2V0KCkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBSRVRSWV9USFJPVFRMRVJfTUFQLmRlbGV0ZSh0aGlzLmdldFRhcmdldCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdBZGRyZXNzIHJlc29sdXRpb24gc3VjY2VlZGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3RvciA9IGNvbmZpZ1NlbGVjdG9yO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAvKiBXZSBwcm9jZXNzIHRoZSBxdWV1ZSBhc3luY2hyb25vdXNseSB0byBlbnN1cmUgdGhhdCB0aGUgY29ycmVzcG9uZGluZ1xyXG4gICAgICAgICAgICAgKiBsb2FkIGJhbGFuY2VyIHVwZGF0ZSBoYXMgY29tcGxldGVkLiAqL1xyXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsUXVldWUgPSB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyVW5yZWYoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBsb2NhbFF1ZXVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5nZXRDb25maWcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgc3RhdHVzID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX1dBUk5JTkcnLCAnQWRkcmVzcyByZXNvbHV0aW9uIGZhaWxlZCB3aXRoIGNvZGUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmNvZGUgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgYW5kIGRldGFpbHMgXCInICtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGV0YWlscyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ1wiJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnTmFtZSByZXNvbHV0aW9uIGZhaWxlZCB3aXRoIGNhbGxzIHF1ZXVlZCBmb3IgY29uZmlnIHNlbGVjdGlvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ1NlbGVjdG9yID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkoc3RhdHVzLmNvZGUsIHN0YXR1cy5kZXRhaWxzKSksIHsgbWV0YWRhdGE6IHN0YXR1cy5tZXRhZGF0YSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsb2NhbFF1ZXVlID0gdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZTtcclxuICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xyXG4gICAgICAgICAgICBpZiAobG9jYWxRdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIGxvY2FsUXVldWUpIHtcclxuICAgICAgICAgICAgICAgIGNhbGwucmVwb3J0UmVzb2x2ZXJFcnJvcihzdGF0dXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkgPSBuZXcgZmlsdGVyX3N0YWNrXzEuRmlsdGVyU3RhY2tGYWN0b3J5KFtcclxuICAgICAgICAgICAgbmV3IGNvbXByZXNzaW9uX2ZpbHRlcl8xLkNvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSh0aGlzLCB0aGlzLm9wdGlvbnMpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ0NoYW5uZWwgY29uc3RydWN0ZWQgd2l0aCBvcHRpb25zICcgK1xyXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShvcHRpb25zLCB1bmRlZmluZWQsIDIpKTtcclxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigpO1xyXG4gICAgICAgICgwLCBsb2dnaW5nXzEudHJhY2UpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2NoYW5uZWxfc3RhY2t0cmFjZScsICcoJyArXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xyXG4gICAgICAgICAgICAnKSAnICtcclxuICAgICAgICAgICAgJ0NoYW5uZWwgY29uc3RydWN0ZWQgXFxuJyArXHJcbiAgICAgICAgICAgICgoX2ggPSBlcnJvci5zdGFjaykgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLnN1YnN0cmluZyhlcnJvci5zdGFjay5pbmRleE9mKCdcXG4nKSArIDEpKSk7XHJcbiAgICAgICAgdGhpcy5sYXN0QWN0aXZpdHlUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbm5lbHpJbmZvKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5vcmlnaW5hbFRhcmdldCxcclxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuY29ubmVjdGl2aXR5U3RhdGUsXHJcbiAgICAgICAgICAgIHRyYWNlOiB0aGlzLmNoYW5uZWx6VHJhY2UsXHJcbiAgICAgICAgICAgIGNhbGxUcmFja2VyOiB0aGlzLmNhbGxUcmFja2VyLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB0cmFjZSh0ZXh0LCB2ZXJib3NpdHlPdmVycmlkZSkge1xyXG4gICAgICAgICgwLCBsb2dnaW5nXzEudHJhY2UpKHZlcmJvc2l0eU92ZXJyaWRlICE9PSBudWxsICYmIHZlcmJvc2l0eU92ZXJyaWRlICE9PSB2b2lkIDAgPyB2ZXJib3NpdHlPdmVycmlkZSA6IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2NoYW5uZWwnLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArICcgJyArIHRleHQpO1xyXG4gICAgfVxyXG4gICAgY2FsbFJlZlRpbWVyUmVmKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICAvLyBJZiB0aGUgaGFzUmVmIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0LCBhbHdheXMgcnVuIHRoZSBjb2RlXHJcbiAgICAgICAgaWYgKCEoKF9iID0gKF9hID0gdGhpcy5jYWxsUmVmVGltZXIpLmhhc1JlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjYWxsUmVmVGltZXIucmVmIHwgY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoPScgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggK1xyXG4gICAgICAgICAgICAgICAgJyBwaWNrUXVldWUubGVuZ3RoPScgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUubGVuZ3RoKTtcclxuICAgICAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYWxsUmVmVGltZXIpLnJlZikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhbGxSZWZUaW1lclVucmVmKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgLy8gSWYgdGhlIGhhc1JlZiBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCwgYWx3YXlzIHJ1biB0aGUgY29kZVxyXG4gICAgICAgIGlmICghdGhpcy5jYWxsUmVmVGltZXIuaGFzUmVmIHx8IHRoaXMuY2FsbFJlZlRpbWVyLmhhc1JlZigpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NhbGxSZWZUaW1lci51bnJlZiB8IGNvbmZpZ1NlbGVjdGlvblF1ZXVlLmxlbmd0aD0nICtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoICtcclxuICAgICAgICAgICAgICAgICcgcGlja1F1ZXVlLmxlbmd0aD0nICtcclxuICAgICAgICAgICAgICAgIHRoaXMucGlja1F1ZXVlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KSB7XHJcbiAgICAgICAgY29uc3Qgd2F0Y2hlckluZGV4ID0gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLmZpbmRJbmRleCh2YWx1ZSA9PiB2YWx1ZSA9PT0gd2F0Y2hlck9iamVjdCk7XHJcbiAgICAgICAgaWYgKHdhdGNoZXJJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5zcGxpY2Uod2F0Y2hlckluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSkge1xyXG4gICAgICAgICgwLCBsb2dnaW5nXzEudHJhY2UpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2Nvbm5lY3Rpdml0eV9zdGF0ZScsICcoJyArXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xyXG4gICAgICAgICAgICAnKSAnICtcclxuICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcclxuICAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jb25uZWN0aXZpdHlTdGF0ZV0gK1xyXG4gICAgICAgICAgICAnIC0+ICcgK1xyXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xyXG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZSB0byAnICsgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IG5ld1N0YXRlO1xyXG4gICAgICAgIGNvbnN0IHdhdGNoZXJzQ29weSA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5zbGljZSgpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgd2F0Y2hlck9iamVjdCBvZiB3YXRjaGVyc0NvcHkpIHtcclxuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSB3YXRjaGVyT2JqZWN0LmN1cnJlbnRTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdhdGNoZXJPYmplY3QudGltZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQod2F0Y2hlck9iamVjdC50aW1lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KTtcclxuICAgICAgICAgICAgICAgIHdhdGNoZXJPYmplY3QuY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV3U3RhdGUgIT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhyb3R0bGVLZWVwYWxpdmUobmV3S2VlcGFsaXZlVGltZSkge1xyXG4gICAgICAgIGlmIChuZXdLZWVwYWxpdmVUaW1lID4gdGhpcy5rZWVwYWxpdmVUaW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IG5ld0tlZXBhbGl2ZVRpbWU7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd3JhcHBlZFN1YmNoYW5uZWwgb2YgdGhpcy53cmFwcGVkU3ViY2hhbm5lbHMpIHtcclxuICAgICAgICAgICAgICAgIHdyYXBwZWRTdWJjaGFubmVsLnRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlV3JhcHBlZFN1YmNoYW5uZWwod3JhcHBlZFN1YmNoYW5uZWwpIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRTdWJjaGFubmVscy5kZWxldGUod3JhcHBlZFN1YmNoYW5uZWwpO1xyXG4gICAgfVxyXG4gICAgZG9QaWNrKG1ldGFkYXRhLCBleHRyYVBpY2tJbmZvKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBpY2tlci5waWNrKHtcclxuICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxyXG4gICAgICAgICAgICBleHRyYVBpY2tJbmZvOiBleHRyYVBpY2tJbmZvLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcXVldWVDYWxsRm9yUGljayhjYWxsKSB7XHJcbiAgICAgICAgdGhpcy5waWNrUXVldWUucHVzaChjYWxsKTtcclxuICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclJlZigpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29uZmlnKG1ldGhvZCwgbWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ1NlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnU1VDQ0VTUycsXHJcbiAgICAgICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnU2VsZWN0b3IobWV0aG9kLCBtZXRhZGF0YSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdFUlJPUicsXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvcixcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdOT05FJyxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBxdWV1ZUNhbGxGb3JDb25maWcoY2FsbCkge1xyXG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUucHVzaChjYWxsKTtcclxuICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclJlZigpO1xyXG4gICAgfVxyXG4gICAgZW50ZXJJZGxlKCkge1xyXG4gICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlcik7XHJcbiAgICAgICAgaWYgKHRoaXMuaWRsZVRpbWVyKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lcik7XHJcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFydElkbGVUaW1lb3V0KHRpbWVvdXRNcykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgLyogSWYgdGhlcmUgaXMgY3VycmVudGx5IGEgY2FsbCwgdGhlIGNoYW5uZWwgd2lsbCBub3QgZ28gaWRsZSBmb3IgYVxyXG4gICAgICAgICAgICAgICAgICogcGVyaW9kIG9mIGF0IGxlYXN0IGlkbGVUaW1lb3V0TXMsIHNvIGNoZWNrIGFnYWluIGFmdGVyIHRoYXQgdGltZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydElkbGVUaW1lb3V0KHRoaXMuaWRsZVRpbWVvdXRNcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdEFjdGl2aXR5ID0gbm93LnZhbHVlT2YoKSAtIHRoaXMubGFzdEFjdGl2aXR5VGltZXN0YW1wLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RBY3Rpdml0eSA+PSB0aGlzLmlkbGVUaW1lb3V0TXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0lkbGUgdGltZXIgdHJpZ2dlcmVkIGFmdGVyICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVvdXRNcyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ21zIG9mIGluYWN0aXZpdHknKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJJZGxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvKiBXaGVuZXZlciB0aGUgdGltZXIgZmlyZXMgd2l0aCB0aGUgbGF0ZXN0IGFjdGl2aXR5IGJlaW5nIHRvbyByZWNlbnQsXHJcbiAgICAgICAgICAgICAgICAgKiBzZXQgdGhlIHRpbWVyIGFnYWluIGZvciB0aGUgdGltZSB3aGVuIHRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0XHJcbiAgICAgICAgICAgICAgICAgKiBhY3Rpdml0eSBpcyBlcXVhbCB0byB0aGUgdGltZW91dC4gVGhpcyBzaG91bGQgcmVzdWx0IGluIHRoZSB0aW1lclxyXG4gICAgICAgICAgICAgICAgICogZmlyaW5nIG5vIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGlkbGVUaW1lb3V0TXMvMiBvbiBhdmVyYWdlLiAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydElkbGVUaW1lb3V0KHRoaXMuaWRsZVRpbWVvdXRNcyAtIHRpbWVTaW5jZUxhc3RBY3Rpdml0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aW1lb3V0TXMpO1xyXG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuaWRsZVRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xyXG4gICAgfVxyXG4gICAgbWF5YmVTdGFydElkbGVUaW1lcigpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04gJiYgIXRoaXMuaWRsZVRpbWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRJZGxlVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0TXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uQ2FsbFN0YXJ0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENvdW50ICs9IDE7XHJcbiAgICB9XHJcbiAgICBvbkNhbGxFbmQoc3RhdHVzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENvdW50IC09IDE7XHJcbiAgICAgICAgdGhpcy5sYXN0QWN0aXZpdHlUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHRoaXMubWF5YmVTdGFydElkbGVUaW1lcigpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlTG9hZEJhbGFuY2luZ0NhbGwoY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUpIHtcclxuICAgICAgICBjb25zdCBjYWxsTnVtYmVyID0gKDAsIGNhbGxfbnVtYmVyXzEuZ2V0TmV4dENhbGxOdW1iZXIpKCk7XHJcbiAgICAgICAgdGhpcy50cmFjZSgnY3JlYXRlTG9hZEJhbGFuY2luZ0NhbGwgWycgKyBjYWxsTnVtYmVyICsgJ10gbWV0aG9kPVwiJyArIG1ldGhvZCArICdcIicpO1xyXG4gICAgICAgIHJldHVybiBuZXcgbG9hZF9iYWxhbmNpbmdfY2FsbF8xLkxvYWRCYWxhbmNpbmdDYWxsKHRoaXMsIGNhbGxDb25maWcsIG1ldGhvZCwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lLCBjYWxsTnVtYmVyKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVJldHJ5aW5nQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSkge1xyXG4gICAgICAgIGNvbnN0IGNhbGxOdW1iZXIgPSAoMCwgY2FsbF9udW1iZXJfMS5nZXROZXh0Q2FsbE51bWJlcikoKTtcclxuICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGVSZXRyeWluZ0NhbGwgWycgKyBjYWxsTnVtYmVyICsgJ10gbWV0aG9kPVwiJyArIG1ldGhvZCArICdcIicpO1xyXG4gICAgICAgIHJldHVybiBuZXcgcmV0cnlpbmdfY2FsbF8xLlJldHJ5aW5nQ2FsbCh0aGlzLCBjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSwgY2FsbE51bWJlciwgdGhpcy5yZXRyeUJ1ZmZlclRyYWNrZXIsIFJFVFJZX1RIUk9UVExFUl9NQVAuZ2V0KHRoaXMuZ2V0VGFyZ2V0KCkpKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUlubmVyQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSkge1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIFJldHJ5aW5nQ2FsbCBpZiByZXRyaWVzIGFyZSBlbmFibGVkXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1snZ3JwYy5lbmFibGVfcmV0cmllcyddID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsKGNhbGxDb25maWcsIG1ldGhvZCwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJldHJ5aW5nQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlUmVzb2x2aW5nQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xyXG4gICAgICAgIGNvbnN0IGNhbGxOdW1iZXIgPSAoMCwgY2FsbF9udW1iZXJfMS5nZXROZXh0Q2FsbE51bWJlcikoKTtcclxuICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGVSZXNvbHZpbmdDYWxsIFsnICtcclxuICAgICAgICAgICAgY2FsbE51bWJlciArXHJcbiAgICAgICAgICAgICddIG1ldGhvZD1cIicgK1xyXG4gICAgICAgICAgICBtZXRob2QgK1xyXG4gICAgICAgICAgICAnXCIsIGRlYWRsaW5lPScgK1xyXG4gICAgICAgICAgICAoMCwgZGVhZGxpbmVfMS5kZWFkbGluZVRvU3RyaW5nKShkZWFkbGluZSkpO1xyXG4gICAgICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgZGVhZGxpbmU6IGRlYWRsaW5lLFxyXG4gICAgICAgICAgICBmbGFnczogcHJvcGFnYXRlRmxhZ3MgIT09IG51bGwgJiYgcHJvcGFnYXRlRmxhZ3MgIT09IHZvaWQgMCA/IHByb3BhZ2F0ZUZsYWdzIDogY29uc3RhbnRzXzEuUHJvcGFnYXRlLkRFRkFVTFRTLFxyXG4gICAgICAgICAgICBob3N0OiBob3N0ICE9PSBudWxsICYmIGhvc3QgIT09IHZvaWQgMCA/IGhvc3QgOiB0aGlzLmRlZmF1bHRBdXRob3JpdHksXHJcbiAgICAgICAgICAgIHBhcmVudENhbGw6IHBhcmVudENhbGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBjYWxsID0gbmV3IHJlc29sdmluZ19jYWxsXzEuUmVzb2x2aW5nQ2FsbCh0aGlzLCBtZXRob2QsIGZpbmFsT3B0aW9ucywgdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkuY2xvbmUoKSwgdGhpcy5jcmVkZW50aWFscy5fZ2V0Q2FsbENyZWRlbnRpYWxzKCksIGNhbGxOdW1iZXIpO1xyXG4gICAgICAgIHRoaXMub25DYWxsU3RhcnQoKTtcclxuICAgICAgICBjYWxsLmFkZFN0YXR1c1dhdGNoZXIoc3RhdHVzID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vbkNhbGxFbmQoc3RhdHVzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2FsbDtcclxuICAgIH1cclxuICAgIGNsb3NlKCkge1xyXG4gICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOKTtcclxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2FsbFJlZlRpbWVyKTtcclxuICAgICAgICBpZiAodGhpcy5pZGxlVGltZXIpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFBvb2wudW5yZWZVbnVzZWRTdWJjaGFubmVscygpO1xyXG4gICAgfVxyXG4gICAgZ2V0VGFyZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCk7XHJcbiAgICB9XHJcbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnlUb0Nvbm5lY3QpIHtcclxuICAgICAgICBjb25zdCBjb25uZWN0aXZpdHlTdGF0ZSA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGU7XHJcbiAgICAgICAgaWYgKHRyeVRvQ29ubmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RBY3Rpdml0eVRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydElkbGVUaW1lcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29ubmVjdGl2aXR5U3RhdGU7XHJcbiAgICB9XHJcbiAgICB3YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhbm5lbCBoYXMgYmVlbiBzaHV0IGRvd24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcclxuICAgICAgICBpZiAoZGVhZGxpbmUgIT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lRGF0ZSA9IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSA/IGRlYWRsaW5lIDogbmV3IERhdGUoZGVhZGxpbmUpO1xyXG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAoZGVhZGxpbmUgPT09IC1JbmZpbml0eSB8fCBkZWFkbGluZURhdGUgPD0gbm93KSB7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgRXJyb3IoJ0RlYWRsaW5lIHBhc3NlZCB3aXRob3V0IGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UnKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVXYXRjaGVyKHdhdGNoZXJPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdEZWFkbGluZSBwYXNzZWQgd2l0aG91dCBjb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlJykpO1xyXG4gICAgICAgICAgICB9LCBkZWFkbGluZURhdGUuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHdhdGNoZXJPYmplY3QgPSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSxcclxuICAgICAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgICAgIHRpbWVyLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLnB1c2god2F0Y2hlck9iamVjdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY2hhbm5lbHogcmVmZXJlbmNlIG9iamVjdCBmb3IgdGhpcyBjaGFubmVsLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXNcclxuICAgICAqIGdhcmJhZ2UgaWYgY2hhbm5lbHogaXMgZGlzYWJsZWQgZm9yIHRoaXMgY2hhbm5lbC5cclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGdldENoYW5uZWx6UmVmKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IG1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHR5cGVvZiBkZWFkbGluZSA9PT0gJ251bWJlcicgfHwgZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IGRlYWRsaW5lIG11c3QgYmUgYSBudW1iZXIgb3IgRGF0ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFubmVsIGhhcyBiZWVuIHNodXQgZG93bicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZXNvbHZpbmdDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkludGVybmFsQ2hhbm5lbCA9IEludGVybmFsQ2hhbm5lbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJuYWwtY2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2020 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ChildLoadBalancerHandler = void 0;\r\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst TYPE_NAME = 'child_load_balancer_helper';\r\nclass ChildLoadBalancerHandler {\r\n    constructor(channelControlHelper) {\r\n        this.channelControlHelper = channelControlHelper;\r\n        this.currentChild = null;\r\n        this.pendingChild = null;\r\n        this.latestConfig = null;\r\n        this.ChildPolicyHelper = class {\r\n            constructor(parent) {\r\n                this.parent = parent;\r\n                this.child = null;\r\n            }\r\n            createSubchannel(subchannelAddress, subchannelArgs) {\r\n                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\r\n            }\r\n            updateState(connectivityState, picker) {\r\n                var _a;\r\n                if (this.calledByPendingChild()) {\r\n                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {\r\n                        return;\r\n                    }\r\n                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\r\n                    this.parent.currentChild = this.parent.pendingChild;\r\n                    this.parent.pendingChild = null;\r\n                }\r\n                else if (!this.calledByCurrentChild()) {\r\n                    return;\r\n                }\r\n                this.parent.channelControlHelper.updateState(connectivityState, picker);\r\n            }\r\n            requestReresolution() {\r\n                var _a;\r\n                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\r\n                if (this.child === latestChild) {\r\n                    this.parent.channelControlHelper.requestReresolution();\r\n                }\r\n            }\r\n            setChild(newChild) {\r\n                this.child = newChild;\r\n            }\r\n            addChannelzChild(child) {\r\n                this.parent.channelControlHelper.addChannelzChild(child);\r\n            }\r\n            removeChannelzChild(child) {\r\n                this.parent.channelControlHelper.removeChannelzChild(child);\r\n            }\r\n            calledByPendingChild() {\r\n                return this.child === this.parent.pendingChild;\r\n            }\r\n            calledByCurrentChild() {\r\n                return this.child === this.parent.currentChild;\r\n            }\r\n        };\r\n    }\r\n    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {\r\n        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();\r\n    }\r\n    /**\r\n     * Prerequisites: lbConfig !== null and lbConfig.name is registered\r\n     * @param addressList\r\n     * @param lbConfig\r\n     * @param attributes\r\n     */\r\n    updateAddressList(addressList, lbConfig, attributes) {\r\n        let childToUpdate;\r\n        if (this.currentChild === null ||\r\n            this.latestConfig === null ||\r\n            this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {\r\n            const newHelper = new this.ChildPolicyHelper(this);\r\n            const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper);\r\n            newHelper.setChild(newChild);\r\n            if (this.currentChild === null) {\r\n                this.currentChild = newChild;\r\n                childToUpdate = this.currentChild;\r\n            }\r\n            else {\r\n                if (this.pendingChild) {\r\n                    this.pendingChild.destroy();\r\n                }\r\n                this.pendingChild = newChild;\r\n                childToUpdate = this.pendingChild;\r\n            }\r\n        }\r\n        else {\r\n            if (this.pendingChild === null) {\r\n                childToUpdate = this.currentChild;\r\n            }\r\n            else {\r\n                childToUpdate = this.pendingChild;\r\n            }\r\n        }\r\n        this.latestConfig = lbConfig;\r\n        childToUpdate.updateAddressList(addressList, lbConfig, attributes);\r\n    }\r\n    exitIdle() {\r\n        if (this.currentChild) {\r\n            this.currentChild.exitIdle();\r\n            if (this.pendingChild) {\r\n                this.pendingChild.exitIdle();\r\n            }\r\n        }\r\n    }\r\n    resetBackoff() {\r\n        if (this.currentChild) {\r\n            this.currentChild.resetBackoff();\r\n            if (this.pendingChild) {\r\n                this.pendingChild.resetBackoff();\r\n            }\r\n        }\r\n    }\r\n    destroy() {\r\n        /* Note: state updates are only propagated from the child balancer if that\r\n         * object is equal to this.currentChild or this.pendingChild. Since this\r\n         * function sets both of those to null, no further state updates will\r\n         * occur after this function returns. */\r\n        if (this.currentChild) {\r\n            this.currentChild.destroy();\r\n            this.currentChild = null;\r\n        }\r\n        if (this.pendingChild) {\r\n            this.pendingChild.destroy();\r\n            this.pendingChild = null;\r\n        }\r\n    }\r\n    getTypeName() {\r\n        return TYPE_NAME;\r\n    }\r\n}\r\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;\r\n//# sourceMappingURL=load-balancer-child-handler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDLHdCQUF3QixtQkFBTyxDQUFDLHNGQUFpQjtBQUNqRCw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzPzc3ODMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gdm9pZCAwO1xyXG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xyXG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcclxuY29uc3QgVFlQRV9OQU1FID0gJ2NoaWxkX2xvYWRfYmFsYW5jZXJfaGVscGVyJztcclxuY2xhc3MgQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xyXG4gICAgICAgIHRoaXMuY3VycmVudENoaWxkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuQ2hpbGRQb2xpY3lIZWxwZXIgPSBjbGFzcyB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsZWRCeVBlbmRpbmdDaGlsZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5wYXJlbnQuY3VycmVudENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmN1cnJlbnRDaGlsZCA9IHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY2FsbGVkQnlDdXJyZW50Q2hpbGQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3RDaGlsZCA9IChfYSA9IHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5wYXJlbnQuY3VycmVudENoaWxkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGQgPT09IGxhdGVzdENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldENoaWxkKG5ld0NoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkID0gbmV3Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkQ2hhbm5lbHpDaGlsZChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIuYWRkQ2hhbm5lbHpDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbGVkQnlQZW5kaW5nQ2hpbGQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZCA9PT0gdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxlZEJ5Q3VycmVudENoaWxkKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQgPT09IHRoaXMucGFyZW50LmN1cnJlbnRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25maWdVcGRhdGVSZXF1aXJlc05ld1BvbGljeUluc3RhbmNlKG9sZENvbmZpZywgbmV3Q29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIG9sZENvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCkgIT09IG5ld0NvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByZXJlcXVpc2l0ZXM6IGxiQ29uZmlnICE9PSBudWxsIGFuZCBsYkNvbmZpZy5uYW1lIGlzIHJlZ2lzdGVyZWRcclxuICAgICAqIEBwYXJhbSBhZGRyZXNzTGlzdFxyXG4gICAgICogQHBhcmFtIGxiQ29uZmlnXHJcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlc1xyXG4gICAgICovXHJcbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcsIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICBsZXQgY2hpbGRUb1VwZGF0ZTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgdGhpcy5jb25maWdVcGRhdGVSZXF1aXJlc05ld1BvbGljeUluc3RhbmNlKHRoaXMubGF0ZXN0Q29uZmlnLCBsYkNvbmZpZykpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3SGVscGVyID0gbmV3IHRoaXMuQ2hpbGRQb2xpY3lIZWxwZXIodGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gKDAsIGxvYWRfYmFsYW5jZXJfMS5jcmVhdGVMb2FkQmFsYW5jZXIpKGxiQ29uZmlnLCBuZXdIZWxwZXIpO1xyXG4gICAgICAgICAgICBuZXdIZWxwZXIuc2V0Q2hpbGQobmV3Q2hpbGQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkID0gbmV3Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5jdXJyZW50Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG5ld0NoaWxkO1xyXG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMucGVuZGluZ0NoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLmN1cnJlbnRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLnBlbmRpbmdDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IGxiQ29uZmlnO1xyXG4gICAgICAgIGNoaWxkVG9VcGRhdGUudXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxiQ29uZmlnLCBhdHRyaWJ1dGVzKTtcclxuICAgIH1cclxuICAgIGV4aXRJZGxlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5leGl0SWRsZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLmV4aXRJZGxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXNldEJhY2tvZmYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkLnJlc2V0QmFja29mZigpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLnJlc2V0QmFja29mZigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICAvKiBOb3RlOiBzdGF0ZSB1cGRhdGVzIGFyZSBvbmx5IHByb3BhZ2F0ZWQgZnJvbSB0aGUgY2hpbGQgYmFsYW5jZXIgaWYgdGhhdFxyXG4gICAgICAgICAqIG9iamVjdCBpcyBlcXVhbCB0byB0aGlzLmN1cnJlbnRDaGlsZCBvciB0aGlzLnBlbmRpbmdDaGlsZC4gU2luY2UgdGhpc1xyXG4gICAgICAgICAqIGZ1bmN0aW9uIHNldHMgYm90aCBvZiB0aG9zZSB0byBudWxsLCBubyBmdXJ0aGVyIHN0YXRlIHVwZGF0ZXMgd2lsbFxyXG4gICAgICAgICAqIG9jY3VyIGFmdGVyIHRoaXMgZnVuY3Rpb24gcmV0dXJucy4gKi9cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRUeXBlTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nvar _a;\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\r\nconst experimental_1 = __webpack_require__(/*! ./experimental */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\r\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\r\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst TRACER_NAME = 'outlier_detection';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nconst TYPE_NAME = 'outlier_detection';\r\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : 'true') === 'true';\r\nconst defaultSuccessRateEjectionConfig = {\r\n    stdev_factor: 1900,\r\n    enforcement_percentage: 100,\r\n    minimum_hosts: 5,\r\n    request_volume: 100,\r\n};\r\nconst defaultFailurePercentageEjectionConfig = {\r\n    threshold: 85,\r\n    enforcement_percentage: 100,\r\n    minimum_hosts: 5,\r\n    request_volume: 50,\r\n};\r\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\r\n    if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\r\n        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\r\n        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\r\n    }\r\n}\r\nfunction validatePositiveDuration(obj, fieldName, objectName) {\r\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\r\n    if (fieldName in obj) {\r\n        if (!(0, duration_1.isDuration)(obj[fieldName])) {\r\n            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\r\n        }\r\n        if (!(obj[fieldName].seconds >= 0 &&\r\n            obj[fieldName].seconds <= 315576000000 &&\r\n            obj[fieldName].nanos >= 0 &&\r\n            obj[fieldName].nanos <= 999999999)) {\r\n            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\r\n        }\r\n    }\r\n}\r\nfunction validatePercentage(obj, fieldName, objectName) {\r\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\r\n    validateFieldType(obj, fieldName, 'number', objectName);\r\n    if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\r\n        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\r\n    }\r\n}\r\nclass OutlierDetectionLoadBalancingConfig {\r\n    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {\r\n        this.childPolicy = childPolicy;\r\n        if (childPolicy.length > 0 &&\r\n            childPolicy[0].getLoadBalancerName() === 'pick_first') {\r\n            throw new Error('outlier_detection LB policy cannot have a pick_first child policy');\r\n        }\r\n        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\r\n        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\r\n        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\r\n        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\r\n        this.successRateEjection = successRateEjection\r\n            ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\r\n        this.failurePercentageEjection = failurePercentageEjection\r\n            ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\r\n    }\r\n    getLoadBalancerName() {\r\n        return TYPE_NAME;\r\n    }\r\n    toJsonObject() {\r\n        return {\r\n            interval: (0, duration_1.msToDuration)(this.intervalMs),\r\n            base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),\r\n            max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),\r\n            max_ejection_percent: this.maxEjectionPercent,\r\n            success_rate_ejection: this.successRateEjection,\r\n            failure_percentage_ejection: this.failurePercentageEjection,\r\n            child_policy: this.childPolicy.map(policy => policy.toJsonObject()),\r\n        };\r\n    }\r\n    getIntervalMs() {\r\n        return this.intervalMs;\r\n    }\r\n    getBaseEjectionTimeMs() {\r\n        return this.baseEjectionTimeMs;\r\n    }\r\n    getMaxEjectionTimeMs() {\r\n        return this.maxEjectionTimeMs;\r\n    }\r\n    getMaxEjectionPercent() {\r\n        return this.maxEjectionPercent;\r\n    }\r\n    getSuccessRateEjectionConfig() {\r\n        return this.successRateEjection;\r\n    }\r\n    getFailurePercentageEjectionConfig() {\r\n        return this.failurePercentageEjection;\r\n    }\r\n    getChildPolicy() {\r\n        return this.childPolicy;\r\n    }\r\n    copyWithChildPolicy(childPolicy) {\r\n        return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\r\n    }\r\n    static createFromJson(obj) {\r\n        var _a;\r\n        validatePositiveDuration(obj, 'interval');\r\n        validatePositiveDuration(obj, 'base_ejection_time');\r\n        validatePositiveDuration(obj, 'max_ejection_time');\r\n        validatePercentage(obj, 'max_ejection_percent');\r\n        if ('success_rate_ejection' in obj) {\r\n            if (typeof obj.success_rate_ejection !== 'object') {\r\n                throw new Error('outlier detection config success_rate_ejection must be an object');\r\n            }\r\n            validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\r\n            validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\r\n            validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\r\n            validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\r\n        }\r\n        if ('failure_percentage_ejection' in obj) {\r\n            if (typeof obj.failure_percentage_ejection !== 'object') {\r\n                throw new Error('outlier detection config failure_percentage_ejection must be an object');\r\n            }\r\n            validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\r\n            validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\r\n            validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\r\n            validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\r\n        }\r\n        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\r\n    }\r\n}\r\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\r\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\r\n    constructor(childSubchannel, mapEntry) {\r\n        super(childSubchannel);\r\n        this.mapEntry = mapEntry;\r\n        this.stateListeners = [];\r\n        this.ejected = false;\r\n        this.refCount = 0;\r\n        this.childSubchannelState = childSubchannel.getConnectivityState();\r\n        childSubchannel.addConnectivityStateListener((subchannel, previousState, newState, keepaliveTime) => {\r\n            this.childSubchannelState = newState;\r\n            if (!this.ejected) {\r\n                for (const listener of this.stateListeners) {\r\n                    listener(this, previousState, newState, keepaliveTime);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    getConnectivityState() {\r\n        if (this.ejected) {\r\n            return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\r\n        }\r\n        else {\r\n            return this.childSubchannelState;\r\n        }\r\n    }\r\n    /**\r\n     * Add a listener function to be called whenever the wrapper's\r\n     * connectivity state changes.\r\n     * @param listener\r\n     */\r\n    addConnectivityStateListener(listener) {\r\n        this.stateListeners.push(listener);\r\n    }\r\n    /**\r\n     * Remove a listener previously added with `addConnectivityStateListener`\r\n     * @param listener A reference to a function previously passed to\r\n     *     `addConnectivityStateListener`\r\n     */\r\n    removeConnectivityStateListener(listener) {\r\n        const listenerIndex = this.stateListeners.indexOf(listener);\r\n        if (listenerIndex > -1) {\r\n            this.stateListeners.splice(listenerIndex, 1);\r\n        }\r\n    }\r\n    ref() {\r\n        this.child.ref();\r\n        this.refCount += 1;\r\n    }\r\n    unref() {\r\n        this.child.unref();\r\n        this.refCount -= 1;\r\n        if (this.refCount <= 0) {\r\n            if (this.mapEntry) {\r\n                const index = this.mapEntry.subchannelWrappers.indexOf(this);\r\n                if (index >= 0) {\r\n                    this.mapEntry.subchannelWrappers.splice(index, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    eject() {\r\n        this.ejected = true;\r\n        for (const listener of this.stateListeners) {\r\n            listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, -1);\r\n        }\r\n    }\r\n    uneject() {\r\n        this.ejected = false;\r\n        for (const listener of this.stateListeners) {\r\n            listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState, -1);\r\n        }\r\n    }\r\n    getMapEntry() {\r\n        return this.mapEntry;\r\n    }\r\n    getWrappedSubchannel() {\r\n        return this.child;\r\n    }\r\n}\r\nfunction createEmptyBucket() {\r\n    return {\r\n        success: 0,\r\n        failure: 0,\r\n    };\r\n}\r\nclass CallCounter {\r\n    constructor() {\r\n        this.activeBucket = createEmptyBucket();\r\n        this.inactiveBucket = createEmptyBucket();\r\n    }\r\n    addSuccess() {\r\n        this.activeBucket.success += 1;\r\n    }\r\n    addFailure() {\r\n        this.activeBucket.failure += 1;\r\n    }\r\n    switchBuckets() {\r\n        this.inactiveBucket = this.activeBucket;\r\n        this.activeBucket = createEmptyBucket();\r\n    }\r\n    getLastSuccesses() {\r\n        return this.inactiveBucket.success;\r\n    }\r\n    getLastFailures() {\r\n        return this.inactiveBucket.failure;\r\n    }\r\n}\r\nclass OutlierDetectionPicker {\r\n    constructor(wrappedPicker, countCalls) {\r\n        this.wrappedPicker = wrappedPicker;\r\n        this.countCalls = countCalls;\r\n    }\r\n    pick(pickArgs) {\r\n        const wrappedPick = this.wrappedPicker.pick(pickArgs);\r\n        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\r\n            const subchannelWrapper = wrappedPick.subchannel;\r\n            const mapEntry = subchannelWrapper.getMapEntry();\r\n            if (mapEntry) {\r\n                let onCallEnded = wrappedPick.onCallEnded;\r\n                if (this.countCalls) {\r\n                    onCallEnded = statusCode => {\r\n                        var _a;\r\n                        if (statusCode === constants_1.Status.OK) {\r\n                            mapEntry.counter.addSuccess();\r\n                        }\r\n                        else {\r\n                            mapEntry.counter.addFailure();\r\n                        }\r\n                        (_a = wrappedPick.onCallEnded) === null || _a === void 0 ? void 0 : _a.call(wrappedPick, statusCode);\r\n                    };\r\n                }\r\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), onCallEnded: onCallEnded });\r\n            }\r\n            else {\r\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });\r\n            }\r\n        }\r\n        else {\r\n            return wrappedPick;\r\n        }\r\n    }\r\n}\r\nclass OutlierDetectionLoadBalancer {\r\n    constructor(channelControlHelper) {\r\n        this.addressMap = new Map();\r\n        this.latestConfig = null;\r\n        this.timerStartTime = null;\r\n        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {\r\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\r\n                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\r\n                const mapEntry = this.addressMap.get((0, subchannel_address_1.subchannelAddressToString)(subchannelAddress));\r\n                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\r\n                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\r\n                    // If the address is ejected, propagate that to the new subchannel wrapper\r\n                    subchannelWrapper.eject();\r\n                }\r\n                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\r\n                return subchannelWrapper;\r\n            },\r\n            updateState: (connectivityState, picker) => {\r\n                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\r\n                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));\r\n                }\r\n                else {\r\n                    channelControlHelper.updateState(connectivityState, picker);\r\n                }\r\n            },\r\n        }));\r\n        this.ejectionTimer = setInterval(() => { }, 0);\r\n        clearInterval(this.ejectionTimer);\r\n    }\r\n    isCountingEnabled() {\r\n        return (this.latestConfig !== null &&\r\n            (this.latestConfig.getSuccessRateEjectionConfig() !== null ||\r\n                this.latestConfig.getFailurePercentageEjectionConfig() !== null));\r\n    }\r\n    getCurrentEjectionPercent() {\r\n        let ejectionCount = 0;\r\n        for (const mapEntry of this.addressMap.values()) {\r\n            if (mapEntry.currentEjectionTimestamp !== null) {\r\n                ejectionCount += 1;\r\n            }\r\n        }\r\n        return (ejectionCount * 100) / this.addressMap.size;\r\n    }\r\n    runSuccessRateCheck(ejectionTimestamp) {\r\n        if (!this.latestConfig) {\r\n            return;\r\n        }\r\n        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\r\n        if (!successRateConfig) {\r\n            return;\r\n        }\r\n        trace('Running success rate check');\r\n        // Step 1\r\n        const targetRequestVolume = successRateConfig.request_volume;\r\n        let addresesWithTargetVolume = 0;\r\n        const successRates = [];\r\n        for (const [address, mapEntry] of this.addressMap) {\r\n            const successes = mapEntry.counter.getLastSuccesses();\r\n            const failures = mapEntry.counter.getLastFailures();\r\n            trace('Stats for ' +\r\n                address +\r\n                ': successes=' +\r\n                successes +\r\n                ' failures=' +\r\n                failures +\r\n                ' targetRequestVolume=' +\r\n                targetRequestVolume);\r\n            if (successes + failures >= targetRequestVolume) {\r\n                addresesWithTargetVolume += 1;\r\n                successRates.push(successes / (successes + failures));\r\n            }\r\n        }\r\n        trace('Found ' +\r\n            addresesWithTargetVolume +\r\n            ' success rate candidates; currentEjectionPercent=' +\r\n            this.getCurrentEjectionPercent() +\r\n            ' successRates=[' +\r\n            successRates +\r\n            ']');\r\n        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\r\n            return;\r\n        }\r\n        // Step 2\r\n        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;\r\n        let successRateDeviationSum = 0;\r\n        for (const rate of successRates) {\r\n            const deviation = rate - successRateMean;\r\n            successRateDeviationSum += deviation * deviation;\r\n        }\r\n        const successRateVariance = successRateDeviationSum / successRates.length;\r\n        const successRateStdev = Math.sqrt(successRateVariance);\r\n        const ejectionThreshold = successRateMean -\r\n            successRateStdev * (successRateConfig.stdev_factor / 1000);\r\n        trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);\r\n        // Step 3\r\n        for (const [address, mapEntry] of this.addressMap.entries()) {\r\n            // Step 3.i\r\n            if (this.getCurrentEjectionPercent() >=\r\n                this.latestConfig.getMaxEjectionPercent()) {\r\n                break;\r\n            }\r\n            // Step 3.ii\r\n            const successes = mapEntry.counter.getLastSuccesses();\r\n            const failures = mapEntry.counter.getLastFailures();\r\n            if (successes + failures < targetRequestVolume) {\r\n                continue;\r\n            }\r\n            // Step 3.iii\r\n            const successRate = successes / (successes + failures);\r\n            trace('Checking candidate ' + address + ' successRate=' + successRate);\r\n            if (successRate < ejectionThreshold) {\r\n                const randomNumber = Math.random() * 100;\r\n                trace('Candidate ' +\r\n                    address +\r\n                    ' randomNumber=' +\r\n                    randomNumber +\r\n                    ' enforcement_percentage=' +\r\n                    successRateConfig.enforcement_percentage);\r\n                if (randomNumber < successRateConfig.enforcement_percentage) {\r\n                    trace('Ejecting candidate ' + address);\r\n                    this.eject(mapEntry, ejectionTimestamp);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    runFailurePercentageCheck(ejectionTimestamp) {\r\n        if (!this.latestConfig) {\r\n            return;\r\n        }\r\n        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\r\n        if (!failurePercentageConfig) {\r\n            return;\r\n        }\r\n        trace('Running failure percentage check. threshold=' +\r\n            failurePercentageConfig.threshold +\r\n            ' request volume threshold=' +\r\n            failurePercentageConfig.request_volume);\r\n        // Step 1\r\n        let addressesWithTargetVolume = 0;\r\n        for (const mapEntry of this.addressMap.values()) {\r\n            const successes = mapEntry.counter.getLastSuccesses();\r\n            const failures = mapEntry.counter.getLastFailures();\r\n            if (successes + failures >= failurePercentageConfig.request_volume) {\r\n                addressesWithTargetVolume += 1;\r\n            }\r\n        }\r\n        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\r\n            return;\r\n        }\r\n        // Step 2\r\n        for (const [address, mapEntry] of this.addressMap.entries()) {\r\n            // Step 2.i\r\n            if (this.getCurrentEjectionPercent() >=\r\n                this.latestConfig.getMaxEjectionPercent()) {\r\n                break;\r\n            }\r\n            // Step 2.ii\r\n            const successes = mapEntry.counter.getLastSuccesses();\r\n            const failures = mapEntry.counter.getLastFailures();\r\n            trace('Candidate successes=' + successes + ' failures=' + failures);\r\n            if (successes + failures < failurePercentageConfig.request_volume) {\r\n                continue;\r\n            }\r\n            // Step 2.iii\r\n            const failurePercentage = (failures * 100) / (failures + successes);\r\n            if (failurePercentage > failurePercentageConfig.threshold) {\r\n                const randomNumber = Math.random() * 100;\r\n                trace('Candidate ' +\r\n                    address +\r\n                    ' randomNumber=' +\r\n                    randomNumber +\r\n                    ' enforcement_percentage=' +\r\n                    failurePercentageConfig.enforcement_percentage);\r\n                if (randomNumber < failurePercentageConfig.enforcement_percentage) {\r\n                    trace('Ejecting candidate ' + address);\r\n                    this.eject(mapEntry, ejectionTimestamp);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    eject(mapEntry, ejectionTimestamp) {\r\n        mapEntry.currentEjectionTimestamp = new Date();\r\n        mapEntry.ejectionTimeMultiplier += 1;\r\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\r\n            subchannelWrapper.eject();\r\n        }\r\n    }\r\n    uneject(mapEntry) {\r\n        mapEntry.currentEjectionTimestamp = null;\r\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\r\n            subchannelWrapper.uneject();\r\n        }\r\n    }\r\n    switchAllBuckets() {\r\n        for (const mapEntry of this.addressMap.values()) {\r\n            mapEntry.counter.switchBuckets();\r\n        }\r\n    }\r\n    startTimer(delayMs) {\r\n        var _a, _b;\r\n        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);\r\n        (_b = (_a = this.ejectionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    }\r\n    runChecks() {\r\n        const ejectionTimestamp = new Date();\r\n        trace('Ejection timer running');\r\n        this.switchAllBuckets();\r\n        if (!this.latestConfig) {\r\n            return;\r\n        }\r\n        this.timerStartTime = ejectionTimestamp;\r\n        this.startTimer(this.latestConfig.getIntervalMs());\r\n        this.runSuccessRateCheck(ejectionTimestamp);\r\n        this.runFailurePercentageCheck(ejectionTimestamp);\r\n        for (const [address, mapEntry] of this.addressMap.entries()) {\r\n            if (mapEntry.currentEjectionTimestamp === null) {\r\n                if (mapEntry.ejectionTimeMultiplier > 0) {\r\n                    mapEntry.ejectionTimeMultiplier -= 1;\r\n                }\r\n            }\r\n            else {\r\n                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\r\n                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\r\n                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\r\n                returnTime.setMilliseconds(returnTime.getMilliseconds() +\r\n                    Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\r\n                if (returnTime < new Date()) {\r\n                    trace('Unejecting ' + address);\r\n                    this.uneject(mapEntry);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    updateAddressList(addressList, lbConfig, attributes) {\r\n        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\r\n            return;\r\n        }\r\n        const subchannelAddresses = new Set();\r\n        for (const address of addressList) {\r\n            subchannelAddresses.add((0, subchannel_address_1.subchannelAddressToString)(address));\r\n        }\r\n        for (const address of subchannelAddresses) {\r\n            if (!this.addressMap.has(address)) {\r\n                trace('Adding map entry for ' + address);\r\n                this.addressMap.set(address, {\r\n                    counter: new CallCounter(),\r\n                    currentEjectionTimestamp: null,\r\n                    ejectionTimeMultiplier: 0,\r\n                    subchannelWrappers: [],\r\n                });\r\n            }\r\n        }\r\n        for (const key of this.addressMap.keys()) {\r\n            if (!subchannelAddresses.has(key)) {\r\n                trace('Removing map entry for ' + key);\r\n                this.addressMap.delete(key);\r\n            }\r\n        }\r\n        const childPolicy = (0, load_balancer_1.getFirstUsableConfig)(lbConfig.getChildPolicy(), true);\r\n        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\r\n        if (lbConfig.getSuccessRateEjectionConfig() ||\r\n            lbConfig.getFailurePercentageEjectionConfig()) {\r\n            if (this.timerStartTime) {\r\n                trace('Previous timer existed. Replacing timer');\r\n                clearTimeout(this.ejectionTimer);\r\n                const remainingDelay = lbConfig.getIntervalMs() -\r\n                    (new Date().getTime() - this.timerStartTime.getTime());\r\n                this.startTimer(remainingDelay);\r\n            }\r\n            else {\r\n                trace('Starting new timer');\r\n                this.timerStartTime = new Date();\r\n                this.startTimer(lbConfig.getIntervalMs());\r\n                this.switchAllBuckets();\r\n            }\r\n        }\r\n        else {\r\n            trace('Counting disabled. Cancelling timer.');\r\n            this.timerStartTime = null;\r\n            clearTimeout(this.ejectionTimer);\r\n            for (const mapEntry of this.addressMap.values()) {\r\n                this.uneject(mapEntry);\r\n                mapEntry.ejectionTimeMultiplier = 0;\r\n            }\r\n        }\r\n        this.latestConfig = lbConfig;\r\n    }\r\n    exitIdle() {\r\n        this.childBalancer.exitIdle();\r\n    }\r\n    resetBackoff() {\r\n        this.childBalancer.resetBackoff();\r\n    }\r\n    destroy() {\r\n        clearTimeout(this.ejectionTimer);\r\n        this.childBalancer.destroy();\r\n    }\r\n    getTypeName() {\r\n        return TYPE_NAME;\r\n    }\r\n}\r\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\r\nfunction setup() {\r\n    if (OUTLIER_DETECTION_ENABLED) {\r\n        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\r\n    }\r\n}\r\nexports.setup = setup;\r\n//# sourceMappingURL=load-balancer-outlier-detection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLG9DQUFvQyxHQUFHLDJDQUEyQztBQUNsRyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsdUJBQXVCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLHNGQUFpQjtBQUNqRCxzQ0FBc0MsbUJBQU8sQ0FBQyxrSEFBK0I7QUFDN0UsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELCtCQUErQixtQkFBTyxDQUFDLG9HQUF3QjtBQUMvRCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVcsR0FBRyxVQUFVO0FBQ3RFLG9EQUFvRCxlQUFlLHdCQUF3QixhQUFhLFFBQVEsc0JBQXNCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXLEdBQUcsVUFBVTtBQUNsRTtBQUNBO0FBQ0Esd0RBQXdELGVBQWUsc0NBQXNDLHNCQUFzQjtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGVBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVyxHQUFHLFVBQVU7QUFDbEU7QUFDQTtBQUNBLG9EQUFvRCxlQUFlO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0IsZ0ZBQWdGO0FBQ3ZKO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLHNEQUFzRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb24uanM/NDA4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbnZhciBfYTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnNldHVwID0gZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyID0gZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyA9IHZvaWQgMDtcclxuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBkdXJhdGlvbl8xID0gcmVxdWlyZShcIi4vZHVyYXRpb25cIik7XHJcbmNvbnN0IGV4cGVyaW1lbnRhbF8xID0gcmVxdWlyZShcIi4vZXhwZXJpbWVudGFsXCIpO1xyXG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xyXG5jb25zdCBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlclwiKTtcclxuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XHJcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xyXG5jb25zdCBzdWJjaGFubmVsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1pbnRlcmZhY2VcIik7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdvdXRsaWVyX2RldGVjdGlvbic7XHJcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcclxuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XHJcbn1cclxuY29uc3QgVFlQRV9OQU1FID0gJ291dGxpZXJfZGV0ZWN0aW9uJztcclxuY29uc3QgT1VUTElFUl9ERVRFQ1RJT05fRU5BQkxFRCA9ICgoX2EgPSBwcm9jZXNzLmVudi5HUlBDX0VYUEVSSU1FTlRBTF9FTkFCTEVfT1VUTElFUl9ERVRFQ1RJT04pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd0cnVlJykgPT09ICd0cnVlJztcclxuY29uc3QgZGVmYXVsdFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcgPSB7XHJcbiAgICBzdGRldl9mYWN0b3I6IDE5MDAsXHJcbiAgICBlbmZvcmNlbWVudF9wZXJjZW50YWdlOiAxMDAsXHJcbiAgICBtaW5pbXVtX2hvc3RzOiA1LFxyXG4gICAgcmVxdWVzdF92b2x1bWU6IDEwMCxcclxufTtcclxuY29uc3QgZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcgPSB7XHJcbiAgICB0aHJlc2hvbGQ6IDg1LFxyXG4gICAgZW5mb3JjZW1lbnRfcGVyY2VudGFnZTogMTAwLFxyXG4gICAgbWluaW11bV9ob3N0czogNSxcclxuICAgIHJlcXVlc3Rfdm9sdW1lOiA1MCxcclxufTtcclxuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsIGV4cGVjdGVkVHlwZSwgb2JqZWN0TmFtZSkge1xyXG4gICAgaWYgKGZpZWxkTmFtZSBpbiBvYmogJiYgdHlwZW9mIG9ialtmaWVsZE5hbWVdICE9PSBleHBlY3RlZFR5cGUpIHtcclxuICAgICAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogZXhwZWN0ZWQgJHtleHBlY3RlZFR5cGV9LCBnb3QgJHt0eXBlb2Ygb2JqW2ZpZWxkTmFtZV19YCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgZmllbGROYW1lLCBvYmplY3ROYW1lKSB7XHJcbiAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XHJcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaikge1xyXG4gICAgICAgIGlmICghKDAsIGR1cmF0aW9uXzEuaXNEdXJhdGlvbikob2JqW2ZpZWxkTmFtZV0pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IGV4cGVjdGVkIER1cmF0aW9uLCBnb3QgJHt0eXBlb2Ygb2JqW2ZpZWxkTmFtZV19YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKG9ialtmaWVsZE5hbWVdLnNlY29uZHMgPj0gMCAmJlxyXG4gICAgICAgICAgICBvYmpbZmllbGROYW1lXS5zZWNvbmRzIDw9IDMxNTU3NjAwMDAwMCAmJlxyXG4gICAgICAgICAgICBvYmpbZmllbGROYW1lXS5uYW5vcyA+PSAwICYmXHJcbiAgICAgICAgICAgIG9ialtmaWVsZE5hbWVdLm5hbm9zIDw9IDk5OTk5OTk5OSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogdmFsdWVzIG91dCBvZiByYW5nZSBmb3Igbm9uLW5lZ2F0aXZlIER1YXJhdGlvbmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCBmaWVsZE5hbWUsIG9iamVjdE5hbWUpIHtcclxuICAgIGNvbnN0IGZ1bGxGaWVsZE5hbWUgPSBvYmplY3ROYW1lID8gYCR7b2JqZWN0TmFtZX0uJHtmaWVsZE5hbWV9YCA6IGZpZWxkTmFtZTtcclxuICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iaiwgZmllbGROYW1lLCAnbnVtYmVyJywgb2JqZWN0TmFtZSk7XHJcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaiAmJiAhKG9ialtmaWVsZE5hbWVdID49IDAgJiYgb2JqW2ZpZWxkTmFtZV0gPD0gMTAwKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IHZhbHVlIG91dCBvZiByYW5nZSBmb3IgcGVyY2VudGFnZSAoMC0xMDApYCk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcge1xyXG4gICAgY29uc3RydWN0b3IoaW50ZXJ2YWxNcywgYmFzZUVqZWN0aW9uVGltZU1zLCBtYXhFamVjdGlvblRpbWVNcywgbWF4RWplY3Rpb25QZXJjZW50LCBzdWNjZXNzUmF0ZUVqZWN0aW9uLCBmYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uLCBjaGlsZFBvbGljeSkge1xyXG4gICAgICAgIHRoaXMuY2hpbGRQb2xpY3kgPSBjaGlsZFBvbGljeTtcclxuICAgICAgICBpZiAoY2hpbGRQb2xpY3kubGVuZ3RoID4gMCAmJlxyXG4gICAgICAgICAgICBjaGlsZFBvbGljeVswXS5nZXRMb2FkQmFsYW5jZXJOYW1lKCkgPT09ICdwaWNrX2ZpcnN0Jykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXJfZGV0ZWN0aW9uIExCIHBvbGljeSBjYW5ub3QgaGF2ZSBhIHBpY2tfZmlyc3QgY2hpbGQgcG9saWN5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWxNcyA9IGludGVydmFsTXMgIT09IG51bGwgJiYgaW50ZXJ2YWxNcyAhPT0gdm9pZCAwID8gaW50ZXJ2YWxNcyA6IDEwMDAwO1xyXG4gICAgICAgIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zID0gYmFzZUVqZWN0aW9uVGltZU1zICE9PSBudWxsICYmIGJhc2VFamVjdGlvblRpbWVNcyAhPT0gdm9pZCAwID8gYmFzZUVqZWN0aW9uVGltZU1zIDogMzAwMDA7XHJcbiAgICAgICAgdGhpcy5tYXhFamVjdGlvblRpbWVNcyA9IG1heEVqZWN0aW9uVGltZU1zICE9PSBudWxsICYmIG1heEVqZWN0aW9uVGltZU1zICE9PSB2b2lkIDAgPyBtYXhFamVjdGlvblRpbWVNcyA6IDMwMDAwMDtcclxuICAgICAgICB0aGlzLm1heEVqZWN0aW9uUGVyY2VudCA9IG1heEVqZWN0aW9uUGVyY2VudCAhPT0gbnVsbCAmJiBtYXhFamVjdGlvblBlcmNlbnQgIT09IHZvaWQgMCA/IG1heEVqZWN0aW9uUGVyY2VudCA6IDEwO1xyXG4gICAgICAgIHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbiA9IHN1Y2Nlc3NSYXRlRWplY3Rpb25cclxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKSwgc3VjY2Vzc1JhdGVFamVjdGlvbikgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiA9IGZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25cclxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKSwgZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbikgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xyXG4gICAgfVxyXG4gICAgdG9Kc29uT2JqZWN0KCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGludGVydmFsOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKHRoaXMuaW50ZXJ2YWxNcyksXHJcbiAgICAgICAgICAgIGJhc2VfZWplY3Rpb25fdGltZTogKDAsIGR1cmF0aW9uXzEubXNUb0R1cmF0aW9uKSh0aGlzLmJhc2VFamVjdGlvblRpbWVNcyksXHJcbiAgICAgICAgICAgIG1heF9lamVjdGlvbl90aW1lOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKHRoaXMubWF4RWplY3Rpb25UaW1lTXMpLFxyXG4gICAgICAgICAgICBtYXhfZWplY3Rpb25fcGVyY2VudDogdGhpcy5tYXhFamVjdGlvblBlcmNlbnQsXHJcbiAgICAgICAgICAgIHN1Y2Nlc3NfcmF0ZV9lamVjdGlvbjogdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uLFxyXG4gICAgICAgICAgICBmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb246IHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbixcclxuICAgICAgICAgICAgY2hpbGRfcG9saWN5OiB0aGlzLmNoaWxkUG9saWN5Lm1hcChwb2xpY3kgPT4gcG9saWN5LnRvSnNvbk9iamVjdCgpKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0SW50ZXJ2YWxNcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbE1zO1xyXG4gICAgfVxyXG4gICAgZ2V0QmFzZUVqZWN0aW9uVGltZU1zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VFamVjdGlvblRpbWVNcztcclxuICAgIH1cclxuICAgIGdldE1heEVqZWN0aW9uVGltZU1zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1heEVqZWN0aW9uVGltZU1zO1xyXG4gICAgfVxyXG4gICAgZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1heEVqZWN0aW9uUGVyY2VudDtcclxuICAgIH1cclxuICAgIGdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbjtcclxuICAgIH1cclxuICAgIGdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbjtcclxuICAgIH1cclxuICAgIGdldENoaWxkUG9saWN5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkUG9saWN5O1xyXG4gICAgfVxyXG4gICAgY29weVdpdGhDaGlsZFBvbGljeShjaGlsZFBvbGljeSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcodGhpcy5pbnRlcnZhbE1zLCB0aGlzLmJhc2VFamVjdGlvblRpbWVNcywgdGhpcy5tYXhFamVjdGlvblRpbWVNcywgdGhpcy5tYXhFamVjdGlvblBlcmNlbnQsIHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbiwgdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uLCBjaGlsZFBvbGljeSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlRnJvbUpzb24ob2JqKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdpbnRlcnZhbCcpO1xyXG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdiYXNlX2VqZWN0aW9uX3RpbWUnKTtcclxuICAgICAgICB2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24ob2JqLCAnbWF4X2VqZWN0aW9uX3RpbWUnKTtcclxuICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCAnbWF4X2VqZWN0aW9uX3BlcmNlbnQnKTtcclxuICAgICAgICBpZiAoJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0bGllciBkZXRlY3Rpb24gY29uZmlnIHN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdzdGRldl9mYWN0b3InLCAnbnVtYmVyJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xyXG4gICAgICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ2VuZm9yY2VtZW50X3BlcmNlbnRhZ2UnLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdtaW5pbXVtX2hvc3RzJywgJ251bWJlcicsICdzdWNjZXNzX3JhdGVfZWplY3Rpb24nKTtcclxuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ3JlcXVlc3Rfdm9sdW1lJywgJ251bWJlcicsICdzdWNjZXNzX3JhdGVfZWplY3Rpb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nIGluIG9iaikge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24gIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24gbXVzdCBiZSBhbiBvYmplY3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ3RocmVzaG9sZCcsICdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nKTtcclxuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICdlbmZvcmNlbWVudF9wZXJjZW50YWdlJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAnbWluaW11bV9ob3N0cycsICdudW1iZXInLCAnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICdyZXF1ZXN0X3ZvbHVtZScsICdudW1iZXInLCAnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcob2JqLmludGVydmFsID8gKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zKShvYmouaW50ZXJ2YWwpIDogbnVsbCwgb2JqLmJhc2VfZWplY3Rpb25fdGltZSA/ICgwLCBkdXJhdGlvbl8xLmR1cmF0aW9uVG9Ncykob2JqLmJhc2VfZWplY3Rpb25fdGltZSkgOiBudWxsLCBvYmoubWF4X2VqZWN0aW9uX3RpbWUgPyAoMCwgZHVyYXRpb25fMS5kdXJhdGlvblRvTXMpKG9iai5tYXhfZWplY3Rpb25fdGltZSkgOiBudWxsLCAoX2EgPSBvYmoubWF4X2VqZWN0aW9uX3BlcmNlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsIG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sIG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sIG9iai5jaGlsZF9wb2xpY3kubWFwKGxvYWRfYmFsYW5jZXJfMS52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnID0gT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWc7XHJcbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25TdWJjaGFubmVsV3JhcHBlciBleHRlbmRzIHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEuQmFzZVN1YmNoYW5uZWxXcmFwcGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNoaWxkU3ViY2hhbm5lbCwgbWFwRW50cnkpIHtcclxuICAgICAgICBzdXBlcihjaGlsZFN1YmNoYW5uZWwpO1xyXG4gICAgICAgIHRoaXMubWFwRW50cnkgPSBtYXBFbnRyeTtcclxuICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5lamVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZWZDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZSA9IGNoaWxkU3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xyXG4gICAgICAgIGNoaWxkU3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKChzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwga2VlcGFsaXZlVGltZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlID0gbmV3U3RhdGU7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5lamVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcih0aGlzLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwga2VlcGFsaXZlVGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVqZWN0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHdyYXBwZXInc1xyXG4gICAgICogY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZXMuXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIHByZXZpb3VzbHkgYWRkZWQgd2l0aCBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBBIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIHByZXZpb3VzbHkgcGFzc2VkIHRvXHJcbiAgICAgKiAgICAgYGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXJgXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICBjb25zdCBsaXN0ZW5lckluZGV4ID0gdGhpcy5zdGF0ZUxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICBpZiAobGlzdGVuZXJJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuc3BsaWNlKGxpc3RlbmVySW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZigpIHtcclxuICAgICAgICB0aGlzLmNoaWxkLnJlZigpO1xyXG4gICAgICAgIHRoaXMucmVmQ291bnQgKz0gMTtcclxuICAgIH1cclxuICAgIHVucmVmKCkge1xyXG4gICAgICAgIHRoaXMuY2hpbGQudW5yZWYoKTtcclxuICAgICAgICB0aGlzLnJlZkNvdW50IC09IDE7XHJcbiAgICAgICAgaWYgKHRoaXMucmVmQ291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXBFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWplY3QoKSB7XHJcbiAgICAgICAgdGhpcy5lamVjdGVkID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1bmVqZWN0KCkge1xyXG4gICAgICAgIHRoaXMuZWplY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZUxpc3RlbmVycykge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcih0aGlzLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZSwgLTEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE1hcEVudHJ5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcEVudHJ5O1xyXG4gICAgfVxyXG4gICAgZ2V0V3JhcHBlZFN1YmNoYW5uZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRW1wdHlCdWNrZXQoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IDAsXHJcbiAgICAgICAgZmFpbHVyZTogMCxcclxuICAgIH07XHJcbn1cclxuY2xhc3MgQ2FsbENvdW50ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVCdWNrZXQgPSBjcmVhdGVFbXB0eUJ1Y2tldCgpO1xyXG4gICAgICAgIHRoaXMuaW5hY3RpdmVCdWNrZXQgPSBjcmVhdGVFbXB0eUJ1Y2tldCgpO1xyXG4gICAgfVxyXG4gICAgYWRkU3VjY2VzcygpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldC5zdWNjZXNzICs9IDE7XHJcbiAgICB9XHJcbiAgICBhZGRGYWlsdXJlKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0LmZhaWx1cmUgKz0gMTtcclxuICAgIH1cclxuICAgIHN3aXRjaEJ1Y2tldHMoKSB7XHJcbiAgICAgICAgdGhpcy5pbmFjdGl2ZUJ1Y2tldCA9IHRoaXMuYWN0aXZlQnVja2V0O1xyXG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0ID0gY3JlYXRlRW1wdHlCdWNrZXQoKTtcclxuICAgIH1cclxuICAgIGdldExhc3RTdWNjZXNzZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5hY3RpdmVCdWNrZXQuc3VjY2VzcztcclxuICAgIH1cclxuICAgIGdldExhc3RGYWlsdXJlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmFjdGl2ZUJ1Y2tldC5mYWlsdXJlO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25QaWNrZXIge1xyXG4gICAgY29uc3RydWN0b3Iod3JhcHBlZFBpY2tlciwgY291bnRDYWxscykge1xyXG4gICAgICAgIHRoaXMud3JhcHBlZFBpY2tlciA9IHdyYXBwZWRQaWNrZXI7XHJcbiAgICAgICAgdGhpcy5jb3VudENhbGxzID0gY291bnRDYWxscztcclxuICAgIH1cclxuICAgIHBpY2socGlja0FyZ3MpIHtcclxuICAgICAgICBjb25zdCB3cmFwcGVkUGljayA9IHRoaXMud3JhcHBlZFBpY2tlci5waWNrKHBpY2tBcmdzKTtcclxuICAgICAgICBpZiAod3JhcHBlZFBpY2sucGlja1Jlc3VsdFR5cGUgPT09IHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkNPTVBMRVRFKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyID0gd3JhcHBlZFBpY2suc3ViY2hhbm5lbDtcclxuICAgICAgICAgICAgY29uc3QgbWFwRW50cnkgPSBzdWJjaGFubmVsV3JhcHBlci5nZXRNYXBFbnRyeSgpO1xyXG4gICAgICAgICAgICBpZiAobWFwRW50cnkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBvbkNhbGxFbmRlZCA9IHdyYXBwZWRQaWNrLm9uQ2FsbEVuZGVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnRDYWxscykge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2FsbEVuZGVkID0gc3RhdHVzQ29kZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwRW50cnkuY291bnRlci5hZGRTdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBFbnRyeS5jb3VudGVyLmFkZEZhaWx1cmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB3cmFwcGVkUGljay5vbkNhbGxFbmRlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwod3JhcHBlZFBpY2ssIHN0YXR1c0NvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cmFwcGVkUGljayksIHsgc3ViY2hhbm5lbDogc3ViY2hhbm5lbFdyYXBwZXIuZ2V0V3JhcHBlZFN1YmNoYW5uZWwoKSwgb25DYWxsRW5kZWQ6IG9uQ2FsbEVuZGVkIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd3JhcHBlZFBpY2spLCB7IHN1YmNoYW5uZWw6IHN1YmNoYW5uZWxXcmFwcGVyLmdldFdyYXBwZWRTdWJjaGFubmVsKCkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVkUGljaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xyXG4gICAgICAgIHRoaXMuYWRkcmVzc01hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50aW1lclN0YXJ0VGltZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyID0gbmV3IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlcigoMCwgZXhwZXJpbWVudGFsXzEuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcikoY2hhbm5lbENvbnRyb2xIZWxwZXIsIHtcclxuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdWJjaGFubmVsID0gY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWFwRW50cnkgPSB0aGlzLmFkZHJlc3NNYXAuZ2V0KCgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShzdWJjaGFubmVsQWRkcmVzcykpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgPSBuZXcgT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyKG9yaWdpbmFsU3ViY2hhbm5lbCwgbWFwRW50cnkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChtYXBFbnRyeSA9PT0gbnVsbCB8fCBtYXBFbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhZGRyZXNzIGlzIGVqZWN0ZWQsIHByb3BhZ2F0ZSB0aGF0IHRvIHRoZSBuZXcgc3ViY2hhbm5lbCB3cmFwcGVyXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIuZWplY3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1hcEVudHJ5ID09PSBudWxsIHx8IG1hcEVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMucHVzaChzdWJjaGFubmVsV3JhcHBlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViY2hhbm5lbFdyYXBwZXI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBuZXcgT3V0bGllckRldGVjdGlvblBpY2tlcihwaWNrZXIsIHRoaXMuaXNDb3VudGluZ0VuYWJsZWQoKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuZWplY3Rpb25UaW1lciA9IHNldEludGVydmFsKCgpID0+IHsgfSwgMCk7XHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmVqZWN0aW9uVGltZXIpO1xyXG4gICAgfVxyXG4gICAgaXNDb3VudGluZ0VuYWJsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxhdGVzdENvbmZpZyAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAodGhpcy5sYXRlc3RDb25maWcuZ2V0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZygpICE9PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENvbmZpZy5nZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKCkgIT09IG51bGwpKTtcclxuICAgIH1cclxuICAgIGdldEN1cnJlbnRFamVjdGlvblBlcmNlbnQoKSB7XHJcbiAgICAgICAgbGV0IGVqZWN0aW9uQ291bnQgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGVqZWN0aW9uQ291bnQgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGVqZWN0aW9uQ291bnQgKiAxMDApIC8gdGhpcy5hZGRyZXNzTWFwLnNpemU7XHJcbiAgICB9XHJcbiAgICBydW5TdWNjZXNzUmF0ZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENvbmZpZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlQ29uZmlnID0gdGhpcy5sYXRlc3RDb25maWcuZ2V0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZygpO1xyXG4gICAgICAgIGlmICghc3VjY2Vzc1JhdGVDb25maWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFjZSgnUnVubmluZyBzdWNjZXNzIHJhdGUgY2hlY2snKTtcclxuICAgICAgICAvLyBTdGVwIDFcclxuICAgICAgICBjb25zdCB0YXJnZXRSZXF1ZXN0Vm9sdW1lID0gc3VjY2Vzc1JhdGVDb25maWcucmVxdWVzdF92b2x1bWU7XHJcbiAgICAgICAgbGV0IGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSA9IDA7XHJcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgbWFwRW50cnldIG9mIHRoaXMuYWRkcmVzc01hcCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcclxuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RGYWlsdXJlcygpO1xyXG4gICAgICAgICAgICB0cmFjZSgnU3RhdHMgZm9yICcgK1xyXG4gICAgICAgICAgICAgICAgYWRkcmVzcyArXHJcbiAgICAgICAgICAgICAgICAnOiBzdWNjZXNzZXM9JyArXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzZXMgK1xyXG4gICAgICAgICAgICAgICAgJyBmYWlsdXJlcz0nICtcclxuICAgICAgICAgICAgICAgIGZhaWx1cmVzICtcclxuICAgICAgICAgICAgICAgICcgdGFyZ2V0UmVxdWVzdFZvbHVtZT0nICtcclxuICAgICAgICAgICAgICAgIHRhcmdldFJlcXVlc3RWb2x1bWUpO1xyXG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPj0gdGFyZ2V0UmVxdWVzdFZvbHVtZSkge1xyXG4gICAgICAgICAgICAgICAgYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lICs9IDE7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZXMucHVzaChzdWNjZXNzZXMgLyAoc3VjY2Vzc2VzICsgZmFpbHVyZXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFjZSgnRm91bmQgJyArXHJcbiAgICAgICAgICAgIGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSArXHJcbiAgICAgICAgICAgICcgc3VjY2VzcyByYXRlIGNhbmRpZGF0ZXM7IGN1cnJlbnRFamVjdGlvblBlcmNlbnQ9JyArXHJcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpICtcclxuICAgICAgICAgICAgJyBzdWNjZXNzUmF0ZXM9WycgK1xyXG4gICAgICAgICAgICBzdWNjZXNzUmF0ZXMgK1xyXG4gICAgICAgICAgICAnXScpO1xyXG4gICAgICAgIGlmIChhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgPCBzdWNjZXNzUmF0ZUNvbmZpZy5taW5pbXVtX2hvc3RzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3RlcCAyXHJcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVNZWFuID0gc3VjY2Vzc1JhdGVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8gc3VjY2Vzc1JhdGVzLmxlbmd0aDtcclxuICAgICAgICBsZXQgc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgcmF0ZSBvZiBzdWNjZXNzUmF0ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgZGV2aWF0aW9uID0gcmF0ZSAtIHN1Y2Nlc3NSYXRlTWVhbjtcclxuICAgICAgICAgICAgc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gKz0gZGV2aWF0aW9uICogZGV2aWF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZVZhcmlhbmNlID0gc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gLyBzdWNjZXNzUmF0ZXMubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlU3RkZXYgPSBNYXRoLnNxcnQoc3VjY2Vzc1JhdGVWYXJpYW5jZSk7XHJcbiAgICAgICAgY29uc3QgZWplY3Rpb25UaHJlc2hvbGQgPSBzdWNjZXNzUmF0ZU1lYW4gLVxyXG4gICAgICAgICAgICBzdWNjZXNzUmF0ZVN0ZGV2ICogKHN1Y2Nlc3NSYXRlQ29uZmlnLnN0ZGV2X2ZhY3RvciAvIDEwMDApO1xyXG4gICAgICAgIHRyYWNlKCdzdGRldj0nICsgc3VjY2Vzc1JhdGVTdGRldiArICcgZWplY3Rpb25UaHJlc2hvbGQ9JyArIGVqZWN0aW9uVGhyZXNob2xkKTtcclxuICAgICAgICAvLyBTdGVwIDNcclxuICAgICAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBtYXBFbnRyeV0gb2YgdGhpcy5hZGRyZXNzTWFwLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICAvLyBTdGVwIDMuaVxyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkgPj1cclxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnLmdldE1heEVqZWN0aW9uUGVyY2VudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdGVwIDMuaWlcclxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcclxuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzIDwgdGFyZ2V0UmVxdWVzdFZvbHVtZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3RlcCAzLmlpaVxyXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZSA9IHN1Y2Nlc3NlcyAvIChzdWNjZXNzZXMgKyBmYWlsdXJlcyk7XHJcbiAgICAgICAgICAgIHRyYWNlKCdDaGVja2luZyBjYW5kaWRhdGUgJyArIGFkZHJlc3MgKyAnIHN1Y2Nlc3NSYXRlPScgKyBzdWNjZXNzUmF0ZSk7XHJcbiAgICAgICAgICAgIGlmIChzdWNjZXNzUmF0ZSA8IGVqZWN0aW9uVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xyXG4gICAgICAgICAgICAgICAgdHJhY2UoJ0NhbmRpZGF0ZSAnICtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzICtcclxuICAgICAgICAgICAgICAgICAgICAnIHJhbmRvbU51bWJlcj0nICtcclxuICAgICAgICAgICAgICAgICAgICByYW5kb21OdW1iZXIgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgZW5mb3JjZW1lbnRfcGVyY2VudGFnZT0nICtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyYW5kb21OdW1iZXIgPCBzdWNjZXNzUmF0ZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ0VqZWN0aW5nIGNhbmRpZGF0ZSAnICsgYWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcnVuRmFpbHVyZVBlcmNlbnRhZ2VDaGVjayhlamVjdGlvblRpbWVzdGFtcCkge1xyXG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDb25maWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKTtcclxuICAgICAgICBpZiAoIWZhaWx1cmVQZXJjZW50YWdlQ29uZmlnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2UoJ1J1bm5pbmcgZmFpbHVyZSBwZXJjZW50YWdlIGNoZWNrLiB0aHJlc2hvbGQ9JyArXHJcbiAgICAgICAgICAgIGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnRocmVzaG9sZCArXHJcbiAgICAgICAgICAgICcgcmVxdWVzdCB2b2x1bWUgdGhyZXNob2xkPScgK1xyXG4gICAgICAgICAgICBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZSk7XHJcbiAgICAgICAgLy8gU3RlcCAxXHJcbiAgICAgICAgbGV0IGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdFN1Y2Nlc3NlcygpO1xyXG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XHJcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyBmYWlsdXJlcyA+PSBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZSkge1xyXG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzV2l0aFRhcmdldFZvbHVtZSArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGRyZXNzZXNXaXRoVGFyZ2V0Vm9sdW1lIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcubWluaW11bV9ob3N0cykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFN0ZXAgMlxyXG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIC8vIFN0ZXAgMi5pXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEN1cnJlbnRFamVjdGlvblBlcmNlbnQoKSA+PVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFN0ZXAgMi5paVxyXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcclxuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RGYWlsdXJlcygpO1xyXG4gICAgICAgICAgICB0cmFjZSgnQ2FuZGlkYXRlIHN1Y2Nlc3Nlcz0nICsgc3VjY2Vzc2VzICsgJyBmYWlsdXJlcz0nICsgZmFpbHVyZXMpO1xyXG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3RlcCAyLmlpaVxyXG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlUGVyY2VudGFnZSA9IChmYWlsdXJlcyAqIDEwMCkgLyAoZmFpbHVyZXMgKyBzdWNjZXNzZXMpO1xyXG4gICAgICAgICAgICBpZiAoZmFpbHVyZVBlcmNlbnRhZ2UgPiBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy50aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmRvbU51bWJlciA9IE1hdGgucmFuZG9tKCkgKiAxMDA7XHJcbiAgICAgICAgICAgICAgICB0cmFjZSgnQ2FuZGlkYXRlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgcmFuZG9tTnVtYmVyPScgK1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmRvbU51bWJlciArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBlbmZvcmNlbWVudF9wZXJjZW50YWdlPScgK1xyXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLmVuZm9yY2VtZW50X3BlcmNlbnRhZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhbmRvbU51bWJlciA8IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLmVuZm9yY2VtZW50X3BlcmNlbnRhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRWplY3RpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVqZWN0KG1hcEVudHJ5LCBlamVjdGlvblRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApIHtcclxuICAgICAgICBtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgKz0gMTtcclxuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyIG9mIG1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycykge1xyXG4gICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlci5lamVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVuZWplY3QobWFwRW50cnkpIHtcclxuICAgICAgICBtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgb2YgbWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzKSB7XHJcbiAgICAgICAgICAgIHN1YmNoYW5uZWxXcmFwcGVyLnVuZWplY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzd2l0Y2hBbGxCdWNrZXRzKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuc3dpdGNoQnVja2V0cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0VGltZXIoZGVsYXlNcykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdGhpcy5lamVjdGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnJ1bkNoZWNrcygpLCBkZWxheU1zKTtcclxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmVqZWN0aW9uVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICB9XHJcbiAgICBydW5DaGVja3MoKSB7XHJcbiAgICAgICAgY29uc3QgZWplY3Rpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHRyYWNlKCdFamVjdGlvbiB0aW1lciBydW5uaW5nJyk7XHJcbiAgICAgICAgdGhpcy5zd2l0Y2hBbGxCdWNrZXRzKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENvbmZpZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBlamVjdGlvblRpbWVzdGFtcDtcclxuICAgICAgICB0aGlzLnN0YXJ0VGltZXIodGhpcy5sYXRlc3RDb25maWcuZ2V0SW50ZXJ2YWxNcygpKTtcclxuICAgICAgICB0aGlzLnJ1blN1Y2Nlc3NSYXRlQ2hlY2soZWplY3Rpb25UaW1lc3RhbXApO1xyXG4gICAgICAgIHRoaXMucnVuRmFpbHVyZVBlcmNlbnRhZ2VDaGVjayhlamVjdGlvblRpbWVzdGFtcCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgbWFwRW50cnldIG9mIHRoaXMuYWRkcmVzc01hcC5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgaWYgKG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciAtPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUVqZWN0aW9uVGltZU1zID0gdGhpcy5sYXRlc3RDb25maWcuZ2V0QmFzZUVqZWN0aW9uVGltZU1zKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhFamVjdGlvblRpbWVNcyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldE1heEVqZWN0aW9uVGltZU1zKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5UaW1lID0gbmV3IERhdGUobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wLmdldFRpbWUoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5UaW1lLnNldE1pbGxpc2Vjb25kcyhyZXR1cm5UaW1lLmdldE1pbGxpc2Vjb25kcygpICtcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihiYXNlRWplY3Rpb25UaW1lTXMgKiBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyLCBNYXRoLm1heChiYXNlRWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uVGltZU1zKSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblRpbWUgPCBuZXcgRGF0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ1VuZWplY3RpbmcgJyArIGFkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5lamVjdChtYXBFbnRyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcsIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICBpZiAoIShsYkNvbmZpZyBpbnN0YW5jZW9mIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWxBZGRyZXNzZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGFkZHJlc3NMaXN0KSB7XHJcbiAgICAgICAgICAgIHN1YmNoYW5uZWxBZGRyZXNzZXMuYWRkKCgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBzdWJjaGFubmVsQWRkcmVzc2VzKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5hZGRyZXNzTWFwLmhhcyhhZGRyZXNzKSkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2UoJ0FkZGluZyBtYXAgZW50cnkgZm9yICcgKyBhZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkcmVzc01hcC5zZXQoYWRkcmVzcywge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXI6IG5ldyBDYWxsQ291bnRlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFamVjdGlvblRpbWVzdGFtcDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBlamVjdGlvblRpbWVNdWx0aXBsaWVyOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxXcmFwcGVyczogW10sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmFkZHJlc3NNYXAua2V5cygpKSB7XHJcbiAgICAgICAgICAgIGlmICghc3ViY2hhbm5lbEFkZHJlc3Nlcy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2UoJ1JlbW92aW5nIG1hcCBlbnRyeSBmb3IgJyArIGtleSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZHJlc3NNYXAuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hpbGRQb2xpY3kgPSAoMCwgbG9hZF9iYWxhbmNlcl8xLmdldEZpcnN0VXNhYmxlQ29uZmlnKShsYkNvbmZpZy5nZXRDaGlsZFBvbGljeSgpLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGNoaWxkUG9saWN5LCBhdHRyaWJ1dGVzKTtcclxuICAgICAgICBpZiAobGJDb25maWcuZ2V0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZygpIHx8XHJcbiAgICAgICAgICAgIGxiQ29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lclN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2UoJ1ByZXZpb3VzIHRpbWVyIGV4aXN0ZWQuIFJlcGxhY2luZyB0aW1lcicpO1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdEZWxheSA9IGxiQ29uZmlnLmdldEludGVydmFsTXMoKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy50aW1lclN0YXJ0VGltZS5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKHJlbWFpbmluZ0RlbGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyYWNlKCdTdGFydGluZyBuZXcgdGltZXInKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKGxiQ29uZmlnLmdldEludGVydmFsTXMoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaEFsbEJ1Y2tldHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJhY2UoJ0NvdW50aW5nIGRpc2FibGVkLiBDYW5jZWxsaW5nIHRpbWVyLicpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVyU3RhcnRUaW1lID0gbnVsbDtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuZWplY3QobWFwRW50cnkpO1xyXG4gICAgICAgICAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBsYkNvbmZpZztcclxuICAgIH1cclxuICAgIGV4aXRJZGxlKCkge1xyXG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5leGl0SWRsZSgpO1xyXG4gICAgfVxyXG4gICAgcmVzZXRCYWNrb2ZmKCkge1xyXG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5yZXNldEJhY2tvZmYoKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XHJcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIGdldFR5cGVOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyID0gT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlcjtcclxuZnVuY3Rpb24gc2V0dXAoKSB7XHJcbiAgICBpZiAoT1VUTElFUl9ERVRFQ1RJT05fRU5BQkxFRCkge1xyXG4gICAgICAgICgwLCBleHBlcmltZW50YWxfMS5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUpKFRZUEVfTkFNRSwgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciwgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.setup = exports.PickFirstLoadBalancer = exports.shuffled = exports.PickFirstLoadBalancingConfig = void 0;\r\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst TRACER_NAME = 'pick_first';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nconst TYPE_NAME = 'pick_first';\r\n/**\r\n * Delay after starting a connection on a subchannel before starting a\r\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\r\n */\r\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\r\nclass PickFirstLoadBalancingConfig {\r\n    constructor(shuffleAddressList) {\r\n        this.shuffleAddressList = shuffleAddressList;\r\n    }\r\n    getLoadBalancerName() {\r\n        return TYPE_NAME;\r\n    }\r\n    toJsonObject() {\r\n        return {\r\n            [TYPE_NAME]: {\r\n                shuffleAddressList: this.shuffleAddressList,\r\n            },\r\n        };\r\n    }\r\n    getShuffleAddressList() {\r\n        return this.shuffleAddressList;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    static createFromJson(obj) {\r\n        if ('shuffleAddressList' in obj &&\r\n            !(typeof obj.shuffleAddressList === 'boolean')) {\r\n            throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');\r\n        }\r\n        return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\r\n    }\r\n}\r\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\r\n/**\r\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\r\n * picked subchannel.\r\n */\r\nclass PickFirstPicker {\r\n    constructor(subchannel) {\r\n        this.subchannel = subchannel;\r\n    }\r\n    pick(pickArgs) {\r\n        return {\r\n            pickResultType: picker_1.PickResultType.COMPLETE,\r\n            subchannel: this.subchannel,\r\n            status: null,\r\n            onCallStarted: null,\r\n            onCallEnded: null,\r\n        };\r\n    }\r\n}\r\n/**\r\n * Return a new array with the elements of the input array in a random order\r\n * @param list The input array\r\n * @returns A shuffled array of the elements of list\r\n */\r\nfunction shuffled(list) {\r\n    const result = list.slice();\r\n    for (let i = result.length - 1; i > 1; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        const temp = result[i];\r\n        result[i] = result[j];\r\n        result[j] = temp;\r\n    }\r\n    return result;\r\n}\r\nexports.shuffled = shuffled;\r\nclass PickFirstLoadBalancer {\r\n    /**\r\n     * Load balancer that attempts to connect to each backend in the address list\r\n     * in order, and picks the first one that connects, using it for every\r\n     * request.\r\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\r\n     *     this load balancer's owner.\r\n     */\r\n    constructor(channelControlHelper) {\r\n        this.channelControlHelper = channelControlHelper;\r\n        /**\r\n         * The list of subchannels this load balancer is currently attempting to\r\n         * connect to.\r\n         */\r\n        this.children = [];\r\n        /**\r\n         * The current connectivity state of the load balancer.\r\n         */\r\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\r\n        /**\r\n         * The index within the `subchannels` array of the subchannel with the most\r\n         * recently started connection attempt.\r\n         */\r\n        this.currentSubchannelIndex = 0;\r\n        /**\r\n         * The currently picked subchannel used for making calls. Populated if\r\n         * and only if the load balancer's current state is READY. In that case,\r\n         * the subchannel's current state is also READY.\r\n         */\r\n        this.currentPick = null;\r\n        /**\r\n         * Listener callback attached to each subchannel in the `subchannels` list\r\n         * while establishing a connection.\r\n         */\r\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {\r\n            this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);\r\n        };\r\n        this.triedAllSubchannels = false;\r\n        /**\r\n         * The LB policy enters sticky TRANSIENT_FAILURE mode when all\r\n         * subchannels have failed to connect at least once, and it stays in that\r\n         * mode until a connection attempt is successful. While in sticky TF mode,\r\n         * the LB policy continuously attempts to connect to all of its subchannels.\r\n         */\r\n        this.stickyTransientFailureMode = false;\r\n        /**\r\n         * Indicates whether we called channelControlHelper.requestReresolution since\r\n         * the last call to updateAddressList\r\n         */\r\n        this.requestedResolutionSinceLastUpdate = false;\r\n        /**\r\n         * The most recent error reported by any subchannel as it transitioned to\r\n         * TRANSIENT_FAILURE.\r\n         */\r\n        this.lastError = null;\r\n        this.latestAddressList = null;\r\n        this.connectionDelayTimeout = setTimeout(() => { }, 0);\r\n        clearTimeout(this.connectionDelayTimeout);\r\n    }\r\n    allChildrenHaveReportedTF() {\r\n        return this.children.every(child => child.hasReportedTransientFailure);\r\n    }\r\n    calculateAndReportNewState() {\r\n        if (this.currentPick) {\r\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));\r\n        }\r\n        else if (this.children.length === 0) {\r\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\r\n        }\r\n        else {\r\n            if (this.stickyTransientFailureMode) {\r\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({ details: `No connection established. Last error: ${this.lastError}` }));\r\n            }\r\n            else {\r\n                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\r\n            }\r\n        }\r\n    }\r\n    requestReresolution() {\r\n        this.requestedResolutionSinceLastUpdate = true;\r\n        this.channelControlHelper.requestReresolution();\r\n    }\r\n    maybeEnterStickyTransientFailureMode() {\r\n        if (!this.allChildrenHaveReportedTF()) {\r\n            return;\r\n        }\r\n        if (!this.requestedResolutionSinceLastUpdate) {\r\n            /* Each time we get an update we reset each subchannel's\r\n             * hasReportedTransientFailure flag, so the next time we get to this\r\n             * point after that, each subchannel has reported TRANSIENT_FAILURE\r\n             * at least once since then. That is the trigger for requesting\r\n             * reresolution, whether or not the LB policy is already in sticky TF\r\n             * mode. */\r\n            this.requestReresolution();\r\n        }\r\n        if (this.stickyTransientFailureMode) {\r\n            return;\r\n        }\r\n        this.stickyTransientFailureMode = true;\r\n        for (const { subchannel } of this.children) {\r\n            subchannel.startConnecting();\r\n        }\r\n        this.calculateAndReportNewState();\r\n    }\r\n    removeCurrentPick() {\r\n        if (this.currentPick !== null) {\r\n            /* Unref can cause a state change, which can cause a change in the value\r\n             * of this.currentPick, so we hold a local reference to make sure that\r\n             * does not impact this function. */\r\n            const currentPick = this.currentPick;\r\n            this.currentPick = null;\r\n            currentPick.unref();\r\n            currentPick.removeConnectivityStateListener(this.subchannelStateListener);\r\n            this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\r\n        }\r\n    }\r\n    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {\r\n        var _a;\r\n        if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {\r\n            if (newState !== connectivity_state_1.ConnectivityState.READY) {\r\n                this.removeCurrentPick();\r\n                this.calculateAndReportNewState();\r\n                this.requestReresolution();\r\n            }\r\n            return;\r\n        }\r\n        for (const [index, child] of this.children.entries()) {\r\n            if (subchannel.realSubchannelEquals(child.subchannel)) {\r\n                if (newState === connectivity_state_1.ConnectivityState.READY) {\r\n                    this.pickSubchannel(child.subchannel);\r\n                }\r\n                if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\r\n                    child.hasReportedTransientFailure = true;\r\n                    if (errorMessage) {\r\n                        this.lastError = errorMessage;\r\n                    }\r\n                    this.maybeEnterStickyTransientFailureMode();\r\n                    if (index === this.currentSubchannelIndex) {\r\n                        this.startNextSubchannelConnecting(index + 1);\r\n                    }\r\n                }\r\n                child.subchannel.startConnecting();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    startNextSubchannelConnecting(startIndex) {\r\n        clearTimeout(this.connectionDelayTimeout);\r\n        if (this.triedAllSubchannels) {\r\n            return;\r\n        }\r\n        for (const [index, child] of this.children.entries()) {\r\n            if (index >= startIndex) {\r\n                const subchannelState = child.subchannel.getConnectivityState();\r\n                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\r\n                    subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\r\n                    this.startConnecting(index);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        this.triedAllSubchannels = true;\r\n        this.maybeEnterStickyTransientFailureMode();\r\n    }\r\n    /**\r\n     * Have a single subchannel in the `subchannels` list start connecting.\r\n     * @param subchannelIndex The index into the `subchannels` list.\r\n     */\r\n    startConnecting(subchannelIndex) {\r\n        var _a, _b;\r\n        clearTimeout(this.connectionDelayTimeout);\r\n        this.currentSubchannelIndex = subchannelIndex;\r\n        if (this.children[subchannelIndex].subchannel.getConnectivityState() ===\r\n            connectivity_state_1.ConnectivityState.IDLE) {\r\n            trace('Start connecting to subchannel with address ' +\r\n                this.children[subchannelIndex].subchannel.getAddress());\r\n            process.nextTick(() => {\r\n                var _a;\r\n                (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();\r\n            });\r\n        }\r\n        this.connectionDelayTimeout = (_b = (_a = setTimeout(() => {\r\n            this.startNextSubchannelConnecting(subchannelIndex + 1);\r\n        }, CONNECTION_DELAY_INTERVAL_MS)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n    }\r\n    pickSubchannel(subchannel) {\r\n        if (this.currentPick && subchannel.realSubchannelEquals(this.currentPick)) {\r\n            return;\r\n        }\r\n        trace('Pick subchannel with address ' + subchannel.getAddress());\r\n        this.stickyTransientFailureMode = false;\r\n        if (this.currentPick !== null) {\r\n            this.currentPick.unref();\r\n            this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());\r\n            this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\r\n        }\r\n        this.currentPick = subchannel;\r\n        subchannel.ref();\r\n        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\r\n        this.resetSubchannelList();\r\n        clearTimeout(this.connectionDelayTimeout);\r\n        this.calculateAndReportNewState();\r\n    }\r\n    updateState(newState, picker) {\r\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\r\n            ' -> ' +\r\n            connectivity_state_1.ConnectivityState[newState]);\r\n        this.currentState = newState;\r\n        this.channelControlHelper.updateState(newState, picker);\r\n    }\r\n    resetSubchannelList() {\r\n        for (const child of this.children) {\r\n            if (!(this.currentPick && child.subchannel.realSubchannelEquals(this.currentPick))) {\r\n                /* The connectivity state listener is the same whether the subchannel\r\n                 * is in the list of children or it is the currentPick, so if it is in\r\n                 * both, removing it here would cause problems. In particular, that\r\n                 * always happens immediately after the subchannel is picked. */\r\n                child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\r\n            }\r\n            /* Refs are counted independently for the children list and the\r\n             * currentPick, so we call unref whether or not the child is the\r\n             * currentPick. Channelz child references are also refcounted, so\r\n             * removeChannelzChild can be handled the same way. */\r\n            child.subchannel.unref();\r\n            this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());\r\n        }\r\n        this.currentSubchannelIndex = 0;\r\n        this.children = [];\r\n        this.triedAllSubchannels = false;\r\n        this.requestedResolutionSinceLastUpdate = false;\r\n    }\r\n    connectToAddressList(addressList) {\r\n        const newChildrenList = addressList.map(address => ({\r\n            subchannel: this.channelControlHelper.createSubchannel(address, {}),\r\n            hasReportedTransientFailure: false,\r\n        }));\r\n        /* Ref each subchannel before resetting the list, to ensure that\r\n         * subchannels shared between the list don't drop to 0 refs during the\r\n         * transition. */\r\n        for (const { subchannel } of newChildrenList) {\r\n            subchannel.ref();\r\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\r\n        }\r\n        this.resetSubchannelList();\r\n        this.children = newChildrenList;\r\n        for (const { subchannel } of this.children) {\r\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\r\n            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\r\n                this.pickSubchannel(subchannel);\r\n                return;\r\n            }\r\n        }\r\n        for (const child of this.children) {\r\n            if (child.subchannel.getConnectivityState() ===\r\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\r\n                child.hasReportedTransientFailure = true;\r\n            }\r\n        }\r\n        this.startNextSubchannelConnecting(0);\r\n        this.calculateAndReportNewState();\r\n    }\r\n    updateAddressList(addressList, lbConfig) {\r\n        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\r\n            return;\r\n        }\r\n        /* Previously, an update would be discarded if it was identical to the\r\n         * previous update, to minimize churn. Now the DNS resolver is\r\n         * rate-limited, so that is less of a concern. */\r\n        if (lbConfig.getShuffleAddressList()) {\r\n            addressList = shuffled(addressList);\r\n        }\r\n        this.latestAddressList = addressList;\r\n        this.connectToAddressList(addressList);\r\n    }\r\n    exitIdle() {\r\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE && this.latestAddressList) {\r\n            this.connectToAddressList(this.latestAddressList);\r\n        }\r\n    }\r\n    resetBackoff() {\r\n        /* The pick first load balancer does not have a connection backoff, so this\r\n         * does nothing */\r\n    }\r\n    destroy() {\r\n        this.resetSubchannelList();\r\n        this.removeCurrentPick();\r\n    }\r\n    getTypeName() {\r\n        return TYPE_NAME;\r\n    }\r\n}\r\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\r\nfunction setup() {\r\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\r\n    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\r\n}\r\nexports.setup = setup;\r\n//# sourceMappingURL=load-balancer-pick-first.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLDZCQUE2QixHQUFHLGdCQUFnQixHQUFHLG9DQUFvQztBQUN2Ryx3QkFBd0IsbUJBQU8sQ0FBQyxzRkFBaUI7QUFDakQsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILG1EQUFtRCxlQUFlLEdBQUc7QUFDak07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItcGljay1maXJzdC5qcz9iNWU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnNldHVwID0gZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jZXIgPSBleHBvcnRzLnNodWZmbGVkID0gZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnID0gdm9pZCAwO1xyXG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xyXG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcclxuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgVFJBQ0VSX05BTUUgPSAncGlja19maXJzdCc7XHJcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcclxuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XHJcbn1cclxuY29uc3QgVFlQRV9OQU1FID0gJ3BpY2tfZmlyc3QnO1xyXG4vKipcclxuICogRGVsYXkgYWZ0ZXIgc3RhcnRpbmcgYSBjb25uZWN0aW9uIG9uIGEgc3ViY2hhbm5lbCBiZWZvcmUgc3RhcnRpbmcgYVxyXG4gKiBjb25uZWN0aW9uIG9uIHRoZSBuZXh0IHN1YmNoYW5uZWwgaW4gdGhlIGxpc3QsIGZvciBIYXBweSBFeWViYWxscyBhbGdvcml0aG0uXHJcbiAqL1xyXG5jb25zdCBDT05ORUNUSU9OX0RFTEFZX0lOVEVSVkFMX01TID0gMjUwO1xyXG5jbGFzcyBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnIHtcclxuICAgIGNvbnN0cnVjdG9yKHNodWZmbGVBZGRyZXNzTGlzdCkge1xyXG4gICAgICAgIHRoaXMuc2h1ZmZsZUFkZHJlc3NMaXN0ID0gc2h1ZmZsZUFkZHJlc3NMaXN0O1xyXG4gICAgfVxyXG4gICAgZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xyXG4gICAgfVxyXG4gICAgdG9Kc29uT2JqZWN0KCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFtUWVBFX05BTUVdOiB7XHJcbiAgICAgICAgICAgICAgICBzaHVmZmxlQWRkcmVzc0xpc3Q6IHRoaXMuc2h1ZmZsZUFkZHJlc3NMaXN0LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBnZXRTaHVmZmxlQWRkcmVzc0xpc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2h1ZmZsZUFkZHJlc3NMaXN0O1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSnNvbihvYmopIHtcclxuICAgICAgICBpZiAoJ3NodWZmbGVBZGRyZXNzTGlzdCcgaW4gb2JqICYmXHJcbiAgICAgICAgICAgICEodHlwZW9mIG9iai5zaHVmZmxlQWRkcmVzc0xpc3QgPT09ICdib29sZWFuJykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwaWNrX2ZpcnN0IGNvbmZpZyBmaWVsZCBzaHVmZmxlQWRkcmVzc0xpc3QgbXVzdCBiZSBhIGJvb2xlYW4gaWYgcHJvdmlkZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKG9iai5zaHVmZmxlQWRkcmVzc0xpc3QgPT09IHRydWUpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyA9IFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWc7XHJcbi8qKlxyXG4gKiBQaWNrZXIgZm9yIGEgYFBpY2tGaXJzdExvYWRCYWxhbmNlcmAgaW4gdGhlIFJFQURZIHN0YXRlLiBBbHdheXMgcmV0dXJucyB0aGVcclxuICogcGlja2VkIHN1YmNoYW5uZWwuXHJcbiAqL1xyXG5jbGFzcyBQaWNrRmlyc3RQaWNrZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc3ViY2hhbm5lbCkge1xyXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbCA9IHN1YmNoYW5uZWw7XHJcbiAgICB9XHJcbiAgICBwaWNrKHBpY2tBcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcGlja1Jlc3VsdFR5cGU6IHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkNPTVBMRVRFLFxyXG4gICAgICAgICAgICBzdWJjaGFubmVsOiB0aGlzLnN1YmNoYW5uZWwsXHJcbiAgICAgICAgICAgIHN0YXR1czogbnVsbCxcclxuICAgICAgICAgICAgb25DYWxsU3RhcnRlZDogbnVsbCxcclxuICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggdGhlIGVsZW1lbnRzIG9mIHRoZSBpbnB1dCBhcnJheSBpbiBhIHJhbmRvbSBvcmRlclxyXG4gKiBAcGFyYW0gbGlzdCBUaGUgaW5wdXQgYXJyYXlcclxuICogQHJldHVybnMgQSBzaHVmZmxlZCBhcnJheSBvZiB0aGUgZWxlbWVudHMgb2YgbGlzdFxyXG4gKi9cclxuZnVuY3Rpb24gc2h1ZmZsZWQobGlzdCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gbGlzdC5zbGljZSgpO1xyXG4gICAgZm9yIChsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID4gMTsgaS0tKSB7XHJcbiAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xyXG4gICAgICAgIGNvbnN0IHRlbXAgPSByZXN1bHRbaV07XHJcbiAgICAgICAgcmVzdWx0W2ldID0gcmVzdWx0W2pdO1xyXG4gICAgICAgIHJlc3VsdFtqXSA9IHRlbXA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMuc2h1ZmZsZWQgPSBzaHVmZmxlZDtcclxuY2xhc3MgUGlja0ZpcnN0TG9hZEJhbGFuY2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZCBiYWxhbmNlciB0aGF0IGF0dGVtcHRzIHRvIGNvbm5lY3QgdG8gZWFjaCBiYWNrZW5kIGluIHRoZSBhZGRyZXNzIGxpc3RcclxuICAgICAqIGluIG9yZGVyLCBhbmQgcGlja3MgdGhlIGZpcnN0IG9uZSB0aGF0IGNvbm5lY3RzLCB1c2luZyBpdCBmb3IgZXZlcnlcclxuICAgICAqIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0gY2hhbm5lbENvbnRyb2xIZWxwZXIgYENoYW5uZWxDb250cm9sSGVscGVyYCBpbnN0YW5jZSBwcm92aWRlZCBieVxyXG4gICAgICogICAgIHRoaXMgbG9hZCBiYWxhbmNlcidzIG93bmVyLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBzdWJjaGFubmVscyB0aGlzIGxvYWQgYmFsYW5jZXIgaXMgY3VycmVudGx5IGF0dGVtcHRpbmcgdG9cclxuICAgICAgICAgKiBjb25uZWN0IHRvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUgb2YgdGhlIGxvYWQgYmFsYW5jZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbmRleCB3aXRoaW4gdGhlIGBzdWJjaGFubmVsc2AgYXJyYXkgb2YgdGhlIHN1YmNoYW5uZWwgd2l0aCB0aGUgbW9zdFxyXG4gICAgICAgICAqIHJlY2VudGx5IHN0YXJ0ZWQgY29ubmVjdGlvbiBhdHRlbXB0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBwaWNrZWQgc3ViY2hhbm5lbCB1c2VkIGZvciBtYWtpbmcgY2FsbHMuIFBvcHVsYXRlZCBpZlxyXG4gICAgICAgICAqIGFuZCBvbmx5IGlmIHRoZSBsb2FkIGJhbGFuY2VyJ3MgY3VycmVudCBzdGF0ZSBpcyBSRUFEWS4gSW4gdGhhdCBjYXNlLFxyXG4gICAgICAgICAqIHRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBzdGF0ZSBpcyBhbHNvIFJFQURZLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBpY2sgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3RlbmVyIGNhbGxiYWNrIGF0dGFjaGVkIHRvIGVhY2ggc3ViY2hhbm5lbCBpbiB0aGUgYHN1YmNoYW5uZWxzYCBsaXN0XHJcbiAgICAgICAgICogd2hpbGUgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyID0gKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBrZWVwYWxpdmVUaW1lLCBlcnJvck1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZShzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudHJpZWRBbGxTdWJjaGFubmVscyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBMQiBwb2xpY3kgZW50ZXJzIHN0aWNreSBUUkFOU0lFTlRfRkFJTFVSRSBtb2RlIHdoZW4gYWxsXHJcbiAgICAgICAgICogc3ViY2hhbm5lbHMgaGF2ZSBmYWlsZWQgdG8gY29ubmVjdCBhdCBsZWFzdCBvbmNlLCBhbmQgaXQgc3RheXMgaW4gdGhhdFxyXG4gICAgICAgICAqIG1vZGUgdW50aWwgYSBjb25uZWN0aW9uIGF0dGVtcHQgaXMgc3VjY2Vzc2Z1bC4gV2hpbGUgaW4gc3RpY2t5IFRGIG1vZGUsXHJcbiAgICAgICAgICogdGhlIExCIHBvbGljeSBjb250aW51b3VzbHkgYXR0ZW1wdHMgdG8gY29ubmVjdCB0byBhbGwgb2YgaXRzIHN1YmNoYW5uZWxzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB3ZSBjYWxsZWQgY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbiBzaW5jZVxyXG4gICAgICAgICAqIHRoZSBsYXN0IGNhbGwgdG8gdXBkYXRlQWRkcmVzc0xpc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlcXVlc3RlZFJlc29sdXRpb25TaW5jZUxhc3RVcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbW9zdCByZWNlbnQgZXJyb3IgcmVwb3J0ZWQgYnkgYW55IHN1YmNoYW5uZWwgYXMgaXQgdHJhbnNpdGlvbmVkIHRvXHJcbiAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcclxuICAgIH1cclxuICAgIGFsbENoaWxkcmVuSGF2ZVJlcG9ydGVkVEYoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4gY2hpbGQuaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlKTtcclxuICAgIH1cclxuICAgIGNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFksIG5ldyBQaWNrRmlyc3RQaWNrZXIodGhpcy5jdXJyZW50UGljaykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHsgZGV0YWlsczogYE5vIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuIExhc3QgZXJyb3I6ICR7dGhpcy5sYXN0RXJyb3J9YCB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXF1ZXN0UmVyZXNvbHV0aW9uKCkge1xyXG4gICAgICAgIHRoaXMucmVxdWVzdGVkUmVzb2x1dGlvblNpbmNlTGFzdFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XHJcbiAgICB9XHJcbiAgICBtYXliZUVudGVyU3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFsbENoaWxkcmVuSGF2ZVJlcG9ydGVkVEYoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5yZXF1ZXN0ZWRSZXNvbHV0aW9uU2luY2VMYXN0VXBkYXRlKSB7XHJcbiAgICAgICAgICAgIC8qIEVhY2ggdGltZSB3ZSBnZXQgYW4gdXBkYXRlIHdlIHJlc2V0IGVhY2ggc3ViY2hhbm5lbCdzXHJcbiAgICAgICAgICAgICAqIGhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZSBmbGFnLCBzbyB0aGUgbmV4dCB0aW1lIHdlIGdldCB0byB0aGlzXHJcbiAgICAgICAgICAgICAqIHBvaW50IGFmdGVyIHRoYXQsIGVhY2ggc3ViY2hhbm5lbCBoYXMgcmVwb3J0ZWQgVFJBTlNJRU5UX0ZBSUxVUkVcclxuICAgICAgICAgICAgICogYXQgbGVhc3Qgb25jZSBzaW5jZSB0aGVuLiBUaGF0IGlzIHRoZSB0cmlnZ2VyIGZvciByZXF1ZXN0aW5nXHJcbiAgICAgICAgICAgICAqIHJlcmVzb2x1dGlvbiwgd2hldGhlciBvciBub3QgdGhlIExCIHBvbGljeSBpcyBhbHJlYWR5IGluIHN0aWNreSBURlxyXG4gICAgICAgICAgICAgKiBtb2RlLiAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGNvbnN0IHsgc3ViY2hhbm5lbCB9IG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQ3VycmVudFBpY2soKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2sgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLyogVW5yZWYgY2FuIGNhdXNlIGEgc3RhdGUgY2hhbmdlLCB3aGljaCBjYW4gY2F1c2UgYSBjaGFuZ2UgaW4gdGhlIHZhbHVlXHJcbiAgICAgICAgICAgICAqIG9mIHRoaXMuY3VycmVudFBpY2ssIHNvIHdlIGhvbGQgYSBsb2NhbCByZWZlcmVuY2UgdG8gbWFrZSBzdXJlIHRoYXRcclxuICAgICAgICAgICAgICogZG9lcyBub3QgaW1wYWN0IHRoaXMgZnVuY3Rpb24uICovXHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQaWNrID0gdGhpcy5jdXJyZW50UGljaztcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGljayA9IG51bGw7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQaWNrLnVucmVmKCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQaWNrLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZChjdXJyZW50UGljay5nZXRDaGFubmVselJlZigpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvblN1YmNoYW5uZWxTdGF0ZVVwZGF0ZShzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgZXJyb3JNZXNzYWdlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLmN1cnJlbnRQaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhbFN1YmNoYW5uZWxFcXVhbHMoc3ViY2hhbm5lbCkpIHtcclxuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDdXJyZW50UGljaygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgY2hpbGRdIG9mIHRoaXMuY2hpbGRyZW4uZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWJjaGFubmVsLnJlYWxTdWJjaGFubmVsRXF1YWxzKGNoaWxkLnN1YmNoYW5uZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waWNrU3ViY2hhbm5lbChjaGlsZC5zdWJjaGFubmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5oYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvck1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVFbnRlclN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZyhpbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNoaWxkLnN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZyhzdGFydEluZGV4KSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XHJcbiAgICAgICAgaWYgKHRoaXMudHJpZWRBbGxTdWJjaGFubmVscykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjaGlsZF0gb2YgdGhpcy5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHN0YXJ0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdGF0ZSA9IGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHxcclxuICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZyhpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpZWRBbGxTdWJjaGFubmVscyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5tYXliZUVudGVyU3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGF2ZSBhIHNpbmdsZSBzdWJjaGFubmVsIGluIHRoZSBgc3ViY2hhbm5lbHNgIGxpc3Qgc3RhcnQgY29ubmVjdGluZy5cclxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsSW5kZXggVGhlIGluZGV4IGludG8gdGhlIGBzdWJjaGFubmVsc2AgbGlzdC5cclxuICAgICAqL1xyXG4gICAgc3RhcnRDb25uZWN0aW5nKHN1YmNoYW5uZWxJbmRleCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gc3ViY2hhbm5lbEluZGV4O1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW3N1YmNoYW5uZWxJbmRleF0uc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PVxyXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XHJcbiAgICAgICAgICAgIHRyYWNlKCdTdGFydCBjb25uZWN0aW5nIHRvIHN1YmNoYW5uZWwgd2l0aCBhZGRyZXNzICcgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltzdWJjaGFubmVsSW5kZXhdLnN1YmNoYW5uZWwuZ2V0QWRkcmVzcygpKTtcclxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNoaWxkcmVuW3N1YmNoYW5uZWxJbmRleF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0ID0gKF9iID0gKF9hID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3Rpbmcoc3ViY2hhbm5lbEluZGV4ICsgMSk7XHJcbiAgICAgICAgfSwgQ09OTkVDVElPTl9ERUxBWV9JTlRFUlZBTF9NUykpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICB9XHJcbiAgICBwaWNrU3ViY2hhbm5lbChzdWJjaGFubmVsKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2sgJiYgc3ViY2hhbm5lbC5yZWFsU3ViY2hhbm5lbEVxdWFscyh0aGlzLmN1cnJlbnRQaWNrKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNlKCdQaWNrIHN1YmNoYW5uZWwgd2l0aCBhZGRyZXNzICcgKyBzdWJjaGFubmVsLmdldEFkZHJlc3MoKSk7XHJcbiAgICAgICAgdGhpcy5zdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sudW5yZWYoKTtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKHRoaXMuY3VycmVudFBpY2suZ2V0Q2hhbm5lbHpSZWYoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGljayA9IHN1YmNoYW5uZWw7XHJcbiAgICAgICAgc3ViY2hhbm5lbC5yZWYoKTtcclxuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcclxuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyKSB7XHJcbiAgICAgICAgdHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jdXJyZW50U3RhdGVdICtcclxuICAgICAgICAgICAgJyAtPiAnICtcclxuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcik7XHJcbiAgICB9XHJcbiAgICByZXNldFN1YmNoYW5uZWxMaXN0KCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoISh0aGlzLmN1cnJlbnRQaWNrICYmIGNoaWxkLnN1YmNoYW5uZWwucmVhbFN1YmNoYW5uZWxFcXVhbHModGhpcy5jdXJyZW50UGljaykpKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBUaGUgY29ubmVjdGl2aXR5IHN0YXRlIGxpc3RlbmVyIGlzIHRoZSBzYW1lIHdoZXRoZXIgdGhlIHN1YmNoYW5uZWxcclxuICAgICAgICAgICAgICAgICAqIGlzIGluIHRoZSBsaXN0IG9mIGNoaWxkcmVuIG9yIGl0IGlzIHRoZSBjdXJyZW50UGljaywgc28gaWYgaXQgaXMgaW5cclxuICAgICAgICAgICAgICAgICAqIGJvdGgsIHJlbW92aW5nIGl0IGhlcmUgd291bGQgY2F1c2UgcHJvYmxlbXMuIEluIHBhcnRpY3VsYXIsIHRoYXRcclxuICAgICAgICAgICAgICAgICAqIGFsd2F5cyBoYXBwZW5zIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBzdWJjaGFubmVsIGlzIHBpY2tlZC4gKi9cclxuICAgICAgICAgICAgICAgIGNoaWxkLnN1YmNoYW5uZWwucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKiBSZWZzIGFyZSBjb3VudGVkIGluZGVwZW5kZW50bHkgZm9yIHRoZSBjaGlsZHJlbiBsaXN0IGFuZCB0aGVcclxuICAgICAgICAgICAgICogY3VycmVudFBpY2ssIHNvIHdlIGNhbGwgdW5yZWYgd2hldGhlciBvciBub3QgdGhlIGNoaWxkIGlzIHRoZVxyXG4gICAgICAgICAgICAgKiBjdXJyZW50UGljay4gQ2hhbm5lbHogY2hpbGQgcmVmZXJlbmNlcyBhcmUgYWxzbyByZWZjb3VudGVkLCBzb1xyXG4gICAgICAgICAgICAgKiByZW1vdmVDaGFubmVsekNoaWxkIGNhbiBiZSBoYW5kbGVkIHRoZSBzYW1lIHdheS4gKi9cclxuICAgICAgICAgICAgY2hpbGQuc3ViY2hhbm5lbC51bnJlZigpO1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQoY2hpbGQuc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgdGhpcy50cmllZEFsbFN1YmNoYW5uZWxzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWRSZXNvbHV0aW9uU2luY2VMYXN0VXBkYXRlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25uZWN0VG9BZGRyZXNzTGlzdChhZGRyZXNzTGlzdCkge1xyXG4gICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuTGlzdCA9IGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICh7XHJcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChhZGRyZXNzLCB7fSksXHJcbiAgICAgICAgICAgIGhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZTogZmFsc2UsXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIC8qIFJlZiBlYWNoIHN1YmNoYW5uZWwgYmVmb3JlIHJlc2V0dGluZyB0aGUgbGlzdCwgdG8gZW5zdXJlIHRoYXRcclxuICAgICAgICAgKiBzdWJjaGFubmVscyBzaGFyZWQgYmV0d2VlbiB0aGUgbGlzdCBkb24ndCBkcm9wIHRvIDAgcmVmcyBkdXJpbmcgdGhlXHJcbiAgICAgICAgICogdHJhbnNpdGlvbi4gKi9cclxuICAgICAgICBmb3IgKGNvbnN0IHsgc3ViY2hhbm5lbCB9IG9mIG5ld0NoaWxkcmVuTGlzdCkge1xyXG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuTGlzdDtcclxuICAgICAgICBmb3IgKGNvbnN0IHsgc3ViY2hhbm5lbCB9IG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgc3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrU3ViY2hhbm5lbChzdWJjaGFubmVsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT1cclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5oYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3RpbmcoMCk7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxiQ29uZmlnKSB7XHJcbiAgICAgICAgaWYgKCEobGJDb25maWcgaW5zdGFuY2VvZiBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIFByZXZpb3VzbHksIGFuIHVwZGF0ZSB3b3VsZCBiZSBkaXNjYXJkZWQgaWYgaXQgd2FzIGlkZW50aWNhbCB0byB0aGVcclxuICAgICAgICAgKiBwcmV2aW91cyB1cGRhdGUsIHRvIG1pbmltaXplIGNodXJuLiBOb3cgdGhlIEROUyByZXNvbHZlciBpc1xyXG4gICAgICAgICAqIHJhdGUtbGltaXRlZCwgc28gdGhhdCBpcyBsZXNzIG9mIGEgY29uY2Vybi4gKi9cclxuICAgICAgICBpZiAobGJDb25maWcuZ2V0U2h1ZmZsZUFkZHJlc3NMaXN0KCkpIHtcclxuICAgICAgICAgICAgYWRkcmVzc0xpc3QgPSBzaHVmZmxlZChhZGRyZXNzTGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QgPSBhZGRyZXNzTGlzdDtcclxuICAgICAgICB0aGlzLmNvbm5lY3RUb0FkZHJlc3NMaXN0KGFkZHJlc3NMaXN0KTtcclxuICAgIH1cclxuICAgIGV4aXRJZGxlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSAmJiB0aGlzLmxhdGVzdEFkZHJlc3NMaXN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRvQWRkcmVzc0xpc3QodGhpcy5sYXRlc3RBZGRyZXNzTGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzZXRCYWNrb2ZmKCkge1xyXG4gICAgICAgIC8qIFRoZSBwaWNrIGZpcnN0IGxvYWQgYmFsYW5jZXIgZG9lcyBub3QgaGF2ZSBhIGNvbm5lY3Rpb24gYmFja29mZiwgc28gdGhpc1xyXG4gICAgICAgICAqIGRvZXMgbm90aGluZyAqL1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcclxuICAgICAgICB0aGlzLnJlbW92ZUN1cnJlbnRQaWNrKCk7XHJcbiAgICB9XHJcbiAgICBnZXRUeXBlTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2VyID0gUGlja0ZpcnN0TG9hZEJhbGFuY2VyO1xyXG5mdW5jdGlvbiBzZXR1cCgpIHtcclxuICAgICgwLCBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKShUWVBFX05BTUUsIFBpY2tGaXJzdExvYWRCYWxhbmNlciwgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyk7XHJcbiAgICAoMCwgbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUpKFRZUEVfTkFNRSk7XHJcbn1cclxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\r\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst TRACER_NAME = 'round_robin';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nconst TYPE_NAME = 'round_robin';\r\nclass RoundRobinLoadBalancingConfig {\r\n    getLoadBalancerName() {\r\n        return TYPE_NAME;\r\n    }\r\n    constructor() { }\r\n    toJsonObject() {\r\n        return {\r\n            [TYPE_NAME]: {},\r\n        };\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    static createFromJson(obj) {\r\n        return new RoundRobinLoadBalancingConfig();\r\n    }\r\n}\r\nclass RoundRobinPicker {\r\n    constructor(subchannelList, nextIndex = 0) {\r\n        this.subchannelList = subchannelList;\r\n        this.nextIndex = nextIndex;\r\n    }\r\n    pick(pickArgs) {\r\n        const pickedSubchannel = this.subchannelList[this.nextIndex];\r\n        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\r\n        return {\r\n            pickResultType: picker_1.PickResultType.COMPLETE,\r\n            subchannel: pickedSubchannel,\r\n            status: null,\r\n            onCallStarted: null,\r\n            onCallEnded: null,\r\n        };\r\n    }\r\n    /**\r\n     * Check what the next subchannel returned would be. Used by the load\r\n     * balancer implementation to preserve this part of the picker state if\r\n     * possible when a subchannel connects or disconnects.\r\n     */\r\n    peekNextSubchannel() {\r\n        return this.subchannelList[this.nextIndex];\r\n    }\r\n}\r\nclass RoundRobinLoadBalancer {\r\n    constructor(channelControlHelper) {\r\n        this.channelControlHelper = channelControlHelper;\r\n        this.subchannels = [];\r\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\r\n        this.currentReadyPicker = null;\r\n        this.lastError = null;\r\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {\r\n            this.calculateAndUpdateState();\r\n            if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE ||\r\n                newState === connectivity_state_1.ConnectivityState.IDLE) {\r\n                if (errorMessage) {\r\n                    this.lastError = errorMessage;\r\n                }\r\n                this.channelControlHelper.requestReresolution();\r\n                subchannel.startConnecting();\r\n            }\r\n        };\r\n    }\r\n    countSubchannelsWithState(state) {\r\n        return this.subchannels.filter(subchannel => subchannel.getConnectivityState() === state).length;\r\n    }\r\n    calculateAndUpdateState() {\r\n        if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.READY) > 0) {\r\n            const readySubchannels = this.subchannels.filter(subchannel => subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\r\n            let index = 0;\r\n            if (this.currentReadyPicker !== null) {\r\n                index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\r\n                if (index < 0) {\r\n                    index = 0;\r\n                }\r\n            }\r\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\r\n        }\r\n        else if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {\r\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\r\n        }\r\n        else if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {\r\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({ details: `No connection established. Last error: ${this.lastError}` }));\r\n        }\r\n        else {\r\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\r\n        }\r\n    }\r\n    updateState(newState, picker) {\r\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\r\n            ' -> ' +\r\n            connectivity_state_1.ConnectivityState[newState]);\r\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\r\n            this.currentReadyPicker = picker;\r\n        }\r\n        else {\r\n            this.currentReadyPicker = null;\r\n        }\r\n        this.currentState = newState;\r\n        this.channelControlHelper.updateState(newState, picker);\r\n    }\r\n    resetSubchannelList() {\r\n        for (const subchannel of this.subchannels) {\r\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\r\n            subchannel.unref();\r\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\r\n        }\r\n        this.subchannels = [];\r\n    }\r\n    updateAddressList(addressList, lbConfig) {\r\n        this.resetSubchannelList();\r\n        trace('Connect to address list ' +\r\n            addressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)));\r\n        this.subchannels = addressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\r\n        for (const subchannel of this.subchannels) {\r\n            subchannel.ref();\r\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\r\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\r\n            const subchannelState = subchannel.getConnectivityState();\r\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\r\n                subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\r\n                subchannel.startConnecting();\r\n            }\r\n        }\r\n        this.calculateAndUpdateState();\r\n    }\r\n    exitIdle() {\r\n        for (const subchannel of this.subchannels) {\r\n            subchannel.startConnecting();\r\n        }\r\n    }\r\n    resetBackoff() {\r\n        /* The pick first load balancer does not have a connection backoff, so this\r\n         * does nothing */\r\n    }\r\n    destroy() {\r\n        this.resetSubchannelList();\r\n    }\r\n    getTypeName() {\r\n        return TYPE_NAME;\r\n    }\r\n}\r\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\r\nfunction setup() {\r\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\r\n}\r\nexports.setup = setup;\r\n//# sourceMappingURL=load-balancer-round-robin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyw4QkFBOEI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pELDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILG1EQUFtRCxlQUFlLEdBQUc7QUFDN0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcz9jOWMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnNldHVwID0gZXhwb3J0cy5Sb3VuZFJvYmluTG9hZEJhbGFuY2VyID0gdm9pZCAwO1xyXG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xyXG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcclxuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XHJcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xyXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3JvdW5kX3JvYmluJztcclxuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xyXG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcclxufVxyXG5jb25zdCBUWVBFX05BTUUgPSAncm91bmRfcm9iaW4nO1xyXG5jbGFzcyBSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZyB7XHJcbiAgICBnZXRMb2FkQmFsYW5jZXJOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XHJcbiAgICB9XHJcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxyXG4gICAgdG9Kc29uT2JqZWN0KCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFtUWVBFX05BTUVdOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSnNvbihvYmopIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnKCk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgUm91bmRSb2JpblBpY2tlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzdWJjaGFubmVsTGlzdCwgbmV4dEluZGV4ID0gMCkge1xyXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbExpc3QgPSBzdWJjaGFubmVsTGlzdDtcclxuICAgICAgICB0aGlzLm5leHRJbmRleCA9IG5leHRJbmRleDtcclxuICAgIH1cclxuICAgIHBpY2socGlja0FyZ3MpIHtcclxuICAgICAgICBjb25zdCBwaWNrZWRTdWJjaGFubmVsID0gdGhpcy5zdWJjaGFubmVsTGlzdFt0aGlzLm5leHRJbmRleF07XHJcbiAgICAgICAgdGhpcy5uZXh0SW5kZXggPSAodGhpcy5uZXh0SW5kZXggKyAxKSAlIHRoaXMuc3ViY2hhbm5lbExpc3QubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSxcclxuICAgICAgICAgICAgc3ViY2hhbm5lbDogcGlja2VkU3ViY2hhbm5lbCxcclxuICAgICAgICAgICAgc3RhdHVzOiBudWxsLFxyXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxyXG4gICAgICAgICAgICBvbkNhbGxFbmRlZDogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB3aGF0IHRoZSBuZXh0IHN1YmNoYW5uZWwgcmV0dXJuZWQgd291bGQgYmUuIFVzZWQgYnkgdGhlIGxvYWRcclxuICAgICAqIGJhbGFuY2VyIGltcGxlbWVudGF0aW9uIHRvIHByZXNlcnZlIHRoaXMgcGFydCBvZiB0aGUgcGlja2VyIHN0YXRlIGlmXHJcbiAgICAgKiBwb3NzaWJsZSB3aGVuIGEgc3ViY2hhbm5lbCBjb25uZWN0cyBvciBkaXNjb25uZWN0cy5cclxuICAgICAqL1xyXG4gICAgcGVla05leHRTdWJjaGFubmVsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YmNoYW5uZWxMaXN0W3RoaXMubmV4dEluZGV4XTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBSb3VuZFJvYmluTG9hZEJhbGFuY2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xyXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbHMgPSBbXTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UmVhZHlQaWNrZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdEVycm9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyID0gKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBrZWVwYWxpdmVUaW1lLCBlcnJvck1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFIHx8XHJcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEVycm9yID0gZXJyb3JNZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvdW50U3ViY2hhbm5lbHNXaXRoU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWJjaGFubmVscy5maWx0ZXIoc3ViY2hhbm5lbCA9PiBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IHN0YXRlKS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb3VudFN1YmNoYW5uZWxzV2l0aFN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgcmVhZHlTdWJjaGFubmVscyA9IHRoaXMuc3ViY2hhbm5lbHMuZmlsdGVyKHN1YmNoYW5uZWwgPT4gc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSk7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSByZWFkeVN1YmNoYW5uZWxzLmluZGV4T2YodGhpcy5jdXJyZW50UmVhZHlQaWNrZXIucGVla05leHRTdWJjaGFubmVsKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZLCBuZXcgUm91bmRSb2JpblBpY2tlcihyZWFkeVN1YmNoYW5uZWxzLCBpbmRleCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvdW50U3ViY2hhbm5lbHNXaXRoU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb3VudFN1YmNoYW5uZWxzV2l0aFN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHsgZGV0YWlsczogYE5vIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuIExhc3QgZXJyb3I6ICR7dGhpcy5sYXN0RXJyb3J9YCB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcikge1xyXG4gICAgICAgIHRyYWNlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY3VycmVudFN0YXRlXSArXHJcbiAgICAgICAgICAgICcgLT4gJyArXHJcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XHJcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciA9IHBpY2tlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZTtcclxuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpO1xyXG4gICAgfVxyXG4gICAgcmVzZXRTdWJjaGFubmVsTGlzdCgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xyXG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIHN1YmNoYW5uZWwudW5yZWYoKTtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbHMgPSBbXTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZykge1xyXG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xyXG4gICAgICAgIHRyYWNlKCdDb25uZWN0IHRvIGFkZHJlc3MgbGlzdCAnICtcclxuICAgICAgICAgICAgYWRkcmVzc0xpc3QubWFwKGFkZHJlc3MgPT4gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpKSk7XHJcbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+IHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChhZGRyZXNzLCB7fSkpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbCBvZiB0aGlzLnN1YmNoYW5uZWxzKSB7XHJcbiAgICAgICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XHJcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdGF0ZSA9IHN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcclxuICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWxTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSB8fFxyXG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xyXG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFVwZGF0ZVN0YXRlKCk7XHJcbiAgICB9XHJcbiAgICBleGl0SWRsZSgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xyXG4gICAgICAgICAgICBzdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc2V0QmFja29mZigpIHtcclxuICAgICAgICAvKiBUaGUgcGljayBmaXJzdCBsb2FkIGJhbGFuY2VyIGRvZXMgbm90IGhhdmUgYSBjb25uZWN0aW9uIGJhY2tvZmYsIHNvIHRoaXNcclxuICAgICAgICAgKiBkb2VzIG5vdGhpbmcgKi9cclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XHJcbiAgICB9XHJcbiAgICBnZXRUeXBlTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUm91bmRSb2JpbkxvYWRCYWxhbmNlciA9IFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXI7XHJcbmZ1bmN0aW9uIHNldHVwKCkge1xyXG4gICAgKDAsIGxvYWRfYmFsYW5jZXJfMS5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUpKFRZUEVfTkFNRSwgUm91bmRSb2JpbkxvYWRCYWxhbmNlciwgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcpO1xyXG59XHJcbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.isLoadBalancerNameRegistered = exports.createLoadBalancer = exports.registerDefaultLoadBalancerType = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = void 0;\r\n/**\r\n * Create a child ChannelControlHelper that overrides some methods of the\r\n * parent while letting others pass through to the parent unmodified. This\r\n * allows other code to create these children without needing to know about\r\n * all of the methods to be passed through.\r\n * @param parent\r\n * @param overrides\r\n */\r\nfunction createChildChannelControlHelper(parent, overrides) {\r\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\r\n    return {\r\n        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),\r\n        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),\r\n        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),\r\n        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),\r\n        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent),\r\n    };\r\n}\r\nexports.createChildChannelControlHelper = createChildChannelControlHelper;\r\nconst registeredLoadBalancerTypes = {};\r\nlet defaultLoadBalancerType = null;\r\nfunction registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {\r\n    registeredLoadBalancerTypes[typeName] = {\r\n        LoadBalancer: loadBalancerType,\r\n        LoadBalancingConfig: loadBalancingConfigType,\r\n    };\r\n}\r\nexports.registerLoadBalancerType = registerLoadBalancerType;\r\nfunction registerDefaultLoadBalancerType(typeName) {\r\n    defaultLoadBalancerType = typeName;\r\n}\r\nexports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;\r\nfunction createLoadBalancer(config, channelControlHelper) {\r\n    const typeName = config.getLoadBalancerName();\r\n    if (typeName in registeredLoadBalancerTypes) {\r\n        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nexports.createLoadBalancer = createLoadBalancer;\r\nfunction isLoadBalancerNameRegistered(typeName) {\r\n    return typeName in registeredLoadBalancerTypes;\r\n}\r\nexports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;\r\nfunction getFirstUsableConfig(configs, fallbackTodefault = false) {\r\n    for (const config of configs) {\r\n        if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {\r\n            return config;\r\n        }\r\n    }\r\n    if (fallbackTodefault) {\r\n        if (defaultLoadBalancerType) {\r\n            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nexports.getFirstUsableConfig = getFirstUsableConfig;\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction validateLoadBalancingConfig(obj) {\r\n    if (!(obj !== null && typeof obj === 'object')) {\r\n        throw new Error('Load balancing config must be an object');\r\n    }\r\n    const keys = Object.keys(obj);\r\n    if (keys.length !== 1) {\r\n        throw new Error('Provided load balancing config has multiple conflicting entries');\r\n    }\r\n    const typeName = keys[0];\r\n    if (typeName in registeredLoadBalancerTypes) {\r\n        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);\r\n    }\r\n    else {\r\n        throw new Error(`Unrecognized load balancing config name ${typeName}`);\r\n    }\r\n}\r\nexports.validateLoadBalancingConfig = validateLoadBalancingConfig;\r\n//# sourceMappingURL=load-balancer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1DQUFtQyxHQUFHLDRCQUE0QixHQUFHLG9DQUFvQyxHQUFHLDBCQUEwQixHQUFHLHVDQUF1QyxHQUFHLGdDQUFnQyxHQUFHLHVDQUF1QztBQUM3UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxTQUFTO0FBQzVFO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXIuanM/M2IxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcgPSBleHBvcnRzLmdldEZpcnN0VXNhYmxlQ29uZmlnID0gZXhwb3J0cy5pc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkID0gZXhwb3J0cy5jcmVhdGVMb2FkQmFsYW5jZXIgPSBleHBvcnRzLnJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSBleHBvcnRzLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSA9IGV4cG9ydHMuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciA9IHZvaWQgMDtcclxuLyoqXHJcbiAqIENyZWF0ZSBhIGNoaWxkIENoYW5uZWxDb250cm9sSGVscGVyIHRoYXQgb3ZlcnJpZGVzIHNvbWUgbWV0aG9kcyBvZiB0aGVcclxuICogcGFyZW50IHdoaWxlIGxldHRpbmcgb3RoZXJzIHBhc3MgdGhyb3VnaCB0byB0aGUgcGFyZW50IHVubW9kaWZpZWQuIFRoaXNcclxuICogYWxsb3dzIG90aGVyIGNvZGUgdG8gY3JlYXRlIHRoZXNlIGNoaWxkcmVuIHdpdGhvdXQgbmVlZGluZyB0byBrbm93IGFib3V0XHJcbiAqIGFsbCBvZiB0aGUgbWV0aG9kcyB0byBiZSBwYXNzZWQgdGhyb3VnaC5cclxuICogQHBhcmFtIHBhcmVudFxyXG4gKiBAcGFyYW0gb3ZlcnJpZGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKHBhcmVudCwgb3ZlcnJpZGVzKSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IChfYiA9IChfYSA9IG92ZXJyaWRlcy5jcmVhdGVTdWJjaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBwYXJlbnQuY3JlYXRlU3ViY2hhbm5lbC5iaW5kKHBhcmVudCksXHJcbiAgICAgICAgdXBkYXRlU3RhdGU6IChfZCA9IChfYyA9IG92ZXJyaWRlcy51cGRhdGVTdGF0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogcGFyZW50LnVwZGF0ZVN0YXRlLmJpbmQocGFyZW50KSxcclxuICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uOiAoX2YgPSAoX2UgPSBvdmVycmlkZXMucmVxdWVzdFJlcmVzb2x1dGlvbikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogcGFyZW50LnJlcXVlc3RSZXJlc29sdXRpb24uYmluZChwYXJlbnQpLFxyXG4gICAgICAgIGFkZENoYW5uZWx6Q2hpbGQ6IChfaCA9IChfZyA9IG92ZXJyaWRlcy5hZGRDaGFubmVsekNoaWxkKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBwYXJlbnQuYWRkQ2hhbm5lbHpDaGlsZC5iaW5kKHBhcmVudCksXHJcbiAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogKF9rID0gKF9qID0gb3ZlcnJpZGVzLnJlbW92ZUNoYW5uZWx6Q2hpbGQpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IHBhcmVudC5yZW1vdmVDaGFubmVsekNoaWxkLmJpbmQocGFyZW50KSxcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyID0gY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcjtcclxuY29uc3QgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzID0ge307XHJcbmxldCBkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IG51bGw7XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSh0eXBlTmFtZSwgbG9hZEJhbGFuY2VyVHlwZSwgbG9hZEJhbGFuY2luZ0NvbmZpZ1R5cGUpIHtcclxuICAgIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0gPSB7XHJcbiAgICAgICAgTG9hZEJhbGFuY2VyOiBsb2FkQmFsYW5jZXJUeXBlLFxyXG4gICAgICAgIExvYWRCYWxhbmNpbmdDb25maWc6IGxvYWRCYWxhbmNpbmdDb25maWdUeXBlLFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSA9IHJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSh0eXBlTmFtZSkge1xyXG4gICAgZGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSB0eXBlTmFtZTtcclxufVxyXG5leHBvcnRzLnJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSByZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlO1xyXG5mdW5jdGlvbiBjcmVhdGVMb2FkQmFsYW5jZXIoY29uZmlnLCBjaGFubmVsQ29udHJvbEhlbHBlcikge1xyXG4gICAgY29uc3QgdHlwZU5hbWUgPSBjb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpO1xyXG4gICAgaWYgKHR5cGVOYW1lIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzW3R5cGVOYW1lXS5Mb2FkQmFsYW5jZXIoY2hhbm5lbENvbnRyb2xIZWxwZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5jcmVhdGVMb2FkQmFsYW5jZXIgPSBjcmVhdGVMb2FkQmFsYW5jZXI7XHJcbmZ1bmN0aW9uIGlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQodHlwZU5hbWUpIHtcclxuICAgIHJldHVybiB0eXBlTmFtZSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXM7XHJcbn1cclxuZXhwb3J0cy5pc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkID0gaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZDtcclxuZnVuY3Rpb24gZ2V0Rmlyc3RVc2FibGVDb25maWcoY29uZmlncywgZmFsbGJhY2tUb2RlZmF1bHQgPSBmYWxzZSkge1xyXG4gICAgZm9yIChjb25zdCBjb25maWcgb2YgY29uZmlncykge1xyXG4gICAgICAgIGlmIChjb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChmYWxsYmFja1RvZGVmYXVsdCkge1xyXG4gICAgICAgIGlmIChkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1tkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZV0uTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5nZXRGaXJzdFVzYWJsZUNvbmZpZyA9IGdldEZpcnN0VXNhYmxlQ29uZmlnO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcob2JqKSB7XHJcbiAgICBpZiAoIShvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkIGJhbGFuY2luZyBjb25maWcgbXVzdCBiZSBhbiBvYmplY3QnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xyXG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBsb2FkIGJhbGFuY2luZyBjb25maWcgaGFzIG11bHRpcGxlIGNvbmZsaWN0aW5nIGVudHJpZXMnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHR5cGVOYW1lID0ga2V5c1swXTtcclxuICAgIGlmICh0eXBlTmFtZSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXMpIHtcclxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzW3R5cGVOYW1lXS5Mb2FkQmFsYW5jaW5nQ29uZmlnLmNyZWF0ZUZyb21Kc29uKG9ialt0eXBlTmFtZV0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbG9hZCBiYWxhbmNpbmcgY29uZmlnIG5hbWUgJHt0eXBlTmFtZX1gKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyA9IHZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LoadBalancingCall = void 0;\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\r\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\r\nconst TRACER_NAME = 'load_balancing_call';\r\nclass LoadBalancingCall {\r\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {\r\n        var _a, _b;\r\n        this.channel = channel;\r\n        this.callConfig = callConfig;\r\n        this.methodName = methodName;\r\n        this.host = host;\r\n        this.credentials = credentials;\r\n        this.deadline = deadline;\r\n        this.callNumber = callNumber;\r\n        this.child = null;\r\n        this.readPending = false;\r\n        this.pendingMessage = null;\r\n        this.pendingHalfClose = false;\r\n        this.ended = false;\r\n        this.metadata = null;\r\n        this.listener = null;\r\n        this.onCallEnded = null;\r\n        const splitPath = this.methodName.split('/');\r\n        let serviceName = '';\r\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\r\n         * by '/', the first item should be empty and the second should be the\r\n         * service name */\r\n        if (splitPath.length >= 2) {\r\n            serviceName = splitPath[1];\r\n        }\r\n        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\r\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\r\n         * can assume that the scheme is \"https\" */\r\n        this.serviceUrl = `https://${hostname}/${serviceName}`;\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\r\n    }\r\n    outputStatus(status, progress) {\r\n        var _a, _b;\r\n        if (!this.ended) {\r\n            this.ended = true;\r\n            this.trace('ended with status: code=' +\r\n                status.code +\r\n                ' details=\"' +\r\n                status.details +\r\n                '\"');\r\n            const finalStatus = Object.assign(Object.assign({}, status), { progress });\r\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);\r\n            (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);\r\n        }\r\n    }\r\n    doPick() {\r\n        var _a, _b;\r\n        if (this.ended) {\r\n            return;\r\n        }\r\n        if (!this.metadata) {\r\n            throw new Error('doPick called before start');\r\n        }\r\n        this.trace('Pick called');\r\n        const pickResult = this.channel.doPick(this.metadata, this.callConfig.pickInformation);\r\n        const subchannelString = pickResult.subchannel\r\n            ? '(' +\r\n                pickResult.subchannel.getChannelzRef().id +\r\n                ') ' +\r\n                pickResult.subchannel.getAddress()\r\n            : '' + pickResult.subchannel;\r\n        this.trace('Pick result: ' +\r\n            picker_1.PickResultType[pickResult.pickResultType] +\r\n            ' subchannel: ' +\r\n            subchannelString +\r\n            ' status: ' +\r\n            ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) +\r\n            ' ' +\r\n            ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\r\n        switch (pickResult.pickResultType) {\r\n            case picker_1.PickResultType.COMPLETE:\r\n                this.credentials\r\n                    .generateMetadata({ service_url: this.serviceUrl })\r\n                    .then(credsMetadata => {\r\n                    var _a, _b, _c;\r\n                    /* If this call was cancelled (e.g. by the deadline) before\r\n                     * metadata generation finished, we shouldn't do anything with\r\n                     * it. */\r\n                    if (this.ended) {\r\n                        this.trace('Credentials metadata generation finished after call ended');\r\n                        return;\r\n                    }\r\n                    const finalMetadata = this.metadata.clone();\r\n                    finalMetadata.merge(credsMetadata);\r\n                    if (finalMetadata.get('authorization').length > 1) {\r\n                        this.outputStatus({\r\n                            code: constants_1.Status.INTERNAL,\r\n                            details: '\"authorization\" metadata cannot have multiple values',\r\n                            metadata: new metadata_1.Metadata(),\r\n                        }, 'PROCESSED');\r\n                    }\r\n                    if (pickResult.subchannel.getConnectivityState() !==\r\n                        connectivity_state_1.ConnectivityState.READY) {\r\n                        this.trace('Picked subchannel ' +\r\n                            subchannelString +\r\n                            ' has state ' +\r\n                            connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] +\r\n                            ' after getting credentials metadata. Retrying pick');\r\n                        this.doPick();\r\n                        return;\r\n                    }\r\n                    if (this.deadline !== Infinity) {\r\n                        finalMetadata.set('grpc-timeout', (0, deadline_1.getDeadlineTimeoutString)(this.deadline));\r\n                    }\r\n                    try {\r\n                        this.child = pickResult\r\n                            .subchannel.getRealSubchannel()\r\n                            .createCall(finalMetadata, this.host, this.methodName, {\r\n                            onReceiveMetadata: metadata => {\r\n                                this.trace('Received metadata');\r\n                                this.listener.onReceiveMetadata(metadata);\r\n                            },\r\n                            onReceiveMessage: message => {\r\n                                this.trace('Received message');\r\n                                this.listener.onReceiveMessage(message);\r\n                            },\r\n                            onReceiveStatus: status => {\r\n                                this.trace('Received status');\r\n                                if (status.rstCode ===\r\n                                    http2.constants.NGHTTP2_REFUSED_STREAM) {\r\n                                    this.outputStatus(status, 'REFUSED');\r\n                                }\r\n                                else {\r\n                                    this.outputStatus(status, 'PROCESSED');\r\n                                }\r\n                            },\r\n                        });\r\n                    }\r\n                    catch (error) {\r\n                        this.trace('Failed to start call on picked subchannel ' +\r\n                            subchannelString +\r\n                            ' with error ' +\r\n                            error.message);\r\n                        this.outputStatus({\r\n                            code: constants_1.Status.INTERNAL,\r\n                            details: 'Failed to start HTTP/2 stream with error ' +\r\n                                error.message,\r\n                            metadata: new metadata_1.Metadata(),\r\n                        }, 'NOT_STARTED');\r\n                        return;\r\n                    }\r\n                    (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n                    (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\r\n                    this.onCallEnded = pickResult.onCallEnded;\r\n                    this.trace('Created child call [' + this.child.getCallNumber() + ']');\r\n                    if (this.readPending) {\r\n                        this.child.startRead();\r\n                    }\r\n                    if (this.pendingMessage) {\r\n                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\r\n                    }\r\n                    if (this.pendingHalfClose) {\r\n                        this.child.halfClose();\r\n                    }\r\n                }, (error) => {\r\n                    // We assume the error code isn't 0 (Status.OK)\r\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\r\n                    this.outputStatus({\r\n                        code: code,\r\n                        details: details,\r\n                        metadata: new metadata_1.Metadata(),\r\n                    }, 'PROCESSED');\r\n                });\r\n                break;\r\n            case picker_1.PickResultType.DROP:\r\n                const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\r\n                setImmediate(() => {\r\n                    this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'DROP');\r\n                });\r\n                break;\r\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\r\n                if (this.metadata.getOptions().waitForReady) {\r\n                    this.channel.queueCallForPick(this);\r\n                }\r\n                else {\r\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\r\n                    setImmediate(() => {\r\n                        this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'PROCESSED');\r\n                    });\r\n                }\r\n                break;\r\n            case picker_1.PickResultType.QUEUE:\r\n                this.channel.queueCallForPick(this);\r\n        }\r\n    }\r\n    cancelWithStatus(status, details) {\r\n        var _a;\r\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\r\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\r\n        this.outputStatus({ code: status, details: details, metadata: new metadata_1.Metadata() }, 'PROCESSED');\r\n    }\r\n    getPeer() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\r\n    }\r\n    start(metadata, listener) {\r\n        this.trace('start called');\r\n        this.listener = listener;\r\n        this.metadata = metadata;\r\n        this.doPick();\r\n    }\r\n    sendMessageWithContext(context, message) {\r\n        this.trace('write() called with message of length ' + message.length);\r\n        if (this.child) {\r\n            this.child.sendMessageWithContext(context, message);\r\n        }\r\n        else {\r\n            this.pendingMessage = { context, message };\r\n        }\r\n    }\r\n    startRead() {\r\n        this.trace('startRead called');\r\n        if (this.child) {\r\n            this.child.startRead();\r\n        }\r\n        else {\r\n            this.readPending = true;\r\n        }\r\n    }\r\n    halfClose() {\r\n        this.trace('halfClose called');\r\n        if (this.child) {\r\n            this.child.halfClose();\r\n        }\r\n        else {\r\n            this.pendingHalfClose = true;\r\n        }\r\n    }\r\n    setCredentials(credentials) {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    getCallNumber() {\r\n        return this.callNumber;\r\n    }\r\n}\r\nexports.LoadBalancingCall = LoadBalancingCall;\r\n//# sourceMappingURL=load-balancing-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6Qiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsK0JBQStCLG1CQUFPLENBQUMsb0dBQXdCO0FBQy9ELGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWSxFQUFFLFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTLEdBQUcsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhLFVBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsOEJBQThCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDRCQUE0QixnQkFBZ0IsMExBQTBMLGNBQWM7QUFDcFA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0Esd0NBQXdDLHFEQUFxRDtBQUM3RixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBLDRDQUE0QyxxREFBcUQ7QUFDakcscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFFQUFxRTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNpbmctY2FsbC5qcz9lYWE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkxvYWRCYWxhbmNpbmdDYWxsID0gdm9pZCAwO1xyXG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IGRlYWRsaW5lXzEgPSByZXF1aXJlKFwiLi9kZWFkbGluZVwiKTtcclxuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xyXG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcclxuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcclxuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEgPSByZXF1aXJlKFwiLi9jb250cm9sLXBsYW5lLXN0YXR1c1wiKTtcclxuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XHJcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ2xvYWRfYmFsYW5jaW5nX2NhbGwnO1xyXG5jbGFzcyBMb2FkQmFsYW5jaW5nQ2FsbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBjYWxsQ29uZmlnLCBtZXRob2ROYW1lLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XHJcbiAgICAgICAgdGhpcy5jYWxsQ29uZmlnID0gY2FsbENvbmZpZztcclxuICAgICAgICB0aGlzLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xyXG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xyXG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBkZWFkbGluZTtcclxuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xyXG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVhZFBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vbkNhbGxFbmRlZCA9IG51bGw7XHJcbiAgICAgICAgY29uc3Qgc3BsaXRQYXRoID0gdGhpcy5tZXRob2ROYW1lLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgbGV0IHNlcnZpY2VOYW1lID0gJyc7XHJcbiAgICAgICAgLyogVGhlIHN0YW5kYXJkIHBhdGggZm9ybWF0IGlzIFwiL3tzZXJ2aWNlTmFtZX0ve21ldGhvZE5hbWV9XCIsIHNvIGlmIHdlIHNwbGl0XHJcbiAgICAgICAgICogYnkgJy8nLCB0aGUgZmlyc3QgaXRlbSBzaG91bGQgYmUgZW1wdHkgYW5kIHRoZSBzZWNvbmQgc2hvdWxkIGJlIHRoZVxyXG4gICAgICAgICAqIHNlcnZpY2UgbmFtZSAqL1xyXG4gICAgICAgIGlmIChzcGxpdFBhdGgubGVuZ3RoID49IDIpIHtcclxuICAgICAgICAgICAgc2VydmljZU5hbWUgPSBzcGxpdFBhdGhbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gKF9iID0gKF9hID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0aGlzLmhvc3QpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaG9zdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2xvY2FsaG9zdCc7XHJcbiAgICAgICAgLyogQ3VycmVudGx5LCBjYWxsIGNyZWRlbnRpYWxzIGFyZSBvbmx5IGFsbG93ZWQgb24gSFRUUFMgY29ubmVjdGlvbnMsIHNvIHdlXHJcbiAgICAgICAgICogY2FuIGFzc3VtZSB0aGF0IHRoZSBzY2hlbWUgaXMgXCJodHRwc1wiICovXHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlVXJsID0gYGh0dHBzOi8vJHtob3N0bmFtZX0vJHtzZXJ2aWNlTmFtZX1gO1xyXG4gICAgfVxyXG4gICAgdHJhY2UodGV4dCkge1xyXG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJ1snICsgdGhpcy5jYWxsTnVtYmVyICsgJ10gJyArIHRleHQpO1xyXG4gICAgfVxyXG4gICAgb3V0cHV0U3RhdHVzKHN0YXR1cywgcHJvZ3Jlc3MpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICghdGhpcy5lbmRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmFjZSgnZW5kZWQgd2l0aCBzdGF0dXM6IGNvZGU9JyArXHJcbiAgICAgICAgICAgICAgICBzdGF0dXMuY29kZSArXHJcbiAgICAgICAgICAgICAgICAnIGRldGFpbHM9XCInICtcclxuICAgICAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzICtcclxuICAgICAgICAgICAgICAgICdcIicpO1xyXG4gICAgICAgICAgICBjb25zdCBmaW5hbFN0YXR1cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdHVzKSwgeyBwcm9ncmVzcyB9KTtcclxuICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUmVjZWl2ZVN0YXR1cyhmaW5hbFN0YXR1cyk7XHJcbiAgICAgICAgICAgIChfYiA9IHRoaXMub25DYWxsRW5kZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIGZpbmFsU3RhdHVzLmNvZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRvUGljaygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9QaWNrIGNhbGxlZCBiZWZvcmUgc3RhcnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFjZSgnUGljayBjYWxsZWQnKTtcclxuICAgICAgICBjb25zdCBwaWNrUmVzdWx0ID0gdGhpcy5jaGFubmVsLmRvUGljayh0aGlzLm1ldGFkYXRhLCB0aGlzLmNhbGxDb25maWcucGlja0luZm9ybWF0aW9uKTtcclxuICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RyaW5nID0gcGlja1Jlc3VsdC5zdWJjaGFubmVsXHJcbiAgICAgICAgICAgID8gJygnICtcclxuICAgICAgICAgICAgICAgIHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpLmlkICtcclxuICAgICAgICAgICAgICAgICcpICcgK1xyXG4gICAgICAgICAgICAgICAgcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldEFkZHJlc3MoKVxyXG4gICAgICAgICAgICA6ICcnICsgcGlja1Jlc3VsdC5zdWJjaGFubmVsO1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ1BpY2sgcmVzdWx0OiAnICtcclxuICAgICAgICAgICAgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGVbcGlja1Jlc3VsdC5waWNrUmVzdWx0VHlwZV0gK1xyXG4gICAgICAgICAgICAnIHN1YmNoYW5uZWw6ICcgK1xyXG4gICAgICAgICAgICBzdWJjaGFubmVsU3RyaW5nICtcclxuICAgICAgICAgICAgJyBzdGF0dXM6ICcgK1xyXG4gICAgICAgICAgICAoKF9hID0gcGlja1Jlc3VsdC5zdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSArXHJcbiAgICAgICAgICAgICcgJyArXHJcbiAgICAgICAgICAgICgoX2IgPSBwaWNrUmVzdWx0LnN0YXR1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRldGFpbHMpKTtcclxuICAgICAgICBzd2l0Y2ggKHBpY2tSZXN1bHQucGlja1Jlc3VsdFR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURTpcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgICAgICAuZ2VuZXJhdGVNZXRhZGF0YSh7IHNlcnZpY2VfdXJsOiB0aGlzLnNlcnZpY2VVcmwgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihjcmVkc01ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGlzIGNhbGwgd2FzIGNhbmNlbGxlZCAoZS5nLiBieSB0aGUgZGVhZGxpbmUpIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIG1ldGFkYXRhIGdlbmVyYXRpb24gZmluaXNoZWQsIHdlIHNob3VsZG4ndCBkbyBhbnl0aGluZyB3aXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICogaXQuICovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ3JlZGVudGlhbHMgbWV0YWRhdGEgZ2VuZXJhdGlvbiBmaW5pc2hlZCBhZnRlciBjYWxsIGVuZGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxNZXRhZGF0YSA9IHRoaXMubWV0YWRhdGEuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbE1ldGFkYXRhLm1lcmdlKGNyZWRzTWV0YWRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE1ldGFkYXRhLmdldCgnYXV0aG9yaXphdGlvbicpLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ1wiYXV0aG9yaXphdGlvblwiIG1ldGFkYXRhIGNhbm5vdCBoYXZlIG11bHRpcGxlIHZhbHVlcycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgJ1BST0NFU1NFRCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgIT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1BpY2tlZCBzdWJjaGFubmVsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGhhcyBzdGF0ZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3BpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGFmdGVyIGdldHRpbmcgY3JlZGVudGlhbHMgbWV0YWRhdGEuIFJldHJ5aW5nIHBpY2snKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1BpY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWFkbGluZSAhPT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxNZXRhZGF0YS5zZXQoJ2dycGMtdGltZW91dCcsICgwLCBkZWFkbGluZV8xLmdldERlYWRsaW5lVGltZW91dFN0cmluZykodGhpcy5kZWFkbGluZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkID0gcGlja1Jlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN1YmNoYW5uZWwuZ2V0UmVhbFN1YmNoYW5uZWwoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNyZWF0ZUNhbGwoZmluYWxNZXRhZGF0YSwgdGhpcy5ob3N0LCB0aGlzLm1ldGhvZE5hbWUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWV0YWRhdGEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiBtZXNzYWdlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBtZXNzYWdlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogc3RhdHVzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzdGF0dXMnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnJzdENvZGUgPT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX1JFRlVTRURfU1RSRUFNKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cywgJ1JFRlVTRUQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cywgJ1BST0NFU1NFRCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIHN0YXJ0IGNhbGwgb24gcGlja2VkIHN1YmNoYW5uZWwgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RyaW5nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgd2l0aCBlcnJvciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnRmFpbGVkIHRvIHN0YXJ0IEhUVFAvMiBzdHJlYW0gd2l0aCBlcnJvciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICdOT1RfU1RBUlRFRCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbENvbmZpZykub25Db21taXR0ZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcclxuICAgICAgICAgICAgICAgICAgICAoX2MgPSBwaWNrUmVzdWx0Lm9uQ2FsbFN0YXJ0ZWQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHBpY2tSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DYWxsRW5kZWQgPSBwaWNrUmVzdWx0Lm9uQ2FsbEVuZGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0NyZWF0ZWQgY2hpbGQgY2FsbCBbJyArIHRoaXMuY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkUGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0UmVhZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkLnNlbmRNZXNzYWdlV2l0aENvbnRleHQodGhpcy5wZW5kaW5nTWVzc2FnZS5jb250ZXh0LCB0aGlzLnBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGFsZkNsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuaGFsZkNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHRoZSBlcnJvciBjb2RlIGlzbid0IDAgKFN0YXR1cy5PSylcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkodHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInID8gZXJyb3IuY29kZSA6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLCBgR2V0dGluZyBtZXRhZGF0YSBmcm9tIHBsdWdpbiBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgJ1BST0NFU1NFRCcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5EUk9QOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSAoMCwgY29udHJvbF9wbGFuZV9zdGF0dXNfMS5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUpKHBpY2tSZXN1bHQuc3RhdHVzLmNvZGUsIHBpY2tSZXN1bHQuc3RhdHVzLmRldGFpbHMpO1xyXG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7IGNvZGUsIGRldGFpbHMsIG1ldGFkYXRhOiBwaWNrUmVzdWx0LnN0YXR1cy5tZXRhZGF0YSB9LCAnRFJPUCcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5UUkFOU0lFTlRfRkFJTFVSRTpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yUGljayh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gKDAsIGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKShwaWNrUmVzdWx0LnN0YXR1cy5jb2RlLCBwaWNrUmVzdWx0LnN0YXR1cy5kZXRhaWxzKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7IGNvZGUsIGRldGFpbHMsIG1ldGFkYXRhOiBwaWNrUmVzdWx0LnN0YXR1cy5tZXRhZGF0YSB9LCAnUFJPQ0VTU0VEJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5RVUVVRTpcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5xdWV1ZUNhbGxGb3JQaWNrKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbmNlbFdpdGhTdGF0dXMgY29kZTogJyArIHN0YXR1cyArICcgZGV0YWlsczogXCInICsgZGV0YWlscyArICdcIicpO1xyXG4gICAgICAgIChfYSA9IHRoaXMuY2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoeyBjb2RlOiBzdGF0dXMsIGRldGFpbHM6IGRldGFpbHMsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0sICdQUk9DRVNTRUQnKTtcclxuICAgIH1cclxuICAgIGdldFBlZXIoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5jaGFubmVsLmdldFRhcmdldCgpO1xyXG4gICAgfVxyXG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnQgY2FsbGVkJyk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgICAgICB0aGlzLmRvUGljaygpO1xyXG4gICAgfVxyXG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSB7IGNvbnRleHQsIG1lc3NhZ2UgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFydFJlYWQoKSB7XHJcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnRSZWFkIGNhbGxlZCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYWxmQ2xvc2UoKSB7XHJcbiAgICAgICAgdGhpcy50cmFjZSgnaGFsZkNsb3NlIGNhbGxlZCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuaGFsZkNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsTnVtYmVyO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTG9hZEJhbGFuY2luZ0NhbGwgPSBMb2FkQmFsYW5jaW5nQ2FsbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNpbmctY2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/logging.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nvar _a, _b, _c, _d;\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.isTracerEnabled = exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst process_1 = __webpack_require__(/*! process */ \"process\");\r\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@grpc/grpc-js/package.json\").version);\r\nconst DEFAULT_LOGGER = {\r\n    error: (message, ...optionalParams) => {\r\n        console.error('E ' + message, ...optionalParams);\r\n    },\r\n    info: (message, ...optionalParams) => {\r\n        console.error('I ' + message, ...optionalParams);\r\n    },\r\n    debug: (message, ...optionalParams) => {\r\n        console.error('D ' + message, ...optionalParams);\r\n    },\r\n};\r\nlet _logger = DEFAULT_LOGGER;\r\nlet _logVerbosity = constants_1.LogVerbosity.ERROR;\r\nconst verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : '';\r\nswitch (verbosityString.toUpperCase()) {\r\n    case 'DEBUG':\r\n        _logVerbosity = constants_1.LogVerbosity.DEBUG;\r\n        break;\r\n    case 'INFO':\r\n        _logVerbosity = constants_1.LogVerbosity.INFO;\r\n        break;\r\n    case 'ERROR':\r\n        _logVerbosity = constants_1.LogVerbosity.ERROR;\r\n        break;\r\n    case 'NONE':\r\n        _logVerbosity = constants_1.LogVerbosity.NONE;\r\n        break;\r\n    default:\r\n    // Ignore any other values\r\n}\r\nconst getLogger = () => {\r\n    return _logger;\r\n};\r\nexports.getLogger = getLogger;\r\nconst setLogger = (logger) => {\r\n    _logger = logger;\r\n};\r\nexports.setLogger = setLogger;\r\nconst setLoggerVerbosity = (verbosity) => {\r\n    _logVerbosity = verbosity;\r\n};\r\nexports.setLoggerVerbosity = setLoggerVerbosity;\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst log = (severity, ...args) => {\r\n    let logFunction;\r\n    if (severity >= _logVerbosity) {\r\n        switch (severity) {\r\n            case constants_1.LogVerbosity.DEBUG:\r\n                logFunction = _logger.debug;\r\n                break;\r\n            case constants_1.LogVerbosity.INFO:\r\n                logFunction = _logger.info;\r\n                break;\r\n            case constants_1.LogVerbosity.ERROR:\r\n                logFunction = _logger.error;\r\n                break;\r\n        }\r\n        /* Fall back to _logger.error when other methods are not available for\r\n         * compatiblity with older behavior that always logged to _logger.error */\r\n        if (!logFunction) {\r\n            logFunction = _logger.error;\r\n        }\r\n        if (logFunction) {\r\n            logFunction.bind(_logger)(...args);\r\n        }\r\n    }\r\n};\r\nexports.log = log;\r\nconst tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : '';\r\nconst enabledTracers = new Set();\r\nconst disabledTracers = new Set();\r\nfor (const tracerName of tracersString.split(',')) {\r\n    if (tracerName.startsWith('-')) {\r\n        disabledTracers.add(tracerName.substring(1));\r\n    }\r\n    else {\r\n        enabledTracers.add(tracerName);\r\n    }\r\n}\r\nconst allEnabled = enabledTracers.has('all');\r\nfunction trace(severity, tracer, text) {\r\n    if (isTracerEnabled(tracer)) {\r\n        (0, exports.log)(severity, new Date().toISOString() + ' | v' + clientVersion + ' ' + process_1.pid + ' | ' + tracer + ' | ' + text);\r\n    }\r\n}\r\nexports.trace = trace;\r\nfunction isTracerEnabled(tracer) {\r\n    return (!disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer)));\r\n}\r\nexports.isTracerEnabled = isTracerEnabled;\r\n//# sourceMappingURL=logging.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsYUFBYSxHQUFHLFdBQVcsR0FBRywwQkFBMEIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDMUgsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsd0JBQVM7QUFDbkMsc0JBQXNCLDBHQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcz80MmRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxudmFyIF9hLCBfYiwgX2MsIF9kO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuaXNUcmFjZXJFbmFibGVkID0gZXhwb3J0cy50cmFjZSA9IGV4cG9ydHMubG9nID0gZXhwb3J0cy5zZXRMb2dnZXJWZXJib3NpdHkgPSBleHBvcnRzLnNldExvZ2dlciA9IGV4cG9ydHMuZ2V0TG9nZ2VyID0gdm9pZCAwO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgcHJvY2Vzc18xID0gcmVxdWlyZShcInByb2Nlc3NcIik7XHJcbmNvbnN0IGNsaWVudFZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xyXG5jb25zdCBERUZBVUxUX0xPR0dFUiA9IHtcclxuICAgIGVycm9yOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XHJcbiAgICB9LFxyXG4gICAgaW5mbzogKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignSSAnICsgbWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xyXG4gICAgfSxcclxuICAgIGRlYnVnOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdEICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XHJcbiAgICB9LFxyXG59O1xyXG5sZXQgX2xvZ2dlciA9IERFRkFVTFRfTE9HR0VSO1xyXG5sZXQgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUjtcclxuY29uc3QgdmVyYm9zaXR5U3RyaW5nID0gKF9iID0gKF9hID0gcHJvY2Vzcy5lbnYuR1JQQ19OT0RFX1ZFUkJPU0lUWSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcHJvY2Vzcy5lbnYuR1JQQ19WRVJCT1NJVFkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xyXG5zd2l0Y2ggKHZlcmJvc2l0eVN0cmluZy50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICBjYXNlICdERUJVRyc6XHJcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRztcclxuICAgICAgICBicmVhaztcclxuICAgIGNhc2UgJ0lORk8nOlxyXG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTztcclxuICAgICAgICBicmVhaztcclxuICAgIGNhc2UgJ0VSUk9SJzpcclxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnTk9ORSc6XHJcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5OT05FO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgIC8vIElnbm9yZSBhbnkgb3RoZXIgdmFsdWVzXHJcbn1cclxuY29uc3QgZ2V0TG9nZ2VyID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIF9sb2dnZXI7XHJcbn07XHJcbmV4cG9ydHMuZ2V0TG9nZ2VyID0gZ2V0TG9nZ2VyO1xyXG5jb25zdCBzZXRMb2dnZXIgPSAobG9nZ2VyKSA9PiB7XHJcbiAgICBfbG9nZ2VyID0gbG9nZ2VyO1xyXG59O1xyXG5leHBvcnRzLnNldExvZ2dlciA9IHNldExvZ2dlcjtcclxuY29uc3Qgc2V0TG9nZ2VyVmVyYm9zaXR5ID0gKHZlcmJvc2l0eSkgPT4ge1xyXG4gICAgX2xvZ1ZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcclxufTtcclxuZXhwb3J0cy5zZXRMb2dnZXJWZXJib3NpdHkgPSBzZXRMb2dnZXJWZXJib3NpdHk7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbmNvbnN0IGxvZyA9IChzZXZlcml0eSwgLi4uYXJncykgPT4ge1xyXG4gICAgbGV0IGxvZ0Z1bmN0aW9uO1xyXG4gICAgaWYgKHNldmVyaXR5ID49IF9sb2dWZXJib3NpdHkpIHtcclxuICAgICAgICBzd2l0Y2ggKHNldmVyaXR5KSB7XHJcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHOlxyXG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmRlYnVnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk86XHJcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuaW5mbztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUjpcclxuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5lcnJvcjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBGYWxsIGJhY2sgdG8gX2xvZ2dlci5lcnJvciB3aGVuIG90aGVyIG1ldGhvZHMgYXJlIG5vdCBhdmFpbGFibGUgZm9yXHJcbiAgICAgICAgICogY29tcGF0aWJsaXR5IHdpdGggb2xkZXIgYmVoYXZpb3IgdGhhdCBhbHdheXMgbG9nZ2VkIHRvIF9sb2dnZXIuZXJyb3IgKi9cclxuICAgICAgICBpZiAoIWxvZ0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5lcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvZ0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIGxvZ0Z1bmN0aW9uLmJpbmQoX2xvZ2dlcikoLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5leHBvcnRzLmxvZyA9IGxvZztcclxuY29uc3QgdHJhY2Vyc1N0cmluZyA9IChfZCA9IChfYyA9IHByb2Nlc3MuZW52LkdSUENfTk9ERV9UUkFDRSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogcHJvY2Vzcy5lbnYuR1JQQ19UUkFDRSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJyc7XHJcbmNvbnN0IGVuYWJsZWRUcmFjZXJzID0gbmV3IFNldCgpO1xyXG5jb25zdCBkaXNhYmxlZFRyYWNlcnMgPSBuZXcgU2V0KCk7XHJcbmZvciAoY29uc3QgdHJhY2VyTmFtZSBvZiB0cmFjZXJzU3RyaW5nLnNwbGl0KCcsJykpIHtcclxuICAgIGlmICh0cmFjZXJOYW1lLnN0YXJ0c1dpdGgoJy0nKSkge1xyXG4gICAgICAgIGRpc2FibGVkVHJhY2Vycy5hZGQodHJhY2VyTmFtZS5zdWJzdHJpbmcoMSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZW5hYmxlZFRyYWNlcnMuYWRkKHRyYWNlck5hbWUpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGFsbEVuYWJsZWQgPSBlbmFibGVkVHJhY2Vycy5oYXMoJ2FsbCcpO1xyXG5mdW5jdGlvbiB0cmFjZShzZXZlcml0eSwgdHJhY2VyLCB0ZXh0KSB7XHJcbiAgICBpZiAoaXNUcmFjZXJFbmFibGVkKHRyYWNlcikpIHtcclxuICAgICAgICAoMCwgZXhwb3J0cy5sb2cpKHNldmVyaXR5LCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnIHwgdicgKyBjbGllbnRWZXJzaW9uICsgJyAnICsgcHJvY2Vzc18xLnBpZCArICcgfCAnICsgdHJhY2VyICsgJyB8ICcgKyB0ZXh0KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnRyYWNlID0gdHJhY2U7XHJcbmZ1bmN0aW9uIGlzVHJhY2VyRW5hYmxlZCh0cmFjZXIpIHtcclxuICAgIHJldHVybiAoIWRpc2FibGVkVHJhY2Vycy5oYXModHJhY2VyKSAmJiAoYWxsRW5hYmxlZCB8fCBlbmFibGVkVHJhY2Vycy5oYXModHJhY2VyKSkpO1xyXG59XHJcbmV4cG9ydHMuaXNUcmFjZXJFbmFibGVkID0gaXNUcmFjZXJFbmFibGVkO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/make-client.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.loadPackageDefinition = exports.makeClientConstructor = void 0;\r\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/client.js\");\r\n/**\r\n * Map with short names for each of the requester maker functions. Used in\r\n * makeClientConstructor\r\n * @private\r\n */\r\nconst requesterFuncs = {\r\n    unary: client_1.Client.prototype.makeUnaryRequest,\r\n    server_stream: client_1.Client.prototype.makeServerStreamRequest,\r\n    client_stream: client_1.Client.prototype.makeClientStreamRequest,\r\n    bidi: client_1.Client.prototype.makeBidiStreamRequest,\r\n};\r\n/**\r\n * Returns true, if given key is included in the blacklisted\r\n * keys.\r\n * @param key key for check, string.\r\n */\r\nfunction isPrototypePolluted(key) {\r\n    return ['__proto__', 'prototype', 'constructor'].includes(key);\r\n}\r\n/**\r\n * Creates a constructor for a client with the given methods, as specified in\r\n * the methods argument. The resulting class will have an instance method for\r\n * each method in the service, which is a partial application of one of the\r\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\r\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\r\n * arguments predefined.\r\n * @param methods An object mapping method names to\r\n *     method attributes\r\n * @param serviceName The fully qualified name of the service\r\n * @param classOptions An options object.\r\n * @return New client constructor, which is a subclass of\r\n *     {@link grpc.Client}, and has the same arguments as that constructor.\r\n */\r\nfunction makeClientConstructor(methods, serviceName, classOptions) {\r\n    if (!classOptions) {\r\n        classOptions = {};\r\n    }\r\n    class ServiceClientImpl extends client_1.Client {\r\n    }\r\n    Object.keys(methods).forEach(name => {\r\n        if (isPrototypePolluted(name)) {\r\n            return;\r\n        }\r\n        const attrs = methods[name];\r\n        let methodType;\r\n        // TODO(murgatroid99): Verify that we don't need this anymore\r\n        if (typeof name === 'string' && name.charAt(0) === '$') {\r\n            throw new Error('Method names cannot start with $');\r\n        }\r\n        if (attrs.requestStream) {\r\n            if (attrs.responseStream) {\r\n                methodType = 'bidi';\r\n            }\r\n            else {\r\n                methodType = 'client_stream';\r\n            }\r\n        }\r\n        else {\r\n            if (attrs.responseStream) {\r\n                methodType = 'server_stream';\r\n            }\r\n            else {\r\n                methodType = 'unary';\r\n            }\r\n        }\r\n        const serialize = attrs.requestSerialize;\r\n        const deserialize = attrs.responseDeserialize;\r\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\r\n        ServiceClientImpl.prototype[name] = methodFunc;\r\n        // Associate all provided attributes with the method\r\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\r\n        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\r\n            ServiceClientImpl.prototype[attrs.originalName] =\r\n                ServiceClientImpl.prototype[name];\r\n        }\r\n    });\r\n    ServiceClientImpl.service = methods;\r\n    ServiceClientImpl.serviceName = serviceName;\r\n    return ServiceClientImpl;\r\n}\r\nexports.makeClientConstructor = makeClientConstructor;\r\nfunction partial(fn, path, serialize, deserialize) {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    return function (...args) {\r\n        return fn.call(this, path, serialize, deserialize, ...args);\r\n    };\r\n}\r\nfunction isProtobufTypeDefinition(obj) {\r\n    return 'format' in obj;\r\n}\r\n/**\r\n * Load a gRPC package definition as a gRPC object hierarchy.\r\n * @param packageDef The package definition object.\r\n * @return The resulting gRPC object.\r\n */\r\nfunction loadPackageDefinition(packageDef) {\r\n    const result = {};\r\n    for (const serviceFqn in packageDef) {\r\n        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\r\n            const service = packageDef[serviceFqn];\r\n            const nameComponents = serviceFqn.split('.');\r\n            if (nameComponents.some((comp) => isPrototypePolluted(comp))) {\r\n                continue;\r\n            }\r\n            const serviceName = nameComponents[nameComponents.length - 1];\r\n            let current = result;\r\n            for (const packageName of nameComponents.slice(0, -1)) {\r\n                if (!current[packageName]) {\r\n                    current[packageName] = {};\r\n                }\r\n                current = current[packageName];\r\n            }\r\n            if (isProtobufTypeDefinition(service)) {\r\n                current[serviceName] = service;\r\n            }\r\n            else {\r\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.loadPackageDefinition = loadPackageDefinition;\r\n//# sourceMappingURL=make-client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWFrZS1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyw2QkFBNkI7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tYWtlLWNsaWVudC5qcz81ODE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmxvYWRQYWNrYWdlRGVmaW5pdGlvbiA9IGV4cG9ydHMubWFrZUNsaWVudENvbnN0cnVjdG9yID0gdm9pZCAwO1xyXG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcclxuLyoqXHJcbiAqIE1hcCB3aXRoIHNob3J0IG5hbWVzIGZvciBlYWNoIG9mIHRoZSByZXF1ZXN0ZXIgbWFrZXIgZnVuY3Rpb25zLiBVc2VkIGluXHJcbiAqIG1ha2VDbGllbnRDb25zdHJ1Y3RvclxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgcmVxdWVzdGVyRnVuY3MgPSB7XHJcbiAgICB1bmFyeTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlVW5hcnlSZXF1ZXN0LFxyXG4gICAgc2VydmVyX3N0cmVhbTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlU2VydmVyU3RyZWFtUmVxdWVzdCxcclxuICAgIGNsaWVudF9zdHJlYW06IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZUNsaWVudFN0cmVhbVJlcXVlc3QsXHJcbiAgICBiaWRpOiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VCaWRpU3RyZWFtUmVxdWVzdCxcclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSwgaWYgZ2l2ZW4ga2V5IGlzIGluY2x1ZGVkIGluIHRoZSBibGFja2xpc3RlZFxyXG4gKiBrZXlzLlxyXG4gKiBAcGFyYW0ga2V5IGtleSBmb3IgY2hlY2ssIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGlzUHJvdG90eXBlUG9sbHV0ZWQoa2V5KSB7XHJcbiAgICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5jbHVkZXMoa2V5KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNvbnN0cnVjdG9yIGZvciBhIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBtZXRob2RzLCBhcyBzcGVjaWZpZWQgaW5cclxuICogdGhlIG1ldGhvZHMgYXJndW1lbnQuIFRoZSByZXN1bHRpbmcgY2xhc3Mgd2lsbCBoYXZlIGFuIGluc3RhbmNlIG1ldGhvZCBmb3JcclxuICogZWFjaCBtZXRob2QgaW4gdGhlIHNlcnZpY2UsIHdoaWNoIGlzIGEgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBvbmUgb2YgdGhlXHJcbiAqIFtDbGllbnRde0BsaW5rIGdycGMuQ2xpZW50fSByZXF1ZXN0IG1ldGhvZHMsIGRlcGVuZGluZyBvbiBgcmVxdWVzdFNlcmlhbGl6ZWBcclxuICogYW5kIGByZXNwb25zZVNlcmlhbGl6ZWAsIHdpdGggdGhlIGBtZXRob2RgLCBgc2VyaWFsaXplYCwgYW5kIGBkZXNlcmlhbGl6ZWBcclxuICogYXJndW1lbnRzIHByZWRlZmluZWQuXHJcbiAqIEBwYXJhbSBtZXRob2RzIEFuIG9iamVjdCBtYXBwaW5nIG1ldGhvZCBuYW1lcyB0b1xyXG4gKiAgICAgbWV0aG9kIGF0dHJpYnV0ZXNcclxuICogQHBhcmFtIHNlcnZpY2VOYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvZiB0aGUgc2VydmljZVxyXG4gKiBAcGFyYW0gY2xhc3NPcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LlxyXG4gKiBAcmV0dXJuIE5ldyBjbGllbnQgY29uc3RydWN0b3IsIHdoaWNoIGlzIGEgc3ViY2xhc3Mgb2ZcclxuICogICAgIHtAbGluayBncnBjLkNsaWVudH0sIGFuZCBoYXMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHRoYXQgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlQ2xpZW50Q29uc3RydWN0b3IobWV0aG9kcywgc2VydmljZU5hbWUsIGNsYXNzT3B0aW9ucykge1xyXG4gICAgaWYgKCFjbGFzc09wdGlvbnMpIHtcclxuICAgICAgICBjbGFzc09wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuICAgIGNsYXNzIFNlcnZpY2VDbGllbnRJbXBsIGV4dGVuZHMgY2xpZW50XzEuQ2xpZW50IHtcclxuICAgIH1cclxuICAgIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2gobmFtZSA9PiB7XHJcbiAgICAgICAgaWYgKGlzUHJvdG90eXBlUG9sbHV0ZWQobmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhdHRycyA9IG1ldGhvZHNbbmFtZV07XHJcbiAgICAgICAgbGV0IG1ldGhvZFR5cGU7XHJcbiAgICAgICAgLy8gVE9ETyhtdXJnYXRyb2lkOTkpOiBWZXJpZnkgdGhhdCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgbmFtZS5jaGFyQXQoMCkgPT09ICckJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCAkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhdHRycy5yZXF1ZXN0U3RyZWFtKSB7XHJcbiAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdiaWRpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnY2xpZW50X3N0cmVhbSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdzZXJ2ZXJfc3RyZWFtJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAndW5hcnknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZSA9IGF0dHJzLnJlcXVlc3RTZXJpYWxpemU7XHJcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemUgPSBhdHRycy5yZXNwb25zZURlc2VyaWFsaXplO1xyXG4gICAgICAgIGNvbnN0IG1ldGhvZEZ1bmMgPSBwYXJ0aWFsKHJlcXVlc3RlckZ1bmNzW21ldGhvZFR5cGVdLCBhdHRycy5wYXRoLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplKTtcclxuICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV0gPSBtZXRob2RGdW5jO1xyXG4gICAgICAgIC8vIEFzc29jaWF0ZSBhbGwgcHJvdmlkZWQgYXR0cmlidXRlcyB3aXRoIHRoZSBtZXRob2RcclxuICAgICAgICBPYmplY3QuYXNzaWduKFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVtuYW1lXSwgYXR0cnMpO1xyXG4gICAgICAgIGlmIChhdHRycy5vcmlnaW5hbE5hbWUgJiYgIWlzUHJvdG90eXBlUG9sbHV0ZWQoYXR0cnMub3JpZ2luYWxOYW1lKSkge1xyXG4gICAgICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbYXR0cnMub3JpZ2luYWxOYW1lXSA9XHJcbiAgICAgICAgICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBTZXJ2aWNlQ2xpZW50SW1wbC5zZXJ2aWNlID0gbWV0aG9kcztcclxuICAgIFNlcnZpY2VDbGllbnRJbXBsLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XHJcbiAgICByZXR1cm4gU2VydmljZUNsaWVudEltcGw7XHJcbn1cclxuZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSBtYWtlQ2xpZW50Q29uc3RydWN0b3I7XHJcbmZ1bmN0aW9uIHBhcnRpYWwoZm4sIHBhdGgsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBwYXRoLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCAuLi5hcmdzKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNQcm90b2J1ZlR5cGVEZWZpbml0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuICdmb3JtYXQnIGluIG9iajtcclxufVxyXG4vKipcclxuICogTG9hZCBhIGdSUEMgcGFja2FnZSBkZWZpbml0aW9uIGFzIGEgZ1JQQyBvYmplY3QgaGllcmFyY2h5LlxyXG4gKiBAcGFyYW0gcGFja2FnZURlZiBUaGUgcGFja2FnZSBkZWZpbml0aW9uIG9iamVjdC5cclxuICogQHJldHVybiBUaGUgcmVzdWx0aW5nIGdSUEMgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gbG9hZFBhY2thZ2VEZWZpbml0aW9uKHBhY2thZ2VEZWYpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBzZXJ2aWNlRnFuIGluIHBhY2thZ2VEZWYpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhY2thZ2VEZWYsIHNlcnZpY2VGcW4pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwYWNrYWdlRGVmW3NlcnZpY2VGcW5dO1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lQ29tcG9uZW50cyA9IHNlcnZpY2VGcW4uc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgaWYgKG5hbWVDb21wb25lbnRzLnNvbWUoKGNvbXApID0+IGlzUHJvdG90eXBlUG9sbHV0ZWQoY29tcCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlTmFtZSA9IG5hbWVDb21wb25lbnRzW25hbWVDb21wb25lbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHJlc3VsdDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwYWNrYWdlTmFtZSBvZiBuYW1lQ29tcG9uZW50cy5zbGljZSgwLCAtMSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFtwYWNrYWdlTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50W3BhY2thZ2VOYW1lXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFja2FnZU5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1Byb3RvYnVmVHlwZURlZmluaXRpb24oc2VydmljZSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRbc2VydmljZU5hbWVdID0gc2VydmljZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRbc2VydmljZU5hbWVdID0gbWFrZUNsaWVudENvbnN0cnVjdG9yKHNlcnZpY2UsIHNlcnZpY2VOYW1lLCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gbG9hZFBhY2thZ2VEZWZpbml0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/make-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/metadata.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Metadata = void 0;\r\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\");\r\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\r\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\r\nfunction isLegalKey(key) {\r\n    return LEGAL_KEY_REGEX.test(key);\r\n}\r\nfunction isLegalNonBinaryValue(value) {\r\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\r\n}\r\nfunction isBinaryKey(key) {\r\n    return key.endsWith('-bin');\r\n}\r\nfunction isCustomMetadata(key) {\r\n    return !key.startsWith('grpc-');\r\n}\r\nfunction normalizeKey(key) {\r\n    return key.toLowerCase();\r\n}\r\nfunction validate(key, value) {\r\n    if (!isLegalKey(key)) {\r\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\r\n    }\r\n    if (value !== null && value !== undefined) {\r\n        if (isBinaryKey(key)) {\r\n            if (!Buffer.isBuffer(value)) {\r\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\r\n            }\r\n        }\r\n        else {\r\n            if (Buffer.isBuffer(value)) {\r\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\r\n            }\r\n            if (!isLegalNonBinaryValue(value)) {\r\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\r\n */\r\nclass Metadata {\r\n    constructor(options = {}) {\r\n        this.internalRepr = new Map();\r\n        this.options = options;\r\n    }\r\n    /**\r\n     * Sets the given value for the given key by replacing any other values\r\n     * associated with that key. Normalizes the key.\r\n     * @param key The key to whose value should be set.\r\n     * @param value The value to set. Must be a buffer if and only\r\n     *   if the normalized key ends with '-bin'.\r\n     */\r\n    set(key, value) {\r\n        key = normalizeKey(key);\r\n        validate(key, value);\r\n        this.internalRepr.set(key, [value]);\r\n    }\r\n    /**\r\n     * Adds the given value for the given key by appending to a list of previous\r\n     * values associated with that key. Normalizes the key.\r\n     * @param key The key for which a new value should be appended.\r\n     * @param value The value to add. Must be a buffer if and only\r\n     *   if the normalized key ends with '-bin'.\r\n     */\r\n    add(key, value) {\r\n        key = normalizeKey(key);\r\n        validate(key, value);\r\n        const existingValue = this.internalRepr.get(key);\r\n        if (existingValue === undefined) {\r\n            this.internalRepr.set(key, [value]);\r\n        }\r\n        else {\r\n            existingValue.push(value);\r\n        }\r\n    }\r\n    /**\r\n     * Removes the given key and any associated values. Normalizes the key.\r\n     * @param key The key whose values should be removed.\r\n     */\r\n    remove(key) {\r\n        key = normalizeKey(key);\r\n        // validate(key);\r\n        this.internalRepr.delete(key);\r\n    }\r\n    /**\r\n     * Gets a list of all values associated with the key. Normalizes the key.\r\n     * @param key The key whose value should be retrieved.\r\n     * @return A list of values associated with the given key.\r\n     */\r\n    get(key) {\r\n        key = normalizeKey(key);\r\n        // validate(key);\r\n        return this.internalRepr.get(key) || [];\r\n    }\r\n    /**\r\n     * Gets a plain object mapping each key to the first value associated with it.\r\n     * This reflects the most common way that people will want to see metadata.\r\n     * @return A key/value mapping of the metadata.\r\n     */\r\n    getMap() {\r\n        const result = {};\r\n        for (const [key, values] of this.internalRepr) {\r\n            if (values.length > 0) {\r\n                const v = values[0];\r\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Clones the metadata object.\r\n     * @return The newly cloned object.\r\n     */\r\n    clone() {\r\n        const newMetadata = new Metadata(this.options);\r\n        const newInternalRepr = newMetadata.internalRepr;\r\n        for (const [key, value] of this.internalRepr) {\r\n            const clonedValue = value.map(v => {\r\n                if (Buffer.isBuffer(v)) {\r\n                    return Buffer.from(v);\r\n                }\r\n                else {\r\n                    return v;\r\n                }\r\n            });\r\n            newInternalRepr.set(key, clonedValue);\r\n        }\r\n        return newMetadata;\r\n    }\r\n    /**\r\n     * Merges all key-value pairs from a given Metadata object into this one.\r\n     * If both this object and the given object have values in the same key,\r\n     * values from the other Metadata object will be appended to this object's\r\n     * values.\r\n     * @param other A Metadata object.\r\n     */\r\n    merge(other) {\r\n        for (const [key, values] of other.internalRepr) {\r\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\r\n            this.internalRepr.set(key, mergedValue);\r\n        }\r\n    }\r\n    setOptions(options) {\r\n        this.options = options;\r\n    }\r\n    getOptions() {\r\n        return this.options;\r\n    }\r\n    /**\r\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\r\n     */\r\n    toHttp2Headers() {\r\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\r\n        const result = {};\r\n        for (const [key, values] of this.internalRepr) {\r\n            // We assume that the user's interaction with this object is limited to\r\n            // through its public API (i.e. keys and values are already validated).\r\n            result[key] = values.map(bufToString);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * This modifies the behavior of JSON.stringify to show an object\r\n     * representation of the metadata map.\r\n     */\r\n    toJSON() {\r\n        const result = {};\r\n        for (const [key, values] of this.internalRepr) {\r\n            result[key] = values;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\r\n     * object.\r\n     * @param headers An IncomingHttpHeaders object.\r\n     */\r\n    static fromHttp2Headers(headers) {\r\n        const result = new Metadata();\r\n        for (const key of Object.keys(headers)) {\r\n            // Reserved headers (beginning with `:`) are not valid keys.\r\n            if (key.charAt(0) === ':') {\r\n                continue;\r\n            }\r\n            const values = headers[key];\r\n            try {\r\n                if (isBinaryKey(key)) {\r\n                    if (Array.isArray(values)) {\r\n                        values.forEach(value => {\r\n                            result.add(key, Buffer.from(value, 'base64'));\r\n                        });\r\n                    }\r\n                    else if (values !== undefined) {\r\n                        if (isCustomMetadata(key)) {\r\n                            values.split(',').forEach(v => {\r\n                                result.add(key, Buffer.from(v.trim(), 'base64'));\r\n                            });\r\n                        }\r\n                        else {\r\n                            result.add(key, Buffer.from(values, 'base64'));\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (Array.isArray(values)) {\r\n                        values.forEach(value => {\r\n                            result.add(key, value);\r\n                        });\r\n                    }\r\n                    else if (values !== undefined) {\r\n                        result.add(key, values);\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\r\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.Metadata = Metadata;\r\nconst bufToString = (val) => {\r\n    return Buffer.isBuffer(val) ? val.toString('base64') : val;\r\n};\r\n//# sourceMappingURL=metadata.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsa0JBQWtCLG1CQUFPLENBQUMsMEVBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsSUFBSSxJQUFJLE9BQU8sSUFBSSxvQ0FBb0M7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tZXRhZGF0YS5qcz9lZGM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLk1ldGFkYXRhID0gdm9pZCAwO1xyXG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xyXG5jb25zdCBMRUdBTF9LRVlfUkVHRVggPSAvXlswLTlhLXpfLi1dKyQvO1xyXG5jb25zdCBMRUdBTF9OT05fQklOQVJZX1ZBTFVFX1JFR0VYID0gL15bIC1+XSokLztcclxuZnVuY3Rpb24gaXNMZWdhbEtleShrZXkpIHtcclxuICAgIHJldHVybiBMRUdBTF9LRVlfUkVHRVgudGVzdChrZXkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzTGVnYWxOb25CaW5hcnlWYWx1ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIExFR0FMX05PTl9CSU5BUllfVkFMVUVfUkVHRVgudGVzdCh2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gaXNCaW5hcnlLZXkoa2V5KSB7XHJcbiAgICByZXR1cm4ga2V5LmVuZHNXaXRoKCctYmluJyk7XHJcbn1cclxuZnVuY3Rpb24gaXNDdXN0b21NZXRhZGF0YShrZXkpIHtcclxuICAgIHJldHVybiAha2V5LnN0YXJ0c1dpdGgoJ2dycGMtJyk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlKGtleSwgdmFsdWUpIHtcclxuICAgIGlmICghaXNMZWdhbEtleShrZXkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhZGF0YSBrZXkgXCInICsga2V5ICsgJ1wiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycycpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoaXNCaW5hcnlLZXkoa2V5KSkge1xyXG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleXMgdGhhdCBlbmQgd2l0aCAnLWJpbicgbXVzdCBoYXZlIEJ1ZmZlciB2YWx1ZXNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZG9uJ3QgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBTdHJpbmcgdmFsdWVzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNMZWdhbE5vbkJpbmFyeVZhbHVlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhZGF0YSBzdHJpbmcgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIHN0b3JpbmcgbWV0YWRhdGEuIEtleXMgYXJlIG5vcm1hbGl6ZWQgdG8gbG93ZXJjYXNlIEFTQ0lJLlxyXG4gKi9cclxuY2xhc3MgTWV0YWRhdGEge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkgYnkgcmVwbGFjaW5nIGFueSBvdGhlciB2YWx1ZXNcclxuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHdob3NlIHZhbHVlIHNob3VsZCBiZSBzZXQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC4gTXVzdCBiZSBhIGJ1ZmZlciBpZiBhbmQgb25seVxyXG4gICAgICogICBpZiB0aGUgbm9ybWFsaXplZCBrZXkgZW5kcyB3aXRoICctYmluJy5cclxuICAgICAqL1xyXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZShrZXksIHZhbHVlKTtcclxuICAgICAgICB0aGlzLmludGVybmFsUmVwci5zZXQoa2V5LCBbdmFsdWVdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkgYnkgYXBwZW5kaW5nIHRvIGEgbGlzdCBvZiBwcmV2aW91c1xyXG4gICAgICogdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IGZvciB3aGljaCBhIG5ldyB2YWx1ZSBzaG91bGQgYmUgYXBwZW5kZWQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZC4gTXVzdCBiZSBhIGJ1ZmZlciBpZiBhbmQgb25seVxyXG4gICAgICogICBpZiB0aGUgbm9ybWFsaXplZCBrZXkgZW5kcyB3aXRoICctYmluJy5cclxuICAgICAqL1xyXG4gICAgYWRkKGtleSwgdmFsdWUpIHtcclxuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZShrZXksIHZhbHVlKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gdGhpcy5pbnRlcm5hbFJlcHIuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nVmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVwci5zZXQoa2V5LCBbdmFsdWVdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBrZXkgYW5kIGFueSBhc3NvY2lhdGVkIHZhbHVlcy4gTm9ybWFsaXplcyB0aGUga2V5LlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHdob3NlIHZhbHVlcyBzaG91bGQgYmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSkge1xyXG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xyXG4gICAgICAgIC8vIHZhbGlkYXRlKGtleSk7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuZGVsZXRlKGtleSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBsaXN0IG9mIGFsbCB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkuIE5vcm1hbGl6ZXMgdGhlIGtleS5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgcmV0cmlldmVkLlxyXG4gICAgICogQHJldHVybiBBIGxpc3Qgb2YgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxyXG4gICAgICovXHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XHJcbiAgICAgICAgLy8gdmFsaWRhdGUoa2V5KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFJlcHIuZ2V0KGtleSkgfHwgW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBwbGFpbiBvYmplY3QgbWFwcGluZyBlYWNoIGtleSB0byB0aGUgZmlyc3QgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0LlxyXG4gICAgICogVGhpcyByZWZsZWN0cyB0aGUgbW9zdCBjb21tb24gd2F5IHRoYXQgcGVvcGxlIHdpbGwgd2FudCB0byBzZWUgbWV0YWRhdGEuXHJcbiAgICAgKiBAcmV0dXJuIEEga2V5L3ZhbHVlIG1hcHBpbmcgb2YgdGhlIG1ldGFkYXRhLlxyXG4gICAgICovXHJcbiAgICBnZXRNYXAoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlc1swXTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gQnVmZmVyLmlzQnVmZmVyKHYpID8gQnVmZmVyLmZyb20odikgOiB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsb25lcyB0aGUgbWV0YWRhdGEgb2JqZWN0LlxyXG4gICAgICogQHJldHVybiBUaGUgbmV3bHkgY2xvbmVkIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgY29uc3QgbmV3TWV0YWRhdGEgPSBuZXcgTWV0YWRhdGEodGhpcy5vcHRpb25zKTtcclxuICAgICAgICBjb25zdCBuZXdJbnRlcm5hbFJlcHIgPSBuZXdNZXRhZGF0YS5pbnRlcm5hbFJlcHI7XHJcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcclxuICAgICAgICAgICAgY29uc3QgY2xvbmVkVmFsdWUgPSB2YWx1ZS5tYXAodiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBuZXdJbnRlcm5hbFJlcHIuc2V0KGtleSwgY2xvbmVkVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3TWV0YWRhdGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlcyBhbGwga2V5LXZhbHVlIHBhaXJzIGZyb20gYSBnaXZlbiBNZXRhZGF0YSBvYmplY3QgaW50byB0aGlzIG9uZS5cclxuICAgICAqIElmIGJvdGggdGhpcyBvYmplY3QgYW5kIHRoZSBnaXZlbiBvYmplY3QgaGF2ZSB2YWx1ZXMgaW4gdGhlIHNhbWUga2V5LFxyXG4gICAgICogdmFsdWVzIGZyb20gdGhlIG90aGVyIE1ldGFkYXRhIG9iamVjdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoaXMgb2JqZWN0J3NcclxuICAgICAqIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSBvdGhlciBBIE1ldGFkYXRhIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgbWVyZ2Uob3RoZXIpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2Ygb3RoZXIuaW50ZXJuYWxSZXByKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZFZhbHVlID0gKHRoaXMuaW50ZXJuYWxSZXByLmdldChrZXkpIHx8IFtdKS5jb25jYXQodmFsdWVzKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuc2V0KGtleSwgbWVyZ2VkVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBnZXRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gT3V0Z29pbmdIdHRwSGVhZGVycyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHRoZSBodHRwMiBBUEkuXHJcbiAgICAgKi9cclxuICAgIHRvSHR0cDJIZWFkZXJzKCkge1xyXG4gICAgICAgIC8vIE5PVEU6IE5vZGUgPDguOSBmb3JtYXRzIGh0dHAyIGhlYWRlcnMgaW5jb3JyZWN0bHkuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gd2l0aCB0aGlzIG9iamVjdCBpcyBsaW1pdGVkIHRvXHJcbiAgICAgICAgICAgIC8vIHRocm91Z2ggaXRzIHB1YmxpYyBBUEkgKGkuZS4ga2V5cyBhbmQgdmFsdWVzIGFyZSBhbHJlYWR5IHZhbGlkYXRlZCkuXHJcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzLm1hcChidWZUb1N0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbW9kaWZpZXMgdGhlIGJlaGF2aW9yIG9mIEpTT04uc3RyaW5naWZ5IHRvIHNob3cgYW4gb2JqZWN0XHJcbiAgICAgKiByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWV0YWRhdGEgbWFwLlxyXG4gICAgICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IE1ldGFkYXRhIG9iamVjdCBiYXNlZCBmaWVsZHMgaW4gYSBnaXZlbiBJbmNvbWluZ0h0dHBIZWFkZXJzXHJcbiAgICAgKiBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gaGVhZGVycyBBbiBJbmNvbWluZ0h0dHBIZWFkZXJzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21IdHRwMkhlYWRlcnMoaGVhZGVycykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNZXRhZGF0YSgpO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc2VydmVkIGhlYWRlcnMgKGJlZ2lubmluZyB3aXRoIGA6YCkgYXJlIG5vdCB2YWxpZCBrZXlzLlxyXG4gICAgICAgICAgICBpZiAoa2V5LmNoYXJBdCgwKSA9PT0gJzonKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBoZWFkZXJzW2tleV07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNCaW5hcnlLZXkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHZhbHVlLCAnYmFzZTY0JykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VzdG9tTWV0YWRhdGEoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNwbGl0KCcsJykuZm9yRWFjaCh2ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGtleSwgQnVmZmVyLmZyb20odi50cmltKCksICdiYXNlNjQnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCBCdWZmZXIuZnJvbSh2YWx1ZXMsICdiYXNlNjQnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGtleSwgdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZhaWxlZCB0byBhZGQgbWV0YWRhdGEgZW50cnkgJHtrZXl9OiAke3ZhbHVlc30uICR7KDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnJvcil9LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL2lzc3Vlcy8xMTczYDtcclxuICAgICAgICAgICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5NZXRhZGF0YSA9IE1ldGFkYXRhO1xyXG5jb25zdCBidWZUb1N0cmluZyA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsKSA/IHZhbC50b1N0cmluZygnYmFzZTY0JykgOiB2YWw7XHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFkYXRhLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/picker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nvar PickResultType;\r\n(function (PickResultType) {\r\n    PickResultType[PickResultType[\"COMPLETE\"] = 0] = \"COMPLETE\";\r\n    PickResultType[PickResultType[\"QUEUE\"] = 1] = \"QUEUE\";\r\n    PickResultType[PickResultType[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\r\n    PickResultType[PickResultType[\"DROP\"] = 3] = \"DROP\";\r\n})(PickResultType || (exports.PickResultType = PickResultType = {}));\r\n/**\r\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\r\n * state. Always responds to every pick request with an UNAVAILABLE status.\r\n */\r\nclass UnavailablePicker {\r\n    constructor(status) {\r\n        this.status = Object.assign({ code: constants_1.Status.UNAVAILABLE, details: 'No connection established', metadata: new metadata_1.Metadata() }, status);\r\n    }\r\n    pick(pickArgs) {\r\n        return {\r\n            pickResultType: PickResultType.TRANSIENT_FAILURE,\r\n            subchannel: null,\r\n            status: this.status,\r\n            onCallStarted: null,\r\n            onCallEnded: null,\r\n        };\r\n    }\r\n}\r\nexports.UnavailablePicker = UnavailablePicker;\r\n/**\r\n * A standard picker representing a load balancer in the IDLE or CONNECTING\r\n * state. Always responds to every pick request with a QUEUE pick result\r\n * indicating that the pick should be tried again with the next `Picker`. Also\r\n * reports back to the load balancer that a connection should be established\r\n * once any pick is attempted.\r\n */\r\nclass QueuePicker {\r\n    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\r\n    constructor(loadBalancer) {\r\n        this.loadBalancer = loadBalancer;\r\n        this.calledExitIdle = false;\r\n    }\r\n    pick(pickArgs) {\r\n        if (!this.calledExitIdle) {\r\n            process.nextTick(() => {\r\n                this.loadBalancer.exitIdle();\r\n            });\r\n            this.calledExitIdle = true;\r\n        }\r\n        return {\r\n            pickResultType: PickResultType.QUEUE,\r\n            subchannel: null,\r\n            status: null,\r\n            onCallStarted: null,\r\n            onCallEnded: null,\r\n        };\r\n    }\r\n}\r\nexports.QueuePicker = QueuePicker;\r\n//# sourceMappingURL=picker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCO0FBQ3hFLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNCQUFzQixzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlIQUFpSDtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzPzIxOGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuUXVldWVQaWNrZXIgPSBleHBvcnRzLlVuYXZhaWxhYmxlUGlja2VyID0gZXhwb3J0cy5QaWNrUmVzdWx0VHlwZSA9IHZvaWQgMDtcclxuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxudmFyIFBpY2tSZXN1bHRUeXBlO1xyXG4oZnVuY3Rpb24gKFBpY2tSZXN1bHRUeXBlKSB7XHJcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIkNPTVBMRVRFXCJdID0gMF0gPSBcIkNPTVBMRVRFXCI7XHJcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIlFVRVVFXCJdID0gMV0gPSBcIlFVRVVFXCI7XHJcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIlRSQU5TSUVOVF9GQUlMVVJFXCJdID0gMl0gPSBcIlRSQU5TSUVOVF9GQUlMVVJFXCI7XHJcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIkRST1BcIl0gPSAzXSA9IFwiRFJPUFwiO1xyXG59KShQaWNrUmVzdWx0VHlwZSB8fCAoZXhwb3J0cy5QaWNrUmVzdWx0VHlwZSA9IFBpY2tSZXN1bHRUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIEEgc3RhbmRhcmQgcGlja2VyIHJlcHJlc2VudGluZyBhIGxvYWQgYmFsYW5jZXIgaW4gdGhlIFRSQU5TSUVOVF9GQUlMVVJFXHJcbiAqIHN0YXRlLiBBbHdheXMgcmVzcG9uZHMgdG8gZXZlcnkgcGljayByZXF1ZXN0IHdpdGggYW4gVU5BVkFJTEFCTEUgc3RhdHVzLlxyXG4gKi9cclxuY2xhc3MgVW5hdmFpbGFibGVQaWNrZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc3RhdHVzKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBPYmplY3QuYXNzaWduKHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLCBkZXRhaWxzOiAnTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZCcsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0sIHN0YXR1cyk7XHJcbiAgICB9XHJcbiAgICBwaWNrKHBpY2tBcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcGlja1Jlc3VsdFR5cGU6IFBpY2tSZXN1bHRUeXBlLlRSQU5TSUVOVF9GQUlMVVJFLFxyXG4gICAgICAgICAgICBzdWJjaGFubmVsOiBudWxsLFxyXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxyXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxyXG4gICAgICAgICAgICBvbkNhbGxFbmRlZDogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuVW5hdmFpbGFibGVQaWNrZXIgPSBVbmF2YWlsYWJsZVBpY2tlcjtcclxuLyoqXHJcbiAqIEEgc3RhbmRhcmQgcGlja2VyIHJlcHJlc2VudGluZyBhIGxvYWQgYmFsYW5jZXIgaW4gdGhlIElETEUgb3IgQ09OTkVDVElOR1xyXG4gKiBzdGF0ZS4gQWx3YXlzIHJlc3BvbmRzIHRvIGV2ZXJ5IHBpY2sgcmVxdWVzdCB3aXRoIGEgUVVFVUUgcGljayByZXN1bHRcclxuICogaW5kaWNhdGluZyB0aGF0IHRoZSBwaWNrIHNob3VsZCBiZSB0cmllZCBhZ2FpbiB3aXRoIHRoZSBuZXh0IGBQaWNrZXJgLiBBbHNvXHJcbiAqIHJlcG9ydHMgYmFjayB0byB0aGUgbG9hZCBiYWxhbmNlciB0aGF0IGEgY29ubmVjdGlvbiBzaG91bGQgYmUgZXN0YWJsaXNoZWRcclxuICogb25jZSBhbnkgcGljayBpcyBhdHRlbXB0ZWQuXHJcbiAqL1xyXG5jbGFzcyBRdWV1ZVBpY2tlciB7XHJcbiAgICAvLyBDb25zdHJ1Y3RlZCB3aXRoIGEgbG9hZCBiYWxhbmNlci4gQ2FsbHMgZXhpdElkbGUgb24gaXQgdGhlIGZpcnN0IHRpbWUgcGljayBpcyBjYWxsZWRcclxuICAgIGNvbnN0cnVjdG9yKGxvYWRCYWxhbmNlcikge1xyXG4gICAgICAgIHRoaXMubG9hZEJhbGFuY2VyID0gbG9hZEJhbGFuY2VyO1xyXG4gICAgICAgIHRoaXMuY2FsbGVkRXhpdElkbGUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHBpY2socGlja0FyZ3MpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2FsbGVkRXhpdElkbGUpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5jYWxsZWRFeGl0SWRsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBQaWNrUmVzdWx0VHlwZS5RVUVVRSxcclxuICAgICAgICAgICAgc3ViY2hhbm5lbDogbnVsbCxcclxuICAgICAgICAgICAgc3RhdHVzOiBudWxsLFxyXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxyXG4gICAgICAgICAgICBvbkNhbGxFbmRlZDogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUXVldWVQaWNrZXIgPSBRdWV1ZVBpY2tlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlja2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-dns.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.setup = exports.DEFAULT_PORT = void 0;\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst dns = __webpack_require__(/*! dns */ \"dns\");\r\nconst util = __webpack_require__(/*! util */ \"util\");\r\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\r\nconst TRACER_NAME = 'dns_resolver';\r\nfunction trace(text) {\r\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\n/**\r\n * The default TCP port to connect to if not explicitly specified in the target.\r\n */\r\nexports.DEFAULT_PORT = 443;\r\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\r\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\r\nconst dnsLookupPromise = util.promisify(dns.lookup);\r\n/**\r\n * Merge any number of arrays into a single alternating array\r\n * @param arrays\r\n */\r\nfunction mergeArrays(...arrays) {\r\n    const result = [];\r\n    for (let i = 0; i <\r\n        Math.max.apply(null, arrays.map(array => array.length)); i++) {\r\n        for (const array of arrays) {\r\n            if (i < array.length) {\r\n                result.push(array[i]);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Resolver implementation that handles DNS names and IP addresses.\r\n */\r\nclass DnsResolver {\r\n    constructor(target, listener, channelOptions) {\r\n        var _a, _b, _c;\r\n        this.target = target;\r\n        this.listener = listener;\r\n        this.pendingLookupPromise = null;\r\n        this.pendingTxtPromise = null;\r\n        this.latestLookupResult = null;\r\n        this.latestServiceConfig = null;\r\n        this.latestServiceConfigError = null;\r\n        this.continueResolving = false;\r\n        this.isNextResolutionTimerRunning = false;\r\n        this.isServiceConfigEnabled = true;\r\n        this.returnedIpResult = false;\r\n        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));\r\n        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\r\n        if (hostPort === null) {\r\n            this.ipResult = null;\r\n            this.dnsHostname = null;\r\n            this.port = null;\r\n        }\r\n        else {\r\n            if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {\r\n                this.ipResult = [\r\n                    {\r\n                        host: hostPort.host,\r\n                        port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : exports.DEFAULT_PORT,\r\n                    },\r\n                ];\r\n                this.dnsHostname = null;\r\n                this.port = null;\r\n            }\r\n            else {\r\n                this.ipResult = null;\r\n                this.dnsHostname = hostPort.host;\r\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : exports.DEFAULT_PORT;\r\n            }\r\n        }\r\n        this.percentage = Math.random() * 100;\r\n        if (channelOptions['grpc.service_config_disable_resolution'] === 1) {\r\n            this.isServiceConfigEnabled = false;\r\n        }\r\n        this.defaultResolutionError = {\r\n            code: constants_1.Status.UNAVAILABLE,\r\n            details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,\r\n            metadata: new metadata_1.Metadata(),\r\n        };\r\n        const backoffOptions = {\r\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\r\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\r\n        };\r\n        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {\r\n            if (this.continueResolving) {\r\n                this.startResolutionWithBackoff();\r\n            }\r\n        }, backoffOptions);\r\n        this.backoff.unref();\r\n        this.minTimeBetweenResolutionsMs =\r\n            (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\r\n        this.nextResolutionTimer = setTimeout(() => { }, 0);\r\n        clearTimeout(this.nextResolutionTimer);\r\n    }\r\n    /**\r\n     * If the target is an IP address, just provide that address as a result.\r\n     * Otherwise, initiate A, AAAA, and TXT lookups\r\n     */\r\n    startResolution() {\r\n        if (this.ipResult !== null) {\r\n            if (!this.returnedIpResult) {\r\n                trace('Returning IP address for target ' + (0, uri_parser_1.uriToString)(this.target));\r\n                setImmediate(() => {\r\n                    this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\r\n                });\r\n                this.returnedIpResult = true;\r\n            }\r\n            this.backoff.stop();\r\n            this.backoff.reset();\r\n            this.stopNextResolutionTimer();\r\n            return;\r\n        }\r\n        if (this.dnsHostname === null) {\r\n            trace('Failed to parse DNS address ' + (0, uri_parser_1.uriToString)(this.target));\r\n            setImmediate(() => {\r\n                this.listener.onError({\r\n                    code: constants_1.Status.UNAVAILABLE,\r\n                    details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,\r\n                    metadata: new metadata_1.Metadata(),\r\n                });\r\n            });\r\n            this.stopNextResolutionTimer();\r\n        }\r\n        else {\r\n            if (this.pendingLookupPromise !== null) {\r\n                return;\r\n            }\r\n            trace('Looking up DNS hostname ' + this.dnsHostname);\r\n            /* We clear out latestLookupResult here to ensure that it contains the\r\n             * latest result since the last time we started resolving. That way, the\r\n             * TXT resolution handler can use it, but only if it finishes second. We\r\n             * don't clear out any previous service config results because it's\r\n             * better to use a service config that's slightly out of date than to\r\n             * revert to an effectively blank one. */\r\n            this.latestLookupResult = null;\r\n            const hostname = this.dnsHostname;\r\n            /* We lookup both address families here and then split them up later\r\n             * because when looking up a single family, dns.lookup outputs an error\r\n             * if the name exists but there are no records for that family, and that\r\n             * error is indistinguishable from other kinds of errors */\r\n            this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });\r\n            this.pendingLookupPromise.then(addressList => {\r\n                if (this.pendingLookupPromise === null) {\r\n                    return;\r\n                }\r\n                this.pendingLookupPromise = null;\r\n                this.backoff.reset();\r\n                this.backoff.stop();\r\n                const ip4Addresses = addressList.filter(addr => addr.family === 4);\r\n                const ip6Addresses = addressList.filter(addr => addr.family === 6);\r\n                this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map(addr => ({ host: addr.address, port: +this.port }));\r\n                const allAddressesString = '[' +\r\n                    this.latestLookupResult\r\n                        .map(addr => addr.host + ':' + addr.port)\r\n                        .join(',') +\r\n                    ']';\r\n                trace('Resolved addresses for target ' +\r\n                    (0, uri_parser_1.uriToString)(this.target) +\r\n                    ': ' +\r\n                    allAddressesString);\r\n                if (this.latestLookupResult.length === 0) {\r\n                    this.listener.onError(this.defaultResolutionError);\r\n                    return;\r\n                }\r\n                /* If the TXT lookup has not yet finished, both of the last two\r\n                 * arguments will be null, which is the equivalent of getting an\r\n                 * empty TXT response. When the TXT lookup does finish, its handler\r\n                 * can update the service config by using the same address list */\r\n                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\r\n            }, err => {\r\n                if (this.pendingLookupPromise === null) {\r\n                    return;\r\n                }\r\n                trace('Resolution error for target ' +\r\n                    (0, uri_parser_1.uriToString)(this.target) +\r\n                    ': ' +\r\n                    err.message);\r\n                this.pendingLookupPromise = null;\r\n                this.stopNextResolutionTimer();\r\n                this.listener.onError(this.defaultResolutionError);\r\n            });\r\n            /* If there already is a still-pending TXT resolution, we can just use\r\n             * that result when it comes in */\r\n            if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {\r\n                /* We handle the TXT query promise differently than the others because\r\n                 * the name resolution attempt as a whole is a success even if the TXT\r\n                 * lookup fails */\r\n                this.pendingTxtPromise = resolveTxtPromise(hostname);\r\n                this.pendingTxtPromise.then(txtRecord => {\r\n                    if (this.pendingTxtPromise === null) {\r\n                        return;\r\n                    }\r\n                    this.pendingTxtPromise = null;\r\n                    try {\r\n                        this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);\r\n                    }\r\n                    catch (err) {\r\n                        this.latestServiceConfigError = {\r\n                            code: constants_1.Status.UNAVAILABLE,\r\n                            details: `Parsing service config failed with error ${err.message}`,\r\n                            metadata: new metadata_1.Metadata(),\r\n                        };\r\n                    }\r\n                    if (this.latestLookupResult !== null) {\r\n                        /* We rely here on the assumption that calling this function with\r\n                         * identical parameters will be essentialy idempotent, and calling\r\n                         * it with the same address list and a different service config\r\n                         * should result in a fast and seamless switchover. */\r\n                        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\r\n                    }\r\n                }, err => {\r\n                    /* If TXT lookup fails we should do nothing, which means that we\r\n                     * continue to use the result of the most recent successful lookup,\r\n                     * or the default null config object if there has never been a\r\n                     * successful lookup. We do not set the latestServiceConfigError\r\n                     * here because that is specifically used for response validation\r\n                     * errors. We still need to handle this error so that it does not\r\n                     * bubble up as an unhandled promise rejection. */\r\n                });\r\n            }\r\n        }\r\n    }\r\n    startNextResolutionTimer() {\r\n        var _a, _b;\r\n        clearTimeout(this.nextResolutionTimer);\r\n        this.nextResolutionTimer = (_b = (_a = setTimeout(() => {\r\n            this.stopNextResolutionTimer();\r\n            if (this.continueResolving) {\r\n                this.startResolutionWithBackoff();\r\n            }\r\n        }, this.minTimeBetweenResolutionsMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        this.isNextResolutionTimerRunning = true;\r\n    }\r\n    stopNextResolutionTimer() {\r\n        clearTimeout(this.nextResolutionTimer);\r\n        this.isNextResolutionTimerRunning = false;\r\n    }\r\n    startResolutionWithBackoff() {\r\n        if (this.pendingLookupPromise === null) {\r\n            this.continueResolving = false;\r\n            this.backoff.runOnce();\r\n            this.startNextResolutionTimer();\r\n            this.startResolution();\r\n        }\r\n    }\r\n    updateResolution() {\r\n        /* If there is a pending lookup, just let it finish. Otherwise, if the\r\n         * nextResolutionTimer or backoff timer is running, set the\r\n         * continueResolving flag to resolve when whichever of those timers\r\n         * fires. Otherwise, start resolving immediately. */\r\n        if (this.pendingLookupPromise === null) {\r\n            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\r\n                if (this.isNextResolutionTimerRunning) {\r\n                    trace('resolution update delayed by \"min time between resolutions\" rate limit');\r\n                }\r\n                else {\r\n                    trace('resolution update delayed by backoff timer until ' + this.backoff.getEndTime().toISOString());\r\n                }\r\n                this.continueResolving = true;\r\n            }\r\n            else {\r\n                this.startResolutionWithBackoff();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Reset the resolver to the same state it had when it was created. In-flight\r\n     * DNS requests cannot be cancelled, but they are discarded and their results\r\n     * will be ignored.\r\n     */\r\n    destroy() {\r\n        this.continueResolving = false;\r\n        this.backoff.reset();\r\n        this.backoff.stop();\r\n        this.stopNextResolutionTimer();\r\n        this.pendingLookupPromise = null;\r\n        this.pendingTxtPromise = null;\r\n        this.latestLookupResult = null;\r\n        this.latestServiceConfig = null;\r\n        this.latestServiceConfigError = null;\r\n        this.returnedIpResult = false;\r\n    }\r\n    /**\r\n     * Get the default authority for the given target. For IP targets, that is\r\n     * the IP address. For DNS targets, it is the hostname.\r\n     * @param target\r\n     */\r\n    static getDefaultAuthority(target) {\r\n        return target.path;\r\n    }\r\n}\r\n/**\r\n * Set up the DNS resolver class by registering it as the handler for the\r\n * \"dns:\" prefix and as the default resolver.\r\n */\r\nfunction setup() {\r\n    (0, resolver_1.registerResolver)('dns', DnsResolver);\r\n    (0, resolver_1.registerDefaultScheme)('dns');\r\n}\r\nexports.setup = setup;\r\n//# sourceMappingURL=resolver-dns.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItZG5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxvQkFBb0I7QUFDcEMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsMkNBQTJDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMkNBQTJDO0FBQ3ZHO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxXQUFXO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxzQ0FBc0M7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtJQUErSTtBQUMvSSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFlBQVk7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVKQUF1SjtBQUN2SjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLWRucy5qcz80MmMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnNldHVwID0gZXhwb3J0cy5ERUZBVUxUX1BPUlQgPSB2b2lkIDA7XHJcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcclxuY29uc3QgZG5zID0gcmVxdWlyZShcImRuc1wiKTtcclxuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xyXG5jb25zdCBzZXJ2aWNlX2NvbmZpZ18xID0gcmVxdWlyZShcIi4vc2VydmljZS1jb25maWdcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBjb25zdGFudHNfMiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcclxuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xyXG5jb25zdCBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcclxuY29uc3QgVFJBQ0VSX05BTUUgPSAnZG5zX3Jlc29sdmVyJztcclxuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xyXG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMi5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcclxufVxyXG4vKipcclxuICogVGhlIGRlZmF1bHQgVENQIHBvcnQgdG8gY29ubmVjdCB0byBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlIHRhcmdldC5cclxuICovXHJcbmV4cG9ydHMuREVGQVVMVF9QT1JUID0gNDQzO1xyXG5jb25zdCBERUZBVUxUX01JTl9USU1FX0JFVFdFRU5fUkVTT0xVVElPTlNfTVMgPSAzMDAwMDtcclxuY29uc3QgcmVzb2x2ZVR4dFByb21pc2UgPSB1dGlsLnByb21pc2lmeShkbnMucmVzb2x2ZVR4dCk7XHJcbmNvbnN0IGRuc0xvb2t1cFByb21pc2UgPSB1dGlsLnByb21pc2lmeShkbnMubG9va3VwKTtcclxuLyoqXHJcbiAqIE1lcmdlIGFueSBudW1iZXIgb2YgYXJyYXlzIGludG8gYSBzaW5nbGUgYWx0ZXJuYXRpbmcgYXJyYXlcclxuICogQHBhcmFtIGFycmF5c1xyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VBcnJheXMoLi4uYXJyYXlzKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDxcclxuICAgICAgICBNYXRoLm1heC5hcHBseShudWxsLCBhcnJheXMubWFwKGFycmF5ID0+IGFycmF5Lmxlbmd0aCkpOyBpKyspIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGFycmF5IG9mIGFycmF5cykge1xyXG4gICAgICAgICAgICBpZiAoaSA8IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogUmVzb2x2ZXIgaW1wbGVtZW50YXRpb24gdGhhdCBoYW5kbGVzIEROUyBuYW1lcyBhbmQgSVAgYWRkcmVzc2VzLlxyXG4gKi9cclxuY2xhc3MgRG5zUmVzb2x2ZXIge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzU2VydmljZUNvbmZpZ0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucmV0dXJuZWRJcFJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgIHRyYWNlKCdSZXNvbHZlciBjb25zdHJ1Y3RlZCBmb3IgdGFyZ2V0ICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpKTtcclxuICAgICAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0LnBhdGgpO1xyXG4gICAgICAgIGlmIChob3N0UG9ydCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmlwUmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucG9ydCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoKDAsIG5ldF8xLmlzSVB2NCkoaG9zdFBvcnQuaG9zdCkgfHwgKDAsIG5ldF8xLmlzSVB2NikoaG9zdFBvcnQuaG9zdCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXBSZXN1bHQgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBob3N0UG9ydC5ob3N0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiAoX2EgPSBob3N0UG9ydC5wb3J0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleHBvcnRzLkRFRkFVTFRfUE9SVCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG5zSG9zdG5hbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXBSZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IGhvc3RQb3J0Lmhvc3Q7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnQgPSAoX2IgPSBob3N0UG9ydC5wb3J0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBleHBvcnRzLkRFRkFVTFRfUE9SVDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBlcmNlbnRhZ2UgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xyXG4gICAgICAgIGlmIChjaGFubmVsT3B0aW9uc1snZ3JwYy5zZXJ2aWNlX2NvbmZpZ19kaXNhYmxlX3Jlc29sdXRpb24nXSA9PT0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLmlzU2VydmljZUNvbmZpZ0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0UmVzb2x1dGlvbkVycm9yID0ge1xyXG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXHJcbiAgICAgICAgICAgIGRldGFpbHM6IGBOYW1lIHJlc29sdXRpb24gZmFpbGVkIGZvciB0YXJnZXQgJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCl9YCxcclxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBiYWNrb2ZmT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXHJcbiAgICAgICAgICAgIG1heERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYmFja29mZiA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlUmVzb2x2aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBiYWNrb2ZmT3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnVucmVmKCk7XHJcbiAgICAgICAgdGhpcy5taW5UaW1lQmV0d2VlblJlc29sdXRpb25zTXMgPVxyXG4gICAgICAgICAgICAoX2MgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5kbnNfbWluX3RpbWVfYmV0d2Vlbl9yZXNvbHV0aW9uc19tcyddKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01JTl9USU1FX0JFVFdFRU5fUkVTT0xVVElPTlNfTVM7XHJcbiAgICAgICAgdGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgdGFyZ2V0IGlzIGFuIElQIGFkZHJlc3MsIGp1c3QgcHJvdmlkZSB0aGF0IGFkZHJlc3MgYXMgYSByZXN1bHQuXHJcbiAgICAgKiBPdGhlcndpc2UsIGluaXRpYXRlIEEsIEFBQUEsIGFuZCBUWFQgbG9va3Vwc1xyXG4gICAgICovXHJcbiAgICBzdGFydFJlc29sdXRpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXBSZXN1bHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJldHVybmVkSXBSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNlKCdSZXR1cm5pbmcgSVAgYWRkcmVzcyBmb3IgdGFyZ2V0ICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkpO1xyXG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24odGhpcy5pcFJlc3VsdCwgbnVsbCwgbnVsbCwgbnVsbCwge30pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVybmVkSXBSZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZG5zSG9zdG5hbWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdHJhY2UoJ0ZhaWxlZCB0byBwYXJzZSBETlMgYWRkcmVzcyAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpKTtcclxuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxyXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgRE5TIGFkZHJlc3MgJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCl9YCxcclxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cmFjZSgnTG9va2luZyB1cCBETlMgaG9zdG5hbWUgJyArIHRoaXMuZG5zSG9zdG5hbWUpO1xyXG4gICAgICAgICAgICAvKiBXZSBjbGVhciBvdXQgbGF0ZXN0TG9va3VwUmVzdWx0IGhlcmUgdG8gZW5zdXJlIHRoYXQgaXQgY29udGFpbnMgdGhlXHJcbiAgICAgICAgICAgICAqIGxhdGVzdCByZXN1bHQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzdGFydGVkIHJlc29sdmluZy4gVGhhdCB3YXksIHRoZVxyXG4gICAgICAgICAgICAgKiBUWFQgcmVzb2x1dGlvbiBoYW5kbGVyIGNhbiB1c2UgaXQsIGJ1dCBvbmx5IGlmIGl0IGZpbmlzaGVzIHNlY29uZC4gV2VcclxuICAgICAgICAgICAgICogZG9uJ3QgY2xlYXIgb3V0IGFueSBwcmV2aW91cyBzZXJ2aWNlIGNvbmZpZyByZXN1bHRzIGJlY2F1c2UgaXQnc1xyXG4gICAgICAgICAgICAgKiBiZXR0ZXIgdG8gdXNlIGEgc2VydmljZSBjb25maWcgdGhhdCdzIHNsaWdodGx5IG91dCBvZiBkYXRlIHRoYW4gdG9cclxuICAgICAgICAgICAgICogcmV2ZXJ0IHRvIGFuIGVmZmVjdGl2ZWx5IGJsYW5rIG9uZS4gKi9cclxuICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBob3N0bmFtZSA9IHRoaXMuZG5zSG9zdG5hbWU7XHJcbiAgICAgICAgICAgIC8qIFdlIGxvb2t1cCBib3RoIGFkZHJlc3MgZmFtaWxpZXMgaGVyZSBhbmQgdGhlbiBzcGxpdCB0aGVtIHVwIGxhdGVyXHJcbiAgICAgICAgICAgICAqIGJlY2F1c2Ugd2hlbiBsb29raW5nIHVwIGEgc2luZ2xlIGZhbWlseSwgZG5zLmxvb2t1cCBvdXRwdXRzIGFuIGVycm9yXHJcbiAgICAgICAgICAgICAqIGlmIHRoZSBuYW1lIGV4aXN0cyBidXQgdGhlcmUgYXJlIG5vIHJlY29yZHMgZm9yIHRoYXQgZmFtaWx5LCBhbmQgdGhhdFxyXG4gICAgICAgICAgICAgKiBlcnJvciBpcyBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIG90aGVyIGtpbmRzIG9mIGVycm9ycyAqL1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gZG5zTG9va3VwUHJvbWlzZShob3N0bmFtZSwgeyBhbGw6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UudGhlbihhZGRyZXNzTGlzdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmYuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXA0QWRkcmVzc2VzID0gYWRkcmVzc0xpc3QuZmlsdGVyKGFkZHIgPT4gYWRkci5mYW1pbHkgPT09IDQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXA2QWRkcmVzc2VzID0gYWRkcmVzc0xpc3QuZmlsdGVyKGFkZHIgPT4gYWRkci5mYW1pbHkgPT09IDYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBtZXJnZUFycmF5cyhpcDZBZGRyZXNzZXMsIGlwNEFkZHJlc3NlcykubWFwKGFkZHIgPT4gKHsgaG9zdDogYWRkci5hZGRyZXNzLCBwb3J0OiArdGhpcy5wb3J0IH0pKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbEFkZHJlc3Nlc1N0cmluZyA9ICdbJyArXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChhZGRyID0+IGFkZHIuaG9zdCArICc6JyArIGFkZHIucG9ydClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJ10nO1xyXG4gICAgICAgICAgICAgICAgdHJhY2UoJ1Jlc29sdmVkIGFkZHJlc3NlcyBmb3IgdGFyZ2V0ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsQWRkcmVzc2VzU3RyaW5nKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdExvb2t1cFJlc3VsdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uRXJyb3IodGhpcy5kZWZhdWx0UmVzb2x1dGlvbkVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgVFhUIGxvb2t1cCBoYXMgbm90IHlldCBmaW5pc2hlZCwgYm90aCBvZiB0aGUgbGFzdCB0d29cclxuICAgICAgICAgICAgICAgICAqIGFyZ3VtZW50cyB3aWxsIGJlIG51bGwsIHdoaWNoIGlzIHRoZSBlcXVpdmFsZW50IG9mIGdldHRpbmcgYW5cclxuICAgICAgICAgICAgICAgICAqIGVtcHR5IFRYVCByZXNwb25zZS4gV2hlbiB0aGUgVFhUIGxvb2t1cCBkb2VzIGZpbmlzaCwgaXRzIGhhbmRsZXJcclxuICAgICAgICAgICAgICAgICAqIGNhbiB1cGRhdGUgdGhlIHNlcnZpY2UgY29uZmlnIGJ5IHVzaW5nIHRoZSBzYW1lIGFkZHJlc3MgbGlzdCAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0LCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yLCBudWxsLCB7fSk7XHJcbiAgICAgICAgICAgIH0sIGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyYWNlKCdSZXNvbHV0aW9uIGVycm9yIGZvciB0YXJnZXQgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcclxuICAgICAgICAgICAgICAgICAgICAnOiAnICtcclxuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLyogSWYgdGhlcmUgYWxyZWFkeSBpcyBhIHN0aWxsLXBlbmRpbmcgVFhUIHJlc29sdXRpb24sIHdlIGNhbiBqdXN0IHVzZVxyXG4gICAgICAgICAgICAgKiB0aGF0IHJlc3VsdCB3aGVuIGl0IGNvbWVzIGluICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2VydmljZUNvbmZpZ0VuYWJsZWQgJiYgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLyogV2UgaGFuZGxlIHRoZSBUWFQgcXVlcnkgcHJvbWlzZSBkaWZmZXJlbnRseSB0aGFuIHRoZSBvdGhlcnMgYmVjYXVzZVxyXG4gICAgICAgICAgICAgICAgICogdGhlIG5hbWUgcmVzb2x1dGlvbiBhdHRlbXB0IGFzIGEgd2hvbGUgaXMgYSBzdWNjZXNzIGV2ZW4gaWYgdGhlIFRYVFxyXG4gICAgICAgICAgICAgICAgICogbG9va3VwIGZhaWxzICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gcmVzb2x2ZVR4dFByb21pc2UoaG9zdG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZS50aGVuKHR4dFJlY29yZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1R4dFByb21pc2UgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcgPSAoMCwgc2VydmljZV9jb25maWdfMS5leHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZykodHh0UmVjb3JkLCB0aGlzLnBlcmNlbnRhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFBhcnNpbmcgc2VydmljZSBjb25maWcgZmFpbGVkIHdpdGggZXJyb3IgJHtlcnIubWVzc2FnZX1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBXZSByZWx5IGhlcmUgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpZGVudGljYWwgcGFyYW1ldGVycyB3aWxsIGJlIGVzc2VudGlhbHkgaWRlbXBvdGVudCwgYW5kIGNhbGxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogaXQgd2l0aCB0aGUgc2FtZSBhZGRyZXNzIGxpc3QgYW5kIGEgZGlmZmVyZW50IHNlcnZpY2UgY29uZmlnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNob3VsZCByZXN1bHQgaW4gYSBmYXN0IGFuZCBzZWFtbGVzcyBzd2l0Y2hvdmVyLiAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24odGhpcy5sYXRlc3RMb29rdXBSZXN1bHQsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZywgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IsIG51bGwsIHt9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCBlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIElmIFRYVCBsb29rdXAgZmFpbHMgd2Ugc2hvdWxkIGRvIG5vdGhpbmcsIHdoaWNoIG1lYW5zIHRoYXQgd2VcclxuICAgICAgICAgICAgICAgICAgICAgKiBjb250aW51ZSB0byB1c2UgdGhlIHJlc3VsdCBvZiB0aGUgbW9zdCByZWNlbnQgc3VjY2Vzc2Z1bCBsb29rdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICogb3IgdGhlIGRlZmF1bHQgbnVsbCBjb25maWcgb2JqZWN0IGlmIHRoZXJlIGhhcyBuZXZlciBiZWVuIGFcclxuICAgICAgICAgICAgICAgICAgICAgKiBzdWNjZXNzZnVsIGxvb2t1cC4gV2UgZG8gbm90IHNldCB0aGUgbGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICogaGVyZSBiZWNhdXNlIHRoYXQgaXMgc3BlY2lmaWNhbGx5IHVzZWQgZm9yIHJlc3BvbnNlIHZhbGlkYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgKiBlcnJvcnMuIFdlIHN0aWxsIG5lZWQgdG8gaGFuZGxlIHRoaXMgZXJyb3Igc28gdGhhdCBpdCBkb2VzIG5vdFxyXG4gICAgICAgICAgICAgICAgICAgICAqIGJ1YmJsZSB1cCBhcyBhbiB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24uICovXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0TmV4dFJlc29sdXRpb25UaW1lcigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpO1xyXG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25UaW1lciA9IChfYiA9IChfYSA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlUmVzb2x2aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzLm1pblRpbWVCZXR3ZWVuUmVzb2x1dGlvbnNNcykpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpO1xyXG4gICAgICAgIHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucnVuT25jZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmV4dFJlc29sdXRpb25UaW1lcigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XHJcbiAgICAgICAgLyogSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGxvb2t1cCwganVzdCBsZXQgaXQgZmluaXNoLiBPdGhlcndpc2UsIGlmIHRoZVxyXG4gICAgICAgICAqIG5leHRSZXNvbHV0aW9uVGltZXIgb3IgYmFja29mZiB0aW1lciBpcyBydW5uaW5nLCBzZXQgdGhlXHJcbiAgICAgICAgICogY29udGludWVSZXNvbHZpbmcgZmxhZyB0byByZXNvbHZlIHdoZW4gd2hpY2hldmVyIG9mIHRob3NlIHRpbWVyc1xyXG4gICAgICAgICAqIGZpcmVzLiBPdGhlcndpc2UsIHN0YXJ0IHJlc29sdmluZyBpbW1lZGlhdGVseS4gKi9cclxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nIHx8IHRoaXMuYmFja29mZi5pc1J1bm5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdyZXNvbHV0aW9uIHVwZGF0ZSBkZWxheWVkIGJ5IFwibWluIHRpbWUgYmV0d2VlbiByZXNvbHV0aW9uc1wiIHJhdGUgbGltaXQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdyZXNvbHV0aW9uIHVwZGF0ZSBkZWxheWVkIGJ5IGJhY2tvZmYgdGltZXIgdW50aWwgJyArIHRoaXMuYmFja29mZi5nZXRFbmRUaW1lKCkudG9JU09TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIHJlc29sdmVyIHRvIHRoZSBzYW1lIHN0YXRlIGl0IGhhZCB3aGVuIGl0IHdhcyBjcmVhdGVkLiBJbi1mbGlnaHRcclxuICAgICAqIEROUyByZXF1ZXN0cyBjYW5ub3QgYmUgY2FuY2VsbGVkLCBidXQgdGhleSBhcmUgZGlzY2FyZGVkIGFuZCB0aGVpciByZXN1bHRzXHJcbiAgICAgKiB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XHJcbiAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJldHVybmVkSXBSZXN1bHQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBkZWZhdWx0IGF1dGhvcml0eSBmb3IgdGhlIGdpdmVuIHRhcmdldC4gRm9yIElQIHRhcmdldHMsIHRoYXQgaXNcclxuICAgICAqIHRoZSBJUCBhZGRyZXNzLiBGb3IgRE5TIHRhcmdldHMsIGl0IGlzIHRoZSBob3N0bmFtZS5cclxuICAgICAqIEBwYXJhbSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXRoO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTZXQgdXAgdGhlIEROUyByZXNvbHZlciBjbGFzcyBieSByZWdpc3RlcmluZyBpdCBhcyB0aGUgaGFuZGxlciBmb3IgdGhlXHJcbiAqIFwiZG5zOlwiIHByZWZpeCBhbmQgYXMgdGhlIGRlZmF1bHQgcmVzb2x2ZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXR1cCgpIHtcclxuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKCdkbnMnLCBEbnNSZXNvbHZlcik7XHJcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlckRlZmF1bHRTY2hlbWUpKCdkbnMnKTtcclxufVxyXG5leHBvcnRzLnNldHVwID0gc2V0dXA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLWRucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2021 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.setup = void 0;\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst TRACER_NAME = 'ip_resolver';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nconst IPV4_SCHEME = 'ipv4';\r\nconst IPV6_SCHEME = 'ipv6';\r\n/**\r\n * The default TCP port to connect to if not explicitly specified in the target.\r\n */\r\nconst DEFAULT_PORT = 443;\r\nclass IpResolver {\r\n    constructor(target, listener, channelOptions) {\r\n        var _a;\r\n        this.listener = listener;\r\n        this.addresses = [];\r\n        this.error = null;\r\n        this.hasReturnedResult = false;\r\n        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));\r\n        const addresses = [];\r\n        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {\r\n            this.error = {\r\n                code: constants_1.Status.UNAVAILABLE,\r\n                details: `Unrecognized scheme ${target.scheme} in IP resolver`,\r\n                metadata: new metadata_1.Metadata(),\r\n            };\r\n            return;\r\n        }\r\n        const pathList = target.path.split(',');\r\n        for (const path of pathList) {\r\n            const hostPort = (0, uri_parser_1.splitHostPort)(path);\r\n            if (hostPort === null) {\r\n                this.error = {\r\n                    code: constants_1.Status.UNAVAILABLE,\r\n                    details: `Failed to parse ${target.scheme} address ${path}`,\r\n                    metadata: new metadata_1.Metadata(),\r\n                };\r\n                return;\r\n            }\r\n            if ((target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host)) ||\r\n                (target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host))) {\r\n                this.error = {\r\n                    code: constants_1.Status.UNAVAILABLE,\r\n                    details: `Failed to parse ${target.scheme} address ${path}`,\r\n                    metadata: new metadata_1.Metadata(),\r\n                };\r\n                return;\r\n            }\r\n            addresses.push({\r\n                host: hostPort.host,\r\n                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT,\r\n            });\r\n        }\r\n        this.addresses = addresses;\r\n        trace('Parsed ' + target.scheme + ' address list ' + this.addresses);\r\n    }\r\n    updateResolution() {\r\n        if (!this.hasReturnedResult) {\r\n            this.hasReturnedResult = true;\r\n            process.nextTick(() => {\r\n                if (this.error) {\r\n                    this.listener.onError(this.error);\r\n                }\r\n                else {\r\n                    this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});\r\n                }\r\n            });\r\n        }\r\n    }\r\n    destroy() {\r\n        this.hasReturnedResult = false;\r\n    }\r\n    static getDefaultAuthority(target) {\r\n        return target.path.split(',')[0];\r\n    }\r\n}\r\nfunction setup() {\r\n    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);\r\n    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);\r\n}\r\nexports.setup = setup;\r\n//# sourceMappingURL=resolver-ip.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWUsVUFBVSxLQUFLO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZSxVQUFVLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci1pcC5qcz9hZWNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnNldHVwID0gdm9pZCAwO1xyXG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XHJcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcclxuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcclxuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ2lwX3Jlc29sdmVyJztcclxuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xyXG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcclxufVxyXG5jb25zdCBJUFY0X1NDSEVNRSA9ICdpcHY0JztcclxuY29uc3QgSVBWNl9TQ0hFTUUgPSAnaXB2Nic7XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBUQ1AgcG9ydCB0byBjb25uZWN0IHRvIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGUgdGFyZ2V0LlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9QT1JUID0gNDQzO1xyXG5jbGFzcyBJcFJlc29sdmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgbGlzdGVuZXIsIGNoYW5uZWxPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICB0cmFjZSgnUmVzb2x2ZXIgY29uc3RydWN0ZWQgZm9yIHRhcmdldCAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KSk7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW107XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNF9TQ0hFTUUgfHwgdGFyZ2V0LnNjaGVtZSA9PT0gSVBWNl9TQ0hFTUUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgVW5yZWNvZ25pemVkIHNjaGVtZSAke3RhcmdldC5zY2hlbWV9IGluIElQIHJlc29sdmVyYCxcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhdGhMaXN0ID0gdGFyZ2V0LnBhdGguc3BsaXQoJywnKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aExpc3QpIHtcclxuICAgICAgICAgICAgY29uc3QgaG9zdFBvcnQgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoaG9zdFBvcnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxyXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgJHt0YXJnZXQuc2NoZW1lfSBhZGRyZXNzICR7cGF0aH1gLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHRhcmdldC5zY2hlbWUgPT09IElQVjRfU0NIRU1FICYmICEoMCwgbmV0XzEuaXNJUHY0KShob3N0UG9ydC5ob3N0KSkgfHxcclxuICAgICAgICAgICAgICAgICh0YXJnZXQuc2NoZW1lID09PSBJUFY2X1NDSEVNRSAmJiAhKDAsIG5ldF8xLmlzSVB2NikoaG9zdFBvcnQuaG9zdCkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcclxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgRmFpbGVkIHRvIHBhcnNlICR7dGFyZ2V0LnNjaGVtZX0gYWRkcmVzcyAke3BhdGh9YCxcclxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgaG9zdDogaG9zdFBvcnQuaG9zdCxcclxuICAgICAgICAgICAgICAgIHBvcnQ6IChfYSA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERFRkFVTFRfUE9SVCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gYWRkcmVzc2VzO1xyXG4gICAgICAgIHRyYWNlKCdQYXJzZWQgJyArIHRhcmdldC5zY2hlbWUgKyAnIGFkZHJlc3MgbGlzdCAnICsgdGhpcy5hZGRyZXNzZXMpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGFzUmV0dXJuZWRSZXN1bHQpIHtcclxuICAgICAgICAgICAgdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uRXJyb3IodGhpcy5lcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24odGhpcy5hZGRyZXNzZXMsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0LnBhdGguc3BsaXQoJywnKVswXTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXR1cCgpIHtcclxuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKElQVjRfU0NIRU1FLCBJcFJlc29sdmVyKTtcclxuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKElQVjZfU0NIRU1FLCBJcFJlc29sdmVyKTtcclxufVxyXG5leHBvcnRzLnNldHVwID0gc2V0dXA7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLWlwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-uds.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.setup = void 0;\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nclass UdsResolver {\r\n    constructor(target, listener, channelOptions) {\r\n        this.listener = listener;\r\n        this.addresses = [];\r\n        this.hasReturnedResult = false;\r\n        let path;\r\n        if (target.authority === '') {\r\n            path = '/' + target.path;\r\n        }\r\n        else {\r\n            path = target.path;\r\n        }\r\n        this.addresses = [{ path }];\r\n    }\r\n    updateResolution() {\r\n        if (!this.hasReturnedResult) {\r\n            this.hasReturnedResult = true;\r\n            process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});\r\n        }\r\n    }\r\n    destroy() {\r\n        // This resolver owns no resources, so we do nothing here.\r\n    }\r\n    static getDefaultAuthority(target) {\r\n        return 'localhost';\r\n    }\r\n}\r\nfunction setup() {\r\n    (0, resolver_1.registerResolver)('unix', UdsResolver);\r\n}\r\nexports.setup = setup;\r\n//# sourceMappingURL=resolver-uds.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLXVkcy5qcz83YTRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnNldHVwID0gdm9pZCAwO1xyXG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XHJcbmNsYXNzIFVkc1Jlc29sdmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgbGlzdGVuZXIsIGNoYW5uZWxPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gW107XHJcbiAgICAgICAgdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBwYXRoO1xyXG4gICAgICAgIGlmICh0YXJnZXQuYXV0aG9yaXR5ID09PSAnJykge1xyXG4gICAgICAgICAgICBwYXRoID0gJy8nICsgdGFyZ2V0LnBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRoID0gdGFyZ2V0LnBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gW3sgcGF0aCB9XTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JldHVybmVkUmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbiwgdGhpcy5hZGRyZXNzZXMsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIC8vIFRoaXMgcmVzb2x2ZXIgb3ducyBubyByZXNvdXJjZXMsIHNvIHdlIGRvIG5vdGhpbmcgaGVyZS5cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiAnbG9jYWxob3N0JztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXR1cCgpIHtcclxuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKCd1bml4JywgVWRzUmVzb2x2ZXIpO1xyXG59XHJcbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXItdWRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst registeredResolvers = {};\r\nlet defaultScheme = null;\r\n/**\r\n * Register a resolver class to handle target names prefixed with the `prefix`\r\n * string. This prefix should correspond to a URI scheme name listed in the\r\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\r\n * @param prefix\r\n * @param resolverClass\r\n */\r\nfunction registerResolver(scheme, resolverClass) {\r\n    registeredResolvers[scheme] = resolverClass;\r\n}\r\nexports.registerResolver = registerResolver;\r\n/**\r\n * Register a default resolver to handle target names that do not start with\r\n * any registered prefix.\r\n * @param resolverClass\r\n */\r\nfunction registerDefaultScheme(scheme) {\r\n    defaultScheme = scheme;\r\n}\r\nexports.registerDefaultScheme = registerDefaultScheme;\r\n/**\r\n * Create a name resolver for the specified target, if possible. Throws an\r\n * error if no such name resolver can be created.\r\n * @param target\r\n * @param listener\r\n */\r\nfunction createResolver(target, listener, options) {\r\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\r\n        return new registeredResolvers[target.scheme](target, listener, options);\r\n    }\r\n    else {\r\n        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);\r\n    }\r\n}\r\nexports.createResolver = createResolver;\r\n/**\r\n * Get the default authority for the specified target, if possible. Throws an\r\n * error if no registered name resolver can parse that target string.\r\n * @param target\r\n */\r\nfunction getDefaultAuthority(target) {\r\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\r\n        return registeredResolvers[target.scheme].getDefaultAuthority(target);\r\n    }\r\n    else {\r\n        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);\r\n    }\r\n}\r\nexports.getDefaultAuthority = getDefaultAuthority;\r\nfunction mapUriDefaultScheme(target) {\r\n    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\r\n        if (defaultScheme !== null) {\r\n            return {\r\n                scheme: defaultScheme,\r\n                authority: undefined,\r\n                path: (0, uri_parser_1.uriToString)(target),\r\n            };\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    return target;\r\n}\r\nexports.mapUriDefaultScheme = mapUriDefaultScheme;\r\n//# sourceMappingURL=resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyw2QkFBNkIsR0FBRyx3QkFBd0I7QUFDN0kscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxzQ0FBc0M7QUFDekc7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQ0FBc0M7QUFDaEY7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLmpzPzljOTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMubWFwVXJpRGVmYXVsdFNjaGVtZSA9IGV4cG9ydHMuZ2V0RGVmYXVsdEF1dGhvcml0eSA9IGV4cG9ydHMuY3JlYXRlUmVzb2x2ZXIgPSBleHBvcnRzLnJlZ2lzdGVyRGVmYXVsdFNjaGVtZSA9IGV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IHZvaWQgMDtcclxuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcclxuY29uc3QgcmVnaXN0ZXJlZFJlc29sdmVycyA9IHt9O1xyXG5sZXQgZGVmYXVsdFNjaGVtZSA9IG51bGw7XHJcbi8qKlxyXG4gKiBSZWdpc3RlciBhIHJlc29sdmVyIGNsYXNzIHRvIGhhbmRsZSB0YXJnZXQgbmFtZXMgcHJlZml4ZWQgd2l0aCB0aGUgYHByZWZpeGBcclxuICogc3RyaW5nLiBUaGlzIHByZWZpeCBzaG91bGQgY29ycmVzcG9uZCB0byBhIFVSSSBzY2hlbWUgbmFtZSBsaXN0ZWQgaW4gdGhlXHJcbiAqIFtnUlBDIE5hbWUgUmVzb2x1dGlvbiBkb2N1bWVudF0oaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9kb2MvbmFtaW5nLm1kKVxyXG4gKiBAcGFyYW0gcHJlZml4XHJcbiAqIEBwYXJhbSByZXNvbHZlckNsYXNzXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlclJlc29sdmVyKHNjaGVtZSwgcmVzb2x2ZXJDbGFzcykge1xyXG4gICAgcmVnaXN0ZXJlZFJlc29sdmVyc1tzY2hlbWVdID0gcmVzb2x2ZXJDbGFzcztcclxufVxyXG5leHBvcnRzLnJlZ2lzdGVyUmVzb2x2ZXIgPSByZWdpc3RlclJlc29sdmVyO1xyXG4vKipcclxuICogUmVnaXN0ZXIgYSBkZWZhdWx0IHJlc29sdmVyIHRvIGhhbmRsZSB0YXJnZXQgbmFtZXMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aFxyXG4gKiBhbnkgcmVnaXN0ZXJlZCBwcmVmaXguXHJcbiAqIEBwYXJhbSByZXNvbHZlckNsYXNzXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRTY2hlbWUoc2NoZW1lKSB7XHJcbiAgICBkZWZhdWx0U2NoZW1lID0gc2NoZW1lO1xyXG59XHJcbmV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0U2NoZW1lID0gcmVnaXN0ZXJEZWZhdWx0U2NoZW1lO1xyXG4vKipcclxuICogQ3JlYXRlIGEgbmFtZSByZXNvbHZlciBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQsIGlmIHBvc3NpYmxlLiBUaHJvd3MgYW5cclxuICogZXJyb3IgaWYgbm8gc3VjaCBuYW1lIHJlc29sdmVyIGNhbiBiZSBjcmVhdGVkLlxyXG4gKiBAcGFyYW0gdGFyZ2V0XHJcbiAqIEBwYXJhbSBsaXN0ZW5lclxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZXIodGFyZ2V0LCBsaXN0ZW5lciwgb3B0aW9ucykge1xyXG4gICAgaWYgKHRhcmdldC5zY2hlbWUgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQuc2NoZW1lIGluIHJlZ2lzdGVyZWRSZXNvbHZlcnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRSZXNvbHZlcnNbdGFyZ2V0LnNjaGVtZV0odGFyZ2V0LCBsaXN0ZW5lciwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJlc29sdmVyIGNvdWxkIGJlIGNyZWF0ZWQgZm9yIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCl9YCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGNyZWF0ZVJlc29sdmVyO1xyXG4vKipcclxuICogR2V0IHRoZSBkZWZhdWx0IGF1dGhvcml0eSBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQsIGlmIHBvc3NpYmxlLiBUaHJvd3MgYW5cclxuICogZXJyb3IgaWYgbm8gcmVnaXN0ZXJlZCBuYW1lIHJlc29sdmVyIGNhbiBwYXJzZSB0aGF0IHRhcmdldCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB0YXJnZXRcclxuICovXHJcbmZ1bmN0aW9uIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XHJcbiAgICBpZiAodGFyZ2V0LnNjaGVtZSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykge1xyXG4gICAgICAgIHJldHVybiByZWdpc3RlcmVkUmVzb2x2ZXJzW3RhcmdldC5zY2hlbWVdLmdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0YXJnZXQgJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpfWApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZ2V0RGVmYXVsdEF1dGhvcml0eSA9IGdldERlZmF1bHRBdXRob3JpdHk7XHJcbmZ1bmN0aW9uIG1hcFVyaURlZmF1bHRTY2hlbWUodGFyZ2V0KSB7XHJcbiAgICBpZiAodGFyZ2V0LnNjaGVtZSA9PT0gdW5kZWZpbmVkIHx8ICEodGFyZ2V0LnNjaGVtZSBpbiByZWdpc3RlcmVkUmVzb2x2ZXJzKSkge1xyXG4gICAgICAgIGlmIChkZWZhdWx0U2NoZW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzY2hlbWU6IGRlZmF1bHRTY2hlbWUsXHJcbiAgICAgICAgICAgICAgICBhdXRob3JpdHk6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHBhdGg6ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbmV4cG9ydHMubWFwVXJpRGVmYXVsdFNjaGVtZSA9IG1hcFVyaURlZmF1bHRTY2hlbWU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-call.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResolvingCall = void 0;\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\r\nconst TRACER_NAME = 'resolving_call';\r\nclass ResolvingCall {\r\n    constructor(channel, method, options, filterStackFactory, credentials, callNumber) {\r\n        this.channel = channel;\r\n        this.method = method;\r\n        this.filterStackFactory = filterStackFactory;\r\n        this.credentials = credentials;\r\n        this.callNumber = callNumber;\r\n        this.child = null;\r\n        this.readPending = false;\r\n        this.pendingMessage = null;\r\n        this.pendingHalfClose = false;\r\n        this.ended = false;\r\n        this.readFilterPending = false;\r\n        this.writeFilterPending = false;\r\n        this.pendingChildStatus = null;\r\n        this.metadata = null;\r\n        this.listener = null;\r\n        this.statusWatchers = [];\r\n        this.deadlineTimer = setTimeout(() => { }, 0);\r\n        this.filterStack = null;\r\n        this.deadline = options.deadline;\r\n        this.host = options.host;\r\n        if (options.parentCall) {\r\n            if (options.flags & constants_1.Propagate.CANCELLATION) {\r\n                options.parentCall.on('cancelled', () => {\r\n                    this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\r\n                });\r\n            }\r\n            if (options.flags & constants_1.Propagate.DEADLINE) {\r\n                this.trace('Propagating deadline from parent: ' +\r\n                    options.parentCall.getDeadline());\r\n                this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());\r\n            }\r\n        }\r\n        this.trace('Created');\r\n        this.runDeadlineTimer();\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\r\n    }\r\n    runDeadlineTimer() {\r\n        clearTimeout(this.deadlineTimer);\r\n        this.trace('Deadline: ' + (0, deadline_1.deadlineToString)(this.deadline));\r\n        const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);\r\n        if (timeout !== Infinity) {\r\n            this.trace('Deadline will be reached in ' + timeout + 'ms');\r\n            const handleDeadline = () => {\r\n                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\r\n            };\r\n            if (timeout <= 0) {\r\n                process.nextTick(handleDeadline);\r\n            }\r\n            else {\r\n                this.deadlineTimer = setTimeout(handleDeadline, timeout);\r\n            }\r\n        }\r\n    }\r\n    outputStatus(status) {\r\n        if (!this.ended) {\r\n            this.ended = true;\r\n            if (!this.filterStack) {\r\n                this.filterStack = this.filterStackFactory.createFilter();\r\n            }\r\n            clearTimeout(this.deadlineTimer);\r\n            const filteredStatus = this.filterStack.receiveTrailers(status);\r\n            this.trace('ended with status: code=' +\r\n                filteredStatus.code +\r\n                ' details=\"' +\r\n                filteredStatus.details +\r\n                '\"');\r\n            this.statusWatchers.forEach(watcher => watcher(filteredStatus));\r\n            process.nextTick(() => {\r\n                var _a;\r\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\r\n            });\r\n        }\r\n    }\r\n    sendMessageOnChild(context, message) {\r\n        if (!this.child) {\r\n            throw new Error('sendMessageonChild called with child not populated');\r\n        }\r\n        const child = this.child;\r\n        this.writeFilterPending = true;\r\n        this.filterStack.sendMessage(Promise.resolve({ message: message, flags: context.flags })).then(filteredMessage => {\r\n            this.writeFilterPending = false;\r\n            child.sendMessageWithContext(context, filteredMessage.message);\r\n            if (this.pendingHalfClose) {\r\n                child.halfClose();\r\n            }\r\n        }, (status) => {\r\n            this.cancelWithStatus(status.code, status.details);\r\n        });\r\n    }\r\n    getConfig() {\r\n        if (this.ended) {\r\n            return;\r\n        }\r\n        if (!this.metadata || !this.listener) {\r\n            throw new Error('getConfig called before start');\r\n        }\r\n        const configResult = this.channel.getConfig(this.method, this.metadata);\r\n        if (configResult.type === 'NONE') {\r\n            this.channel.queueCallForConfig(this);\r\n            return;\r\n        }\r\n        else if (configResult.type === 'ERROR') {\r\n            if (this.metadata.getOptions().waitForReady) {\r\n                this.channel.queueCallForConfig(this);\r\n            }\r\n            else {\r\n                this.outputStatus(configResult.error);\r\n            }\r\n            return;\r\n        }\r\n        // configResult.type === 'SUCCESS'\r\n        const config = configResult.config;\r\n        if (config.status !== constants_1.Status.OK) {\r\n            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, 'Failed to route call to method ' + this.method);\r\n            this.outputStatus({\r\n                code: code,\r\n                details: details,\r\n                metadata: new metadata_1.Metadata(),\r\n            });\r\n            return;\r\n        }\r\n        if (config.methodConfig.timeout) {\r\n            const configDeadline = new Date();\r\n            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);\r\n            configDeadline.setMilliseconds(configDeadline.getMilliseconds() +\r\n                config.methodConfig.timeout.nanos / 1000000);\r\n            this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);\r\n            this.runDeadlineTimer();\r\n        }\r\n        this.filterStackFactory.push(config.dynamicFilterFactories);\r\n        this.filterStack = this.filterStackFactory.createFilter();\r\n        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => {\r\n            this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);\r\n            this.trace('Created child [' + this.child.getCallNumber() + ']');\r\n            this.child.start(filteredMetadata, {\r\n                onReceiveMetadata: metadata => {\r\n                    this.trace('Received metadata');\r\n                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));\r\n                },\r\n                onReceiveMessage: message => {\r\n                    this.trace('Received message');\r\n                    this.readFilterPending = true;\r\n                    this.filterStack.receiveMessage(message).then(filteredMesssage => {\r\n                        this.trace('Finished filtering received message');\r\n                        this.readFilterPending = false;\r\n                        this.listener.onReceiveMessage(filteredMesssage);\r\n                        if (this.pendingChildStatus) {\r\n                            this.outputStatus(this.pendingChildStatus);\r\n                        }\r\n                    }, (status) => {\r\n                        this.cancelWithStatus(status.code, status.details);\r\n                    });\r\n                },\r\n                onReceiveStatus: status => {\r\n                    this.trace('Received status');\r\n                    if (this.readFilterPending) {\r\n                        this.pendingChildStatus = status;\r\n                    }\r\n                    else {\r\n                        this.outputStatus(status);\r\n                    }\r\n                },\r\n            });\r\n            if (this.readPending) {\r\n                this.child.startRead();\r\n            }\r\n            if (this.pendingMessage) {\r\n                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);\r\n            }\r\n            else if (this.pendingHalfClose) {\r\n                this.child.halfClose();\r\n            }\r\n        }, (status) => {\r\n            this.outputStatus(status);\r\n        });\r\n    }\r\n    reportResolverError(status) {\r\n        var _a;\r\n        if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\r\n            this.channel.queueCallForConfig(this);\r\n        }\r\n        else {\r\n            this.outputStatus(status);\r\n        }\r\n    }\r\n    cancelWithStatus(status, details) {\r\n        var _a;\r\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\r\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\r\n        this.outputStatus({\r\n            code: status,\r\n            details: details,\r\n            metadata: new metadata_1.Metadata(),\r\n        });\r\n    }\r\n    getPeer() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\r\n    }\r\n    start(metadata, listener) {\r\n        this.trace('start called');\r\n        this.metadata = metadata.clone();\r\n        this.listener = listener;\r\n        this.getConfig();\r\n    }\r\n    sendMessageWithContext(context, message) {\r\n        this.trace('write() called with message of length ' + message.length);\r\n        if (this.child) {\r\n            this.sendMessageOnChild(context, message);\r\n        }\r\n        else {\r\n            this.pendingMessage = { context, message };\r\n        }\r\n    }\r\n    startRead() {\r\n        this.trace('startRead called');\r\n        if (this.child) {\r\n            this.child.startRead();\r\n        }\r\n        else {\r\n            this.readPending = true;\r\n        }\r\n    }\r\n    halfClose() {\r\n        this.trace('halfClose called');\r\n        if (this.child && !this.writeFilterPending) {\r\n            this.child.halfClose();\r\n        }\r\n        else {\r\n            this.pendingHalfClose = true;\r\n        }\r\n    }\r\n    setCredentials(credentials) {\r\n        this.credentials = this.credentials.compose(credentials);\r\n    }\r\n    addStatusWatcher(watcher) {\r\n        this.statusWatchers.push(watcher);\r\n    }\r\n    getCallNumber() {\r\n        return this.callNumber;\r\n    }\r\n}\r\nexports.ResolvingCall = ResolvingCall;\r\n//# sourceMappingURL=resolving-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsK0JBQStCLG1CQUFPLENBQUMsb0dBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx3Q0FBd0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmluZy1jYWxsLmpzPzgxZDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuUmVzb2x2aW5nQ2FsbCA9IHZvaWQgMDtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IGRlYWRsaW5lXzEgPSByZXF1aXJlKFwiLi9kZWFkbGluZVwiKTtcclxuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xyXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3QgY29udHJvbF9wbGFuZV9zdGF0dXNfMSA9IHJlcXVpcmUoXCIuL2NvbnRyb2wtcGxhbmUtc3RhdHVzXCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyZXNvbHZpbmdfY2FsbCc7XHJcbmNsYXNzIFJlc29sdmluZ0NhbGwge1xyXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgbWV0aG9kLCBvcHRpb25zLCBmaWx0ZXJTdGFja0ZhY3RvcnksIGNyZWRlbnRpYWxzLCBjYWxsTnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcclxuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcclxuICAgICAgICB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeSA9IGZpbHRlclN0YWNrRmFjdG9yeTtcclxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XHJcbiAgICAgICAgdGhpcy5jYWxsTnVtYmVyID0gY2FsbE51bWJlcjtcclxuICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVhZEZpbHRlclBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLndyaXRlRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkU3RhdHVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBvcHRpb25zLmRlYWRsaW5lO1xyXG4gICAgICAgIHRoaXMuaG9zdCA9IG9wdGlvbnMuaG9zdDtcclxuICAgICAgICBpZiAob3B0aW9ucy5wYXJlbnRDYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZsYWdzICYgY29uc3RhbnRzXzEuUHJvcGFnYXRlLkNBTkNFTExBVElPTikge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJlbnRDYWxsLm9uKCdjYW5jZWxsZWQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgYnkgcGFyZW50IGNhbGwnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZsYWdzICYgY29uc3RhbnRzXzEuUHJvcGFnYXRlLkRFQURMSU5FKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdQcm9wYWdhdGluZyBkZWFkbGluZSBmcm9tIHBhcmVudDogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJlbnRDYWxsLmdldERlYWRsaW5lKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWFkbGluZSA9ICgwLCBkZWFkbGluZV8xLm1pbkRlYWRsaW5lKSh0aGlzLmRlYWRsaW5lLCBvcHRpb25zLnBhcmVudENhbGwuZ2V0RGVhZGxpbmUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFjZSgnQ3JlYXRlZCcpO1xyXG4gICAgICAgIHRoaXMucnVuRGVhZGxpbmVUaW1lcigpO1xyXG4gICAgfVxyXG4gICAgdHJhY2UodGV4dCkge1xyXG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJ1snICsgdGhpcy5jYWxsTnVtYmVyICsgJ10gJyArIHRleHQpO1xyXG4gICAgfVxyXG4gICAgcnVuRGVhZGxpbmVUaW1lcigpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWFkbGluZVRpbWVyKTtcclxuICAgICAgICB0aGlzLnRyYWNlKCdEZWFkbGluZTogJyArICgwLCBkZWFkbGluZV8xLmRlYWRsaW5lVG9TdHJpbmcpKHRoaXMuZGVhZGxpbmUpKTtcclxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gKDAsIGRlYWRsaW5lXzEuZ2V0UmVsYXRpdmVUaW1lb3V0KSh0aGlzLmRlYWRsaW5lKTtcclxuICAgICAgICBpZiAodGltZW91dCAhPT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgdGhpcy50cmFjZSgnRGVhZGxpbmUgd2lsbCBiZSByZWFjaGVkIGluICcgKyB0aW1lb3V0ICsgJ21zJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZURlYWRsaW5lID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRCwgJ0RlYWRsaW5lIGV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soaGFuZGxlRGVhZGxpbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gc2V0VGltZW91dChoYW5kbGVEZWFkbGluZSwgdGltZW91dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvdXRwdXRTdGF0dXMoc3RhdHVzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVuZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlsdGVyU3RhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyU3RhY2sgPSB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeS5jcmVhdGVGaWx0ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWFkbGluZVRpbWVyKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRTdGF0dXMgPSB0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVUcmFpbGVycyhzdGF0dXMpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkU3RhdHVzLmNvZGUgK1xyXG4gICAgICAgICAgICAgICAgJyBkZXRhaWxzPVwiJyArXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFN0YXR1cy5kZXRhaWxzICtcclxuICAgICAgICAgICAgICAgICdcIicpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzLmZvckVhY2god2F0Y2hlciA9PiB3YXRjaGVyKGZpbHRlcmVkU3RhdHVzKSk7XHJcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUmVjZWl2ZVN0YXR1cyhmaWx0ZXJlZFN0YXR1cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRNZXNzYWdlT25DaGlsZChjb250ZXh0LCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VuZE1lc3NhZ2VvbkNoaWxkIGNhbGxlZCB3aXRoIGNoaWxkIG5vdCBwb3B1bGF0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkO1xyXG4gICAgICAgIHRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnNlbmRNZXNzYWdlKFByb21pc2UucmVzb2x2ZSh7IG1lc3NhZ2U6IG1lc3NhZ2UsIGZsYWdzOiBjb250ZXh0LmZsYWdzIH0pKS50aGVuKGZpbHRlcmVkTWVzc2FnZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNoaWxkLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgZmlsdGVyZWRNZXNzYWdlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGFsZkNsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5oYWxmQ2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIChzdGF0dXMpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cy5jb2RlLCBzdGF0dXMuZGV0YWlscyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRDb25maWcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMubWV0YWRhdGEgfHwgIXRoaXMubGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRDb25maWcgY2FsbGVkIGJlZm9yZSBzdGFydCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb25maWdSZXN1bHQgPSB0aGlzLmNoYW5uZWwuZ2V0Q29uZmlnKHRoaXMubWV0aG9kLCB0aGlzLm1ldGFkYXRhKTtcclxuICAgICAgICBpZiAoY29uZmlnUmVzdWx0LnR5cGUgPT09ICdOT05FJykge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yQ29uZmlnKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZ1Jlc3VsdC50eXBlID09PSAnRVJST1InKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5xdWV1ZUNhbGxGb3JDb25maWcodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyhjb25maWdSZXN1bHQuZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uZmlnUmVzdWx0LnR5cGUgPT09ICdTVUNDRVNTJ1xyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ1Jlc3VsdC5jb25maWc7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5zdGF0dXMgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkoY29uZmlnLnN0YXR1cywgJ0ZhaWxlZCB0byByb3V0ZSBjYWxsIHRvIG1ldGhvZCAnICsgdGhpcy5tZXRob2QpO1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxyXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ0RlYWRsaW5lID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgY29uZmlnRGVhZGxpbmUuc2V0U2Vjb25kcyhjb25maWdEZWFkbGluZS5nZXRTZWNvbmRzKCkgKyBjb25maWcubWV0aG9kQ29uZmlnLnRpbWVvdXQuc2Vjb25kcyk7XHJcbiAgICAgICAgICAgIGNvbmZpZ0RlYWRsaW5lLnNldE1pbGxpc2Vjb25kcyhjb25maWdEZWFkbGluZS5nZXRNaWxsaXNlY29uZHMoKSArXHJcbiAgICAgICAgICAgICAgICBjb25maWcubWV0aG9kQ29uZmlnLnRpbWVvdXQubmFub3MgLyAxMDAwMDAwKTtcclxuICAgICAgICAgICAgdGhpcy5kZWFkbGluZSA9ICgwLCBkZWFkbGluZV8xLm1pbkRlYWRsaW5lKSh0aGlzLmRlYWRsaW5lLCBjb25maWdEZWFkbGluZSk7XHJcbiAgICAgICAgICAgIHRoaXMucnVuRGVhZGxpbmVUaW1lcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeS5wdXNoKGNvbmZpZy5keW5hbWljRmlsdGVyRmFjdG9yaWVzKTtcclxuICAgICAgICB0aGlzLmZpbHRlclN0YWNrID0gdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkuY3JlYXRlRmlsdGVyKCk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjay5zZW5kTWV0YWRhdGEoUHJvbWlzZS5yZXNvbHZlKHRoaXMubWV0YWRhdGEpKS50aGVuKGZpbHRlcmVkTWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkID0gdGhpcy5jaGFubmVsLmNyZWF0ZUlubmVyQ2FsbChjb25maWcsIHRoaXMubWV0aG9kLCB0aGlzLmhvc3QsIHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuZGVhZGxpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkIGNoaWxkIFsnICsgdGhpcy5jaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0KGZpbHRlcmVkTWV0YWRhdGEsIHtcclxuICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWV0YWRhdGEnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWVzc2FnZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEZpbHRlclBlbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkudGhlbihmaWx0ZXJlZE1lc3NzYWdlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmluaXNoZWQgZmlsdGVyaW5nIHJlY2VpdmVkIG1lc3NhZ2UnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UoZmlsdGVyZWRNZXNzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZFN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXModGhpcy5wZW5kaW5nQ2hpbGRTdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgKHN0YXR1cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLmNvZGUsIHN0YXR1cy5kZXRhaWxzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHN0YXR1cyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc3RhdHVzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZEZpbHRlclBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGRTdGF0dXMgPSBzdGF0dXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyhzdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkUGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydFJlYWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZU9uQ2hpbGQodGhpcy5wZW5kaW5nTWVzc2FnZS5jb250ZXh0LCB0aGlzLnBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIChzdGF0dXMpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlcG9ydFJlc29sdmVyRXJyb3Ioc3RhdHVzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yQ29uZmlnKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcclxuICAgICAgICAoX2EgPSB0aGlzLmNoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcclxuICAgICAgICAgICAgY29kZTogc3RhdHVzLFxyXG4gICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxyXG4gICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldFBlZXIoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5jaGFubmVsLmdldFRhcmdldCgpO1xyXG4gICAgfVxyXG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnQgY2FsbGVkJyk7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgICAgIHRoaXMuZ2V0Q29uZmlnKCk7XHJcbiAgICB9XHJcbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCd3cml0ZSgpIGNhbGxlZCB3aXRoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZU9uQ2hpbGQoY29udGV4dCwgbWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0geyBjb250ZXh0LCBtZXNzYWdlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhcnRSZWFkKCkge1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0UmVhZCBjYWxsZWQnKTtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0UmVhZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkUGVuZGluZyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFsZkNsb3NlKCkge1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ2hhbGZDbG9zZSBjYWxsZWQnKTtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZCAmJiAhdGhpcy53cml0ZUZpbHRlclBlbmRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcclxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gdGhpcy5jcmVkZW50aWFscy5jb21wb3NlKGNyZWRlbnRpYWxzKTtcclxuICAgIH1cclxuICAgIGFkZFN0YXR1c1dhdGNoZXIod2F0Y2hlcikge1xyXG4gICAgICAgIHRoaXMuc3RhdHVzV2F0Y2hlcnMucHVzaCh3YXRjaGVyKTtcclxuICAgIH1cclxuICAgIGdldENhbGxOdW1iZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbE51bWJlcjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlJlc29sdmluZ0NhbGwgPSBSZXNvbHZpbmdDYWxsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZpbmctY2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ResolvingLoadBalancer = void 0;\r\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\r\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\r\nconst TRACER_NAME = 'resolving_load_balancer';\r\nfunction trace(text) {\r\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\n/**\r\n * Name match levels in order from most to least specific. This is the order in\r\n * which searches will be performed.\r\n */\r\nconst NAME_MATCH_LEVEL_ORDER = [\r\n    'SERVICE_AND_METHOD',\r\n    'SERVICE',\r\n    'EMPTY',\r\n];\r\nfunction hasMatchingName(service, method, methodConfig, matchLevel) {\r\n    for (const name of methodConfig.name) {\r\n        switch (matchLevel) {\r\n            case 'EMPTY':\r\n                if (!name.service && !name.method) {\r\n                    return true;\r\n                }\r\n                break;\r\n            case 'SERVICE':\r\n                if (name.service === service && !name.method) {\r\n                    return true;\r\n                }\r\n                break;\r\n            case 'SERVICE_AND_METHOD':\r\n                if (name.service === service && name.method === method) {\r\n                    return true;\r\n                }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction findMatchingConfig(service, method, methodConfigs, matchLevel) {\r\n    for (const config of methodConfigs) {\r\n        if (hasMatchingName(service, method, config, matchLevel)) {\r\n            return config;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getDefaultConfigSelector(serviceConfig) {\r\n    return function defaultConfigSelector(methodName, metadata) {\r\n        var _a, _b;\r\n        const splitName = methodName.split('/').filter(x => x.length > 0);\r\n        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\r\n        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\r\n        if (serviceConfig && serviceConfig.methodConfig) {\r\n            /* Check for the following in order, and return the first method\r\n             * config that matches:\r\n             * 1. A name that exactly matches the service and method\r\n             * 2. A name with no method set that matches the service\r\n             * 3. An empty name\r\n             */\r\n            for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {\r\n                const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);\r\n                if (matchingConfig) {\r\n                    return {\r\n                        methodConfig: matchingConfig,\r\n                        pickInformation: {},\r\n                        status: constants_1.Status.OK,\r\n                        dynamicFilterFactories: [],\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            methodConfig: { name: [] },\r\n            pickInformation: {},\r\n            status: constants_1.Status.OK,\r\n            dynamicFilterFactories: [],\r\n        };\r\n    };\r\n}\r\nclass ResolvingLoadBalancer {\r\n    /**\r\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\r\n     * resolution internally.\r\n     * @param target The address of the backend to connect to.\r\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\r\n     *     this load balancer's owner.\r\n     * @param defaultServiceConfig The default service configuration to be used\r\n     *     if none is provided by the name resolver. A `null` value indicates\r\n     *     that the default behavior should be the default unconfigured behavior.\r\n     *     In practice, that means using the \"pick first\" load balancer\r\n     *     implmentation\r\n     */\r\n    constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\r\n        this.target = target;\r\n        this.channelControlHelper = channelControlHelper;\r\n        this.onSuccessfulResolution = onSuccessfulResolution;\r\n        this.onFailedResolution = onFailedResolution;\r\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\r\n        this.latestChildPicker = new picker_1.QueuePicker(this);\r\n        /**\r\n         * This resolving load balancer's current connectivity state.\r\n         */\r\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\r\n        /**\r\n         * The service config object from the last successful resolution, if\r\n         * available. A value of null indicates that we have not yet received a valid\r\n         * service config from the resolver.\r\n         */\r\n        this.previousServiceConfig = null;\r\n        /**\r\n         * Indicates whether we should attempt to resolve again after the backoff\r\n         * timer runs out.\r\n         */\r\n        this.continueResolving = false;\r\n        if (channelOptions['grpc.service_config']) {\r\n            this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions['grpc.service_config']));\r\n        }\r\n        else {\r\n            this.defaultServiceConfig = {\r\n                loadBalancingConfig: [],\r\n                methodConfig: [],\r\n            };\r\n        }\r\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\r\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\r\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\r\n            requestReresolution: () => {\r\n                /* If the backoffTimeout is running, we're still backing off from\r\n                 * making resolve requests, so we shouldn't make another one here.\r\n                 * In that case, the backoff timer callback will call\r\n                 * updateResolution */\r\n                if (this.backoffTimeout.isRunning()) {\r\n                    trace('requestReresolution delayed by backoff timer until ' + this.backoffTimeout.getEndTime().toISOString());\r\n                    this.continueResolving = true;\r\n                }\r\n                else {\r\n                    this.updateResolution();\r\n                }\r\n            },\r\n            updateState: (newState, picker) => {\r\n                this.latestChildState = newState;\r\n                this.latestChildPicker = picker;\r\n                this.updateState(newState, picker);\r\n            },\r\n            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\r\n            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper),\r\n        });\r\n        this.innerResolver = (0, resolver_1.createResolver)(target, {\r\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {\r\n                var _a;\r\n                this.backoffTimeout.stop();\r\n                this.backoffTimeout.reset();\r\n                let workingServiceConfig = null;\r\n                /* This first group of conditionals implements the algorithm described\r\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\r\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\r\n                 */\r\n                if (serviceConfig === null) {\r\n                    // Step 4 and 5\r\n                    if (serviceConfigError === null) {\r\n                        // Step 5\r\n                        this.previousServiceConfig = null;\r\n                        workingServiceConfig = this.defaultServiceConfig;\r\n                    }\r\n                    else {\r\n                        // Step 4\r\n                        if (this.previousServiceConfig === null) {\r\n                            // Step 4.ii\r\n                            this.handleResolutionFailure(serviceConfigError);\r\n                        }\r\n                        else {\r\n                            // Step 4.i\r\n                            workingServiceConfig = this.previousServiceConfig;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Step 3\r\n                    workingServiceConfig = serviceConfig;\r\n                    this.previousServiceConfig = serviceConfig;\r\n                }\r\n                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\r\n                const loadBalancingConfig = (0, load_balancer_1.getFirstUsableConfig)(workingConfigList, true);\r\n                if (loadBalancingConfig === null) {\r\n                    // There were load balancing configs but none are supported. This counts as a resolution failure\r\n                    this.handleResolutionFailure({\r\n                        code: constants_1.Status.UNAVAILABLE,\r\n                        details: 'All load balancer options in service config are not compatible',\r\n                        metadata: new metadata_1.Metadata(),\r\n                    });\r\n                    return;\r\n                }\r\n                this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\r\n                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\r\n                this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\r\n            },\r\n            onError: (error) => {\r\n                this.handleResolutionFailure(error);\r\n            },\r\n        }, channelOptions);\r\n        const backoffOptions = {\r\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\r\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\r\n        };\r\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\r\n            if (this.continueResolving) {\r\n                this.updateResolution();\r\n                this.continueResolving = false;\r\n            }\r\n            else {\r\n                this.updateState(this.latestChildState, this.latestChildPicker);\r\n            }\r\n        }, backoffOptions);\r\n        this.backoffTimeout.unref();\r\n    }\r\n    updateResolution() {\r\n        this.innerResolver.updateResolution();\r\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\r\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\r\n        }\r\n        this.backoffTimeout.runOnce();\r\n    }\r\n    updateState(connectivityState, picker) {\r\n        trace((0, uri_parser_1.uriToString)(this.target) +\r\n            ' ' +\r\n            connectivity_state_1.ConnectivityState[this.currentState] +\r\n            ' -> ' +\r\n            connectivity_state_1.ConnectivityState[connectivityState]);\r\n        // Ensure that this.exitIdle() is called by the picker\r\n        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\r\n            picker = new picker_1.QueuePicker(this);\r\n        }\r\n        this.currentState = connectivityState;\r\n        this.channelControlHelper.updateState(connectivityState, picker);\r\n    }\r\n    handleResolutionFailure(error) {\r\n        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\r\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\r\n            this.onFailedResolution(error);\r\n        }\r\n    }\r\n    exitIdle() {\r\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE ||\r\n            this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\r\n            if (this.backoffTimeout.isRunning()) {\r\n                this.continueResolving = true;\r\n            }\r\n            else {\r\n                this.updateResolution();\r\n            }\r\n        }\r\n        this.childLoadBalancer.exitIdle();\r\n    }\r\n    updateAddressList(addressList, lbConfig) {\r\n        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\r\n    }\r\n    resetBackoff() {\r\n        this.backoffTimeout.reset();\r\n        this.childLoadBalancer.resetBackoff();\r\n    }\r\n    destroy() {\r\n        this.childLoadBalancer.destroy();\r\n        this.innerResolver.destroy();\r\n        this.backoffTimeout.reset();\r\n        this.backoffTimeout.stop();\r\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\r\n        this.latestChildPicker = new picker_1.QueuePicker(this);\r\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\r\n        this.previousServiceConfig = null;\r\n        this.continueResolving = false;\r\n    }\r\n    getTypeName() {\r\n        return 'resolving_load_balancer';\r\n    }\r\n}\r\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;\r\n//# sourceMappingURL=resolving-load-balancer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0Isd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pELHlCQUF5QixtQkFBTyxDQUFDLHdGQUFrQjtBQUNuRCw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsMEJBQTBCLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLHNDQUFzQyxtQkFBTyxDQUFDLGtIQUErQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanM/ZmNmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5SZXNvbHZpbmdMb2FkQmFsYW5jZXIgPSB2b2lkIDA7XHJcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XHJcbmNvbnN0IHNlcnZpY2VfY29uZmlnXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlLWNvbmZpZ1wiKTtcclxuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XHJcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcclxuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XHJcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xyXG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcclxuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xyXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XHJcbmNvbnN0IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyZXNvbHZpbmdfbG9hZF9iYWxhbmNlcic7XHJcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcclxuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XHJcbn1cclxuLyoqXHJcbiAqIE5hbWUgbWF0Y2ggbGV2ZWxzIGluIG9yZGVyIGZyb20gbW9zdCB0byBsZWFzdCBzcGVjaWZpYy4gVGhpcyBpcyB0aGUgb3JkZXIgaW5cclxuICogd2hpY2ggc2VhcmNoZXMgd2lsbCBiZSBwZXJmb3JtZWQuXHJcbiAqL1xyXG5jb25zdCBOQU1FX01BVENIX0xFVkVMX09SREVSID0gW1xyXG4gICAgJ1NFUlZJQ0VfQU5EX01FVEhPRCcsXHJcbiAgICAnU0VSVklDRScsXHJcbiAgICAnRU1QVFknLFxyXG5dO1xyXG5mdW5jdGlvbiBoYXNNYXRjaGluZ05hbWUoc2VydmljZSwgbWV0aG9kLCBtZXRob2RDb25maWcsIG1hdGNoTGV2ZWwpIHtcclxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXRob2RDb25maWcubmFtZSkge1xyXG4gICAgICAgIHN3aXRjaCAobWF0Y2hMZXZlbCkge1xyXG4gICAgICAgICAgICBjYXNlICdFTVBUWSc6XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUuc2VydmljZSAmJiAhbmFtZS5tZXRob2QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdTRVJWSUNFJzpcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlcnZpY2UgJiYgIW5hbWUubWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnU0VSVklDRV9BTkRfTUVUSE9EJzpcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlcnZpY2UgJiYgbmFtZS5tZXRob2QgPT09IG1ldGhvZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBmaW5kTWF0Y2hpbmdDb25maWcoc2VydmljZSwgbWV0aG9kLCBtZXRob2RDb25maWdzLCBtYXRjaExldmVsKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBtZXRob2RDb25maWdzKSB7XHJcbiAgICAgICAgaWYgKGhhc01hdGNoaW5nTmFtZShzZXJ2aWNlLCBtZXRob2QsIGNvbmZpZywgbWF0Y2hMZXZlbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBnZXREZWZhdWx0Q29uZmlnU2VsZWN0b3Ioc2VydmljZUNvbmZpZykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlZmF1bHRDb25maWdTZWxlY3RvcihtZXRob2ROYW1lLCBtZXRhZGF0YSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3Qgc3BsaXROYW1lID0gbWV0aG9kTmFtZS5zcGxpdCgnLycpLmZpbHRlcih4ID0+IHgubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IChfYSA9IHNwbGl0TmFtZVswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XHJcbiAgICAgICAgY29uc3QgbWV0aG9kID0gKF9iID0gc3BsaXROYW1lWzFdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcclxuICAgICAgICBpZiAoc2VydmljZUNvbmZpZyAmJiBzZXJ2aWNlQ29uZmlnLm1ldGhvZENvbmZpZykge1xyXG4gICAgICAgICAgICAvKiBDaGVjayBmb3IgdGhlIGZvbGxvd2luZyBpbiBvcmRlciwgYW5kIHJldHVybiB0aGUgZmlyc3QgbWV0aG9kXHJcbiAgICAgICAgICAgICAqIGNvbmZpZyB0aGF0IG1hdGNoZXM6XHJcbiAgICAgICAgICAgICAqIDEuIEEgbmFtZSB0aGF0IGV4YWN0bHkgbWF0Y2hlcyB0aGUgc2VydmljZSBhbmQgbWV0aG9kXHJcbiAgICAgICAgICAgICAqIDIuIEEgbmFtZSB3aXRoIG5vIG1ldGhvZCBzZXQgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2aWNlXHJcbiAgICAgICAgICAgICAqIDMuIEFuIGVtcHR5IG5hbWVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2hMZXZlbCBvZiBOQU1FX01BVENIX0xFVkVMX09SREVSKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ0NvbmZpZyA9IGZpbmRNYXRjaGluZ0NvbmZpZyhzZXJ2aWNlLCBtZXRob2QsIHNlcnZpY2VDb25maWcubWV0aG9kQ29uZmlnLCBtYXRjaExldmVsKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ0NvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogbWF0Y2hpbmdDb25maWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tJbmZvcm1hdGlvbjoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljRmlsdGVyRmFjdG9yaWVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG1ldGhvZENvbmZpZzogeyBuYW1lOiBbXSB9LFxyXG4gICAgICAgICAgICBwaWNrSW5mb3JtYXRpb246IHt9LFxyXG4gICAgICAgICAgICBzdGF0dXM6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcclxuICAgICAgICAgICAgZHluYW1pY0ZpbHRlckZhY3RvcmllczogW10sXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuY2xhc3MgUmVzb2x2aW5nTG9hZEJhbGFuY2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogV3JhcHBlciBjbGFzcyB0aGF0IGJlaGF2ZXMgbGlrZSBhIGBMb2FkQmFsYW5jZXJgIGFuZCBhbHNvIGhhbmRsZXMgbmFtZVxyXG4gICAgICogcmVzb2x1dGlvbiBpbnRlcm5hbGx5LlxyXG4gICAgICogQHBhcmFtIHRhcmdldCBUaGUgYWRkcmVzcyBvZiB0aGUgYmFja2VuZCB0byBjb25uZWN0IHRvLlxyXG4gICAgICogQHBhcmFtIGNoYW5uZWxDb250cm9sSGVscGVyIGBDaGFubmVsQ29udHJvbEhlbHBlcmAgaW5zdGFuY2UgcHJvdmlkZWQgYnlcclxuICAgICAqICAgICB0aGlzIGxvYWQgYmFsYW5jZXIncyBvd25lci5cclxuICAgICAqIEBwYXJhbSBkZWZhdWx0U2VydmljZUNvbmZpZyBUaGUgZGVmYXVsdCBzZXJ2aWNlIGNvbmZpZ3VyYXRpb24gdG8gYmUgdXNlZFxyXG4gICAgICogICAgIGlmIG5vbmUgaXMgcHJvdmlkZWQgYnkgdGhlIG5hbWUgcmVzb2x2ZXIuIEEgYG51bGxgIHZhbHVlIGluZGljYXRlc1xyXG4gICAgICogICAgIHRoYXQgdGhlIGRlZmF1bHQgYmVoYXZpb3Igc2hvdWxkIGJlIHRoZSBkZWZhdWx0IHVuY29uZmlndXJlZCBiZWhhdmlvci5cclxuICAgICAqICAgICBJbiBwcmFjdGljZSwgdGhhdCBtZWFucyB1c2luZyB0aGUgXCJwaWNrIGZpcnN0XCIgbG9hZCBiYWxhbmNlclxyXG4gICAgICogICAgIGltcGxtZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjaGFubmVsQ29udHJvbEhlbHBlciwgY2hhbm5lbE9wdGlvbnMsIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb24sIG9uRmFpbGVkUmVzb2x1dGlvbikge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcclxuICAgICAgICB0aGlzLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24gPSBvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uID0gb25GYWlsZWRSZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XHJcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIHJlc29sdmluZyBsb2FkIGJhbGFuY2VyJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzZXJ2aWNlIGNvbmZpZyBvYmplY3QgZnJvbSB0aGUgbGFzdCBzdWNjZXNzZnVsIHJlc29sdXRpb24sIGlmXHJcbiAgICAgICAgICogYXZhaWxhYmxlLiBBIHZhbHVlIG9mIG51bGwgaW5kaWNhdGVzIHRoYXQgd2UgaGF2ZSBub3QgeWV0IHJlY2VpdmVkIGEgdmFsaWRcclxuICAgICAgICAgKiBzZXJ2aWNlIGNvbmZpZyBmcm9tIHRoZSByZXNvbHZlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgd2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmVzb2x2ZSBhZ2FpbiBhZnRlciB0aGUgYmFja29mZlxyXG4gICAgICAgICAqIHRpbWVyIHJ1bnMgb3V0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcclxuICAgICAgICBpZiAoY2hhbm5lbE9wdGlvbnNbJ2dycGMuc2VydmljZV9jb25maWcnXSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnID0gKDAsIHNlcnZpY2VfY29uZmlnXzEudmFsaWRhdGVTZXJ2aWNlQ29uZmlnKShKU09OLnBhcnNlKGNoYW5uZWxPcHRpb25zWydncnBjLnNlcnZpY2VfY29uZmlnJ10pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWcgPSB7XHJcbiAgICAgICAgICAgICAgICBsb2FkQmFsYW5jaW5nQ29uZmlnOiBbXSxcclxuICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogW10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcclxuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyID0gbmV3IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlcih7XHJcbiAgICAgICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IGNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwuYmluZChjaGFubmVsQ29udHJvbEhlbHBlciksXHJcbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb246ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBiYWNrb2ZmVGltZW91dCBpcyBydW5uaW5nLCB3ZSdyZSBzdGlsbCBiYWNraW5nIG9mZiBmcm9tXHJcbiAgICAgICAgICAgICAgICAgKiBtYWtpbmcgcmVzb2x2ZSByZXF1ZXN0cywgc28gd2Ugc2hvdWxkbid0IG1ha2UgYW5vdGhlciBvbmUgaGVyZS5cclxuICAgICAgICAgICAgICAgICAqIEluIHRoYXQgY2FzZSwgdGhlIGJhY2tvZmYgdGltZXIgY2FsbGJhY2sgd2lsbCBjYWxsXHJcbiAgICAgICAgICAgICAgICAgKiB1cGRhdGVSZXNvbHV0aW9uICovXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdyZXF1ZXN0UmVyZXNvbHV0aW9uIGRlbGF5ZWQgYnkgYmFja29mZiB0aW1lciB1bnRpbCAnICsgdGhpcy5iYWNrb2ZmVGltZW91dC5nZXRFbmRUaW1lKCkudG9JU09TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChuZXdTdGF0ZSwgcGlja2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENoaWxkU3RhdGUgPSBuZXdTdGF0ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgPSBwaWNrZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiBjaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkLmJpbmQoY2hhbm5lbENvbnRyb2xIZWxwZXIpLFxyXG4gICAgICAgICAgICByZW1vdmVDaGFubmVsekNoaWxkOiBjaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkLmJpbmQoY2hhbm5lbENvbnRyb2xIZWxwZXIpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlciA9ICgwLCByZXNvbHZlcl8xLmNyZWF0ZVJlc29sdmVyKSh0YXJnZXQsIHtcclxuICAgICAgICAgICAgb25TdWNjZXNzZnVsUmVzb2x1dGlvbjogKGFkZHJlc3NMaXN0LCBzZXJ2aWNlQ29uZmlnLCBzZXJ2aWNlQ29uZmlnRXJyb3IsIGNvbmZpZ1NlbGVjdG9yLCBhdHRyaWJ1dGVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIGxldCB3b3JraW5nU2VydmljZUNvbmZpZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvKiBUaGlzIGZpcnN0IGdyb3VwIG9mIGNvbmRpdGlvbmFscyBpbXBsZW1lbnRzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkXHJcbiAgICAgICAgICAgICAgICAgKiBpbiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9wcm9wb3NhbC9ibG9iL21hc3Rlci9BMjEtc2VydmljZS1jb25maWctZXJyb3ItaGFuZGxpbmcubWRcclxuICAgICAgICAgICAgICAgICAqIGluIHRoZSBzZWN0aW9uIGNhbGxlZCBcIkJlaGF2aW9yIG9uIHJlY2VpdmluZyBhIG5ldyBnUlBDIENvbmZpZ1wiLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VydmljZUNvbmZpZyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNCBhbmQgNVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnRXJyb3IgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0LmlpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc29sdXRpb25GYWlsdXJlKHNlcnZpY2VDb25maWdFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDQuaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgM1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gc2VydmljZUNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IHNlcnZpY2VDb25maWc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JraW5nQ29uZmlnTGlzdCA9IChfYSA9IHdvcmtpbmdTZXJ2aWNlQ29uZmlnID09PSBudWxsIHx8IHdvcmtpbmdTZXJ2aWNlQ29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3b3JraW5nU2VydmljZUNvbmZpZy5sb2FkQmFsYW5jaW5nQ29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRCYWxhbmNpbmdDb25maWcgPSAoMCwgbG9hZF9iYWxhbmNlcl8xLmdldEZpcnN0VXNhYmxlQ29uZmlnKSh3b3JraW5nQ29uZmlnTGlzdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9hZEJhbGFuY2luZ0NvbmZpZyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdlcmUgbG9hZCBiYWxhbmNpbmcgY29uZmlncyBidXQgbm9uZSBhcmUgc3VwcG9ydGVkLiBUaGlzIGNvdW50cyBhcyBhIHJlc29sdXRpb24gZmFpbHVyZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzb2x1dGlvbkZhaWx1cmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdBbGwgbG9hZCBiYWxhbmNlciBvcHRpb25zIGluIHNlcnZpY2UgY29uZmlnIGFyZSBub3QgY29tcGF0aWJsZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxvYWRCYWxhbmNpbmdDb25maWcsIGF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxTZXJ2aWNlQ29uZmlnID0gd29ya2luZ1NlcnZpY2VDb25maWcgIT09IG51bGwgJiYgd29ya2luZ1NlcnZpY2VDb25maWcgIT09IHZvaWQgMCA/IHdvcmtpbmdTZXJ2aWNlQ29uZmlnIDogdGhpcy5kZWZhdWx0U2VydmljZUNvbmZpZztcclxuICAgICAgICAgICAgICAgIHRoaXMub25TdWNjZXNzZnVsUmVzb2x1dGlvbihmaW5hbFNlcnZpY2VDb25maWcsIGNvbmZpZ1NlbGVjdG9yICE9PSBudWxsICYmIGNvbmZpZ1NlbGVjdG9yICE9PSB2b2lkIDAgPyBjb25maWdTZWxlY3RvciA6IGdldERlZmF1bHRDb25maWdTZWxlY3RvcihmaW5hbFNlcnZpY2VDb25maWcpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc29sdXRpb25GYWlsdXJlKGVycm9yKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LCBjaGFubmVsT3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgYmFja29mZk9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGluaXRpYWxEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMuaW5pdGlhbF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxyXG4gICAgICAgICAgICBtYXhEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMubWF4X3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0ID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludWVSZXNvbHZpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzb2x1dGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLmxhdGVzdENoaWxkU3RhdGUsIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgYmFja29mZk9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQudW5yZWYoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyLnVwZGF0ZVJlc29sdXRpb24oKTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJ1bk9uY2UoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpIHtcclxuICAgICAgICB0cmFjZSgoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkgK1xyXG4gICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xyXG4gICAgICAgICAgICAnIC0+ICcgK1xyXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtjb25uZWN0aXZpdHlTdGF0ZV0pO1xyXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoaXMuZXhpdElkbGUoKSBpcyBjYWxsZWQgYnkgdGhlIHBpY2tlclxyXG4gICAgICAgIGlmIChjb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xyXG4gICAgICAgICAgICBwaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5U3RhdGU7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKTtcclxuICAgIH1cclxuICAgIGhhbmRsZVJlc29sdXRpb25GYWlsdXJlKGVycm9yKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoZXJyb3IpKTtcclxuICAgICAgICAgICAgdGhpcy5vbkZhaWxlZFJlc29sdXRpb24oZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4aXRJZGxlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSB8fFxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYmFja29mZlRpbWVvdXQuaXNSdW5uaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxiQ29uZmlnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1cGRhdGVBZGRyZXNzTGlzdCBub3Qgc3VwcG9ydGVkIG9uIFJlc29sdmluZ0xvYWRCYWxhbmNlcicpO1xyXG4gICAgfVxyXG4gICAgcmVzZXRCYWNrb2ZmKCkge1xyXG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcclxuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLnJlc2V0QmFja29mZigpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmlubmVyUmVzb2x2ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcclxuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcclxuICAgICAgICB0aGlzLmxhdGVzdENoaWxkU3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xyXG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xyXG4gICAgICAgIHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBnZXRUeXBlTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gJ3Jlc29sdmluZ19sb2FkX2JhbGFuY2VyJztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlJlc29sdmluZ0xvYWRCYWxhbmNlciA9IFJlc29sdmluZ0xvYWRCYWxhbmNlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/retrying-call.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst TRACER_NAME = 'retrying_call';\r\nclass RetryThrottler {\r\n    constructor(maxTokens, tokenRatio, previousRetryThrottler) {\r\n        this.maxTokens = maxTokens;\r\n        this.tokenRatio = tokenRatio;\r\n        if (previousRetryThrottler) {\r\n            /* When carrying over tokens from a previous config, rescale them to the\r\n             * new max value */\r\n            this.tokens =\r\n                previousRetryThrottler.tokens *\r\n                    (maxTokens / previousRetryThrottler.maxTokens);\r\n        }\r\n        else {\r\n            this.tokens = maxTokens;\r\n        }\r\n    }\r\n    addCallSucceeded() {\r\n        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\r\n    }\r\n    addCallFailed() {\r\n        this.tokens = Math.min(this.tokens - 1, 0);\r\n    }\r\n    canRetryCall() {\r\n        return this.tokens > this.maxTokens / 2;\r\n    }\r\n}\r\nexports.RetryThrottler = RetryThrottler;\r\nclass MessageBufferTracker {\r\n    constructor(totalLimit, limitPerCall) {\r\n        this.totalLimit = totalLimit;\r\n        this.limitPerCall = limitPerCall;\r\n        this.totalAllocated = 0;\r\n        this.allocatedPerCall = new Map();\r\n    }\r\n    allocate(size, callId) {\r\n        var _a;\r\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\r\n        if (this.limitPerCall - currentPerCall < size ||\r\n            this.totalLimit - this.totalAllocated < size) {\r\n            return false;\r\n        }\r\n        this.allocatedPerCall.set(callId, currentPerCall + size);\r\n        this.totalAllocated += size;\r\n        return true;\r\n    }\r\n    free(size, callId) {\r\n        var _a;\r\n        if (this.totalAllocated < size) {\r\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\r\n        }\r\n        this.totalAllocated -= size;\r\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\r\n        if (currentPerCall < size) {\r\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\r\n        }\r\n        this.allocatedPerCall.set(callId, currentPerCall - size);\r\n    }\r\n    freeAll(callId) {\r\n        var _a;\r\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\r\n        if (this.totalAllocated < currentPerCall) {\r\n            throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\r\n        }\r\n        this.totalAllocated -= currentPerCall;\r\n        this.allocatedPerCall.delete(callId);\r\n    }\r\n}\r\nexports.MessageBufferTracker = MessageBufferTracker;\r\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\r\nclass RetryingCall {\r\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {\r\n        this.channel = channel;\r\n        this.callConfig = callConfig;\r\n        this.methodName = methodName;\r\n        this.host = host;\r\n        this.credentials = credentials;\r\n        this.deadline = deadline;\r\n        this.callNumber = callNumber;\r\n        this.bufferTracker = bufferTracker;\r\n        this.retryThrottler = retryThrottler;\r\n        this.listener = null;\r\n        this.initialMetadata = null;\r\n        this.underlyingCalls = [];\r\n        this.writeBuffer = [];\r\n        /**\r\n         * The offset of message indices in the writeBuffer. For example, if\r\n         * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\r\n         * is in writeBuffer[5].\r\n         */\r\n        this.writeBufferOffset = 0;\r\n        /**\r\n         * Tracks whether a read has been started, so that we know whether to start\r\n         * reads on new child calls. This only matters for the first read, because\r\n         * once a message comes in the child call becomes committed and there will\r\n         * be no new child calls.\r\n         */\r\n        this.readStarted = false;\r\n        this.transparentRetryUsed = false;\r\n        /**\r\n         * Number of attempts so far\r\n         */\r\n        this.attempts = 0;\r\n        this.hedgingTimer = null;\r\n        this.committedCallIndex = null;\r\n        this.initialRetryBackoffSec = 0;\r\n        this.nextRetryBackoffSec = 0;\r\n        if (callConfig.methodConfig.retryPolicy) {\r\n            this.state = 'RETRY';\r\n            const retryPolicy = callConfig.methodConfig.retryPolicy;\r\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\r\n        }\r\n        else if (callConfig.methodConfig.hedgingPolicy) {\r\n            this.state = 'HEDGING';\r\n        }\r\n        else {\r\n            this.state = 'TRANSPARENT_ONLY';\r\n        }\r\n    }\r\n    getCallNumber() {\r\n        return this.callNumber;\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\r\n    }\r\n    reportStatus(statusObject) {\r\n        this.trace('ended with status: code=' +\r\n            statusObject.code +\r\n            ' details=\"' +\r\n            statusObject.details +\r\n            '\"');\r\n        this.bufferTracker.freeAll(this.callNumber);\r\n        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\r\n        this.writeBuffer = [];\r\n        process.nextTick(() => {\r\n            var _a;\r\n            // Explicitly construct status object to remove progress field\r\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({\r\n                code: statusObject.code,\r\n                details: statusObject.details,\r\n                metadata: statusObject.metadata,\r\n            });\r\n        });\r\n    }\r\n    cancelWithStatus(status, details) {\r\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\r\n        this.reportStatus({ code: status, details, metadata: new metadata_1.Metadata() });\r\n        for (const { call } of this.underlyingCalls) {\r\n            call.cancelWithStatus(status, details);\r\n        }\r\n    }\r\n    getPeer() {\r\n        if (this.committedCallIndex !== null) {\r\n            return this.underlyingCalls[this.committedCallIndex].call.getPeer();\r\n        }\r\n        else {\r\n            return 'unknown';\r\n        }\r\n    }\r\n    getBufferEntry(messageIndex) {\r\n        var _a;\r\n        return ((_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {\r\n            entryType: 'FREED',\r\n            allocated: false,\r\n        });\r\n    }\r\n    getNextBufferIndex() {\r\n        return this.writeBufferOffset + this.writeBuffer.length;\r\n    }\r\n    clearSentMessages() {\r\n        if (this.state !== 'COMMITTED') {\r\n            return;\r\n        }\r\n        const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;\r\n        for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {\r\n            const bufferEntry = this.getBufferEntry(messageIndex);\r\n            if (bufferEntry.allocated) {\r\n                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);\r\n            }\r\n        }\r\n        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\r\n        this.writeBufferOffset = earliestNeededMessageIndex;\r\n    }\r\n    commitCall(index) {\r\n        if (this.state === 'COMMITTED') {\r\n            return;\r\n        }\r\n        if (this.underlyingCalls[index].state === 'COMPLETED') {\r\n            return;\r\n        }\r\n        this.trace('Committing call [' +\r\n            this.underlyingCalls[index].call.getCallNumber() +\r\n            '] at index ' +\r\n            index);\r\n        this.state = 'COMMITTED';\r\n        this.committedCallIndex = index;\r\n        for (let i = 0; i < this.underlyingCalls.length; i++) {\r\n            if (i === index) {\r\n                continue;\r\n            }\r\n            if (this.underlyingCalls[i].state === 'COMPLETED') {\r\n                continue;\r\n            }\r\n            this.underlyingCalls[i].state = 'COMPLETED';\r\n            this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');\r\n        }\r\n        this.clearSentMessages();\r\n    }\r\n    commitCallWithMostMessages() {\r\n        if (this.state === 'COMMITTED') {\r\n            return;\r\n        }\r\n        let mostMessages = -1;\r\n        let callWithMostMessages = -1;\r\n        for (const [index, childCall] of this.underlyingCalls.entries()) {\r\n            if (childCall.state === 'ACTIVE' &&\r\n                childCall.nextMessageToSend > mostMessages) {\r\n                mostMessages = childCall.nextMessageToSend;\r\n                callWithMostMessages = index;\r\n            }\r\n        }\r\n        if (callWithMostMessages === -1) {\r\n            /* There are no active calls, disable retries to force the next call that\r\n             * is started to be committed. */\r\n            this.state = 'TRANSPARENT_ONLY';\r\n        }\r\n        else {\r\n            this.commitCall(callWithMostMessages);\r\n        }\r\n    }\r\n    isStatusCodeInList(list, code) {\r\n        return list.some(value => value === code ||\r\n            value.toString().toLowerCase() === constants_1.Status[code].toLowerCase());\r\n    }\r\n    getNextRetryBackoffMs() {\r\n        var _a;\r\n        const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;\r\n        if (!retryPolicy) {\r\n            return 0;\r\n        }\r\n        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\r\n        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\r\n        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\r\n        return nextBackoffMs;\r\n    }\r\n    maybeRetryCall(pushback, callback) {\r\n        if (this.state !== 'RETRY') {\r\n            callback(false);\r\n            return;\r\n        }\r\n        const retryPolicy = this.callConfig.methodConfig.retryPolicy;\r\n        if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {\r\n            callback(false);\r\n            return;\r\n        }\r\n        let retryDelayMs;\r\n        if (pushback === null) {\r\n            retryDelayMs = this.getNextRetryBackoffMs();\r\n        }\r\n        else if (pushback < 0) {\r\n            this.state = 'TRANSPARENT_ONLY';\r\n            callback(false);\r\n            return;\r\n        }\r\n        else {\r\n            retryDelayMs = pushback;\r\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec;\r\n        }\r\n        setTimeout(() => {\r\n            var _a, _b;\r\n            if (this.state !== 'RETRY') {\r\n                callback(false);\r\n                return;\r\n            }\r\n            if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {\r\n                callback(true);\r\n                this.attempts += 1;\r\n                this.startNewAttempt();\r\n            }\r\n        }, retryDelayMs);\r\n    }\r\n    countActiveCalls() {\r\n        let count = 0;\r\n        for (const call of this.underlyingCalls) {\r\n            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE') {\r\n                count += 1;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n    handleProcessedStatus(status, callIndex, pushback) {\r\n        var _a, _b, _c;\r\n        switch (this.state) {\r\n            case 'COMMITTED':\r\n            case 'TRANSPARENT_ONLY':\r\n                this.commitCall(callIndex);\r\n                this.reportStatus(status);\r\n                break;\r\n            case 'HEDGING':\r\n                if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {\r\n                    (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();\r\n                    let delayMs;\r\n                    if (pushback === null) {\r\n                        delayMs = 0;\r\n                    }\r\n                    else if (pushback < 0) {\r\n                        this.state = 'TRANSPARENT_ONLY';\r\n                        this.commitCall(callIndex);\r\n                        this.reportStatus(status);\r\n                        return;\r\n                    }\r\n                    else {\r\n                        delayMs = pushback;\r\n                    }\r\n                    setTimeout(() => {\r\n                        this.maybeStartHedgingAttempt();\r\n                        // If after trying to start a call there are no active calls, this was the last one\r\n                        if (this.countActiveCalls() === 0) {\r\n                            this.commitCall(callIndex);\r\n                            this.reportStatus(status);\r\n                        }\r\n                    }, delayMs);\r\n                }\r\n                else {\r\n                    this.commitCall(callIndex);\r\n                    this.reportStatus(status);\r\n                }\r\n                break;\r\n            case 'RETRY':\r\n                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {\r\n                    (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();\r\n                    this.maybeRetryCall(pushback, retried => {\r\n                        if (!retried) {\r\n                            this.commitCall(callIndex);\r\n                            this.reportStatus(status);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    this.commitCall(callIndex);\r\n                    this.reportStatus(status);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    getPushback(metadata) {\r\n        const mdValue = metadata.get('grpc-retry-pushback-ms');\r\n        if (mdValue.length === 0) {\r\n            return null;\r\n        }\r\n        try {\r\n            return parseInt(mdValue[0]);\r\n        }\r\n        catch (e) {\r\n            return -1;\r\n        }\r\n    }\r\n    handleChildStatus(status, callIndex) {\r\n        var _a;\r\n        if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\r\n            return;\r\n        }\r\n        this.trace('state=' +\r\n            this.state +\r\n            ' handling status with progress ' +\r\n            status.progress +\r\n            ' from child [' +\r\n            this.underlyingCalls[callIndex].call.getCallNumber() +\r\n            '] in state ' +\r\n            this.underlyingCalls[callIndex].state);\r\n        this.underlyingCalls[callIndex].state = 'COMPLETED';\r\n        if (status.code === constants_1.Status.OK) {\r\n            (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();\r\n            this.commitCall(callIndex);\r\n            this.reportStatus(status);\r\n            return;\r\n        }\r\n        if (this.state === 'COMMITTED') {\r\n            this.reportStatus(status);\r\n            return;\r\n        }\r\n        const pushback = this.getPushback(status.metadata);\r\n        switch (status.progress) {\r\n            case 'NOT_STARTED':\r\n                // RPC never leaves the client, always safe to retry\r\n                this.startNewAttempt();\r\n                break;\r\n            case 'REFUSED':\r\n                // RPC reaches the server library, but not the server application logic\r\n                if (this.transparentRetryUsed) {\r\n                    this.handleProcessedStatus(status, callIndex, pushback);\r\n                }\r\n                else {\r\n                    this.transparentRetryUsed = true;\r\n                    this.startNewAttempt();\r\n                }\r\n                break;\r\n            case 'DROP':\r\n                this.commitCall(callIndex);\r\n                this.reportStatus(status);\r\n                break;\r\n            case 'PROCESSED':\r\n                this.handleProcessedStatus(status, callIndex, pushback);\r\n                break;\r\n        }\r\n    }\r\n    maybeStartHedgingAttempt() {\r\n        if (this.state !== 'HEDGING') {\r\n            return;\r\n        }\r\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\r\n            return;\r\n        }\r\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\r\n        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\r\n            return;\r\n        }\r\n        this.attempts += 1;\r\n        this.startNewAttempt();\r\n        this.maybeStartHedgingTimer();\r\n    }\r\n    maybeStartHedgingTimer() {\r\n        var _a, _b, _c;\r\n        if (this.hedgingTimer) {\r\n            clearTimeout(this.hedgingTimer);\r\n        }\r\n        if (this.state !== 'HEDGING') {\r\n            return;\r\n        }\r\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\r\n            return;\r\n        }\r\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\r\n        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\r\n            return;\r\n        }\r\n        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : '0s';\r\n        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\r\n        this.hedgingTimer = setTimeout(() => {\r\n            this.maybeStartHedgingAttempt();\r\n        }, hedgingDelaySec * 1000);\r\n        (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\r\n    }\r\n    startNewAttempt() {\r\n        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\r\n        this.trace('Created child call [' +\r\n            child.getCallNumber() +\r\n            '] for attempt ' +\r\n            this.attempts);\r\n        const index = this.underlyingCalls.length;\r\n        this.underlyingCalls.push({\r\n            state: 'ACTIVE',\r\n            call: child,\r\n            nextMessageToSend: 0,\r\n        });\r\n        const previousAttempts = this.attempts - 1;\r\n        const initialMetadata = this.initialMetadata.clone();\r\n        if (previousAttempts > 0) {\r\n            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\r\n        }\r\n        let receivedMetadata = false;\r\n        child.start(initialMetadata, {\r\n            onReceiveMetadata: metadata => {\r\n                this.trace('Received metadata from child [' + child.getCallNumber() + ']');\r\n                this.commitCall(index);\r\n                receivedMetadata = true;\r\n                if (previousAttempts > 0) {\r\n                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\r\n                }\r\n                if (this.underlyingCalls[index].state === 'ACTIVE') {\r\n                    this.listener.onReceiveMetadata(metadata);\r\n                }\r\n            },\r\n            onReceiveMessage: message => {\r\n                this.trace('Received message from child [' + child.getCallNumber() + ']');\r\n                this.commitCall(index);\r\n                if (this.underlyingCalls[index].state === 'ACTIVE') {\r\n                    this.listener.onReceiveMessage(message);\r\n                }\r\n            },\r\n            onReceiveStatus: status => {\r\n                this.trace('Received status from child [' + child.getCallNumber() + ']');\r\n                if (!receivedMetadata && previousAttempts > 0) {\r\n                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\r\n                }\r\n                this.handleChildStatus(status, index);\r\n            },\r\n        });\r\n        this.sendNextChildMessage(index);\r\n        if (this.readStarted) {\r\n            child.startRead();\r\n        }\r\n    }\r\n    start(metadata, listener) {\r\n        this.trace('start called');\r\n        this.listener = listener;\r\n        this.initialMetadata = metadata;\r\n        this.attempts += 1;\r\n        this.startNewAttempt();\r\n        this.maybeStartHedgingTimer();\r\n    }\r\n    handleChildWriteCompleted(childIndex) {\r\n        var _a, _b;\r\n        const childCall = this.underlyingCalls[childIndex];\r\n        const messageIndex = childCall.nextMessageToSend;\r\n        (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        this.clearSentMessages();\r\n        childCall.nextMessageToSend += 1;\r\n        this.sendNextChildMessage(childIndex);\r\n    }\r\n    sendNextChildMessage(childIndex) {\r\n        const childCall = this.underlyingCalls[childIndex];\r\n        if (childCall.state === 'COMPLETED') {\r\n            return;\r\n        }\r\n        if (this.getBufferEntry(childCall.nextMessageToSend)) {\r\n            const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\r\n            switch (bufferEntry.entryType) {\r\n                case 'MESSAGE':\r\n                    childCall.call.sendMessageWithContext({\r\n                        callback: error => {\r\n                            // Ignore error\r\n                            this.handleChildWriteCompleted(childIndex);\r\n                        },\r\n                    }, bufferEntry.message.message);\r\n                    break;\r\n                case 'HALF_CLOSE':\r\n                    childCall.nextMessageToSend += 1;\r\n                    childCall.call.halfClose();\r\n                    break;\r\n                case 'FREED':\r\n                    // Should not be possible\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    sendMessageWithContext(context, message) {\r\n        var _a;\r\n        this.trace('write() called with message of length ' + message.length);\r\n        const writeObj = {\r\n            message,\r\n            flags: context.flags,\r\n        };\r\n        const messageIndex = this.getNextBufferIndex();\r\n        const bufferEntry = {\r\n            entryType: 'MESSAGE',\r\n            message: writeObj,\r\n            allocated: this.bufferTracker.allocate(message.length, this.callNumber),\r\n        };\r\n        this.writeBuffer.push(bufferEntry);\r\n        if (bufferEntry.allocated) {\r\n            (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\r\n            for (const [callIndex, call] of this.underlyingCalls.entries()) {\r\n                if (call.state === 'ACTIVE' &&\r\n                    call.nextMessageToSend === messageIndex) {\r\n                    call.call.sendMessageWithContext({\r\n                        callback: error => {\r\n                            // Ignore error\r\n                            this.handleChildWriteCompleted(callIndex);\r\n                        },\r\n                    }, message);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.commitCallWithMostMessages();\r\n            // commitCallWithMostMessages can fail if we are between ping attempts\r\n            if (this.committedCallIndex === null) {\r\n                return;\r\n            }\r\n            const call = this.underlyingCalls[this.committedCallIndex];\r\n            bufferEntry.callback = context.callback;\r\n            if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\r\n                call.call.sendMessageWithContext({\r\n                    callback: error => {\r\n                        // Ignore error\r\n                        this.handleChildWriteCompleted(this.committedCallIndex);\r\n                    },\r\n                }, message);\r\n            }\r\n        }\r\n    }\r\n    startRead() {\r\n        this.trace('startRead called');\r\n        this.readStarted = true;\r\n        for (const underlyingCall of this.underlyingCalls) {\r\n            if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === 'ACTIVE') {\r\n                underlyingCall.call.startRead();\r\n            }\r\n        }\r\n    }\r\n    halfClose() {\r\n        this.trace('halfClose called');\r\n        const halfCloseIndex = this.getNextBufferIndex();\r\n        this.writeBuffer.push({\r\n            entryType: 'HALF_CLOSE',\r\n            allocated: false,\r\n        });\r\n        for (const call of this.underlyingCalls) {\r\n            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE' &&\r\n                call.nextMessageToSend === halfCloseIndex) {\r\n                call.nextMessageToSend += 1;\r\n                call.call.halfClose();\r\n            }\r\n        }\r\n    }\r\n    setCredentials(newCredentials) {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    getMethod() {\r\n        return this.methodName;\r\n    }\r\n    getHost() {\r\n        return this.host;\r\n    }\r\n}\r\nexports.RetryingCall = RetryingCall;\r\n//# sourceMappingURL=retrying-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmV0cnlpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLDRCQUE0QixHQUFHLHNCQUFzQjtBQUM1RSxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxRQUFRLFFBQVEsTUFBTSxvQkFBb0Isb0JBQW9CO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVEsUUFBUSxNQUFNLHVCQUF1QixlQUFlO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVEsWUFBWSxnQkFBZ0Isb0JBQW9CLG9CQUFvQjtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUE0RDtBQUN4RixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsMkNBQTJDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxpQkFBaUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpQkFBaUI7QUFDaEc7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXRyeWluZy1jYWxsLmpzP2MxYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuUmV0cnlpbmdDYWxsID0gZXhwb3J0cy5NZXNzYWdlQnVmZmVyVHJhY2tlciA9IGV4cG9ydHMuUmV0cnlUaHJvdHRsZXIgPSB2b2lkIDA7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XHJcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyZXRyeWluZ19jYWxsJztcclxuY2xhc3MgUmV0cnlUaHJvdHRsZXIge1xyXG4gICAgY29uc3RydWN0b3IobWF4VG9rZW5zLCB0b2tlblJhdGlvLCBwcmV2aW91c1JldHJ5VGhyb3R0bGVyKSB7XHJcbiAgICAgICAgdGhpcy5tYXhUb2tlbnMgPSBtYXhUb2tlbnM7XHJcbiAgICAgICAgdGhpcy50b2tlblJhdGlvID0gdG9rZW5SYXRpbztcclxuICAgICAgICBpZiAocHJldmlvdXNSZXRyeVRocm90dGxlcikge1xyXG4gICAgICAgICAgICAvKiBXaGVuIGNhcnJ5aW5nIG92ZXIgdG9rZW5zIGZyb20gYSBwcmV2aW91cyBjb25maWcsIHJlc2NhbGUgdGhlbSB0byB0aGVcclxuICAgICAgICAgICAgICogbmV3IG1heCB2YWx1ZSAqL1xyXG4gICAgICAgICAgICB0aGlzLnRva2VucyA9XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c1JldHJ5VGhyb3R0bGVyLnRva2VucyAqXHJcbiAgICAgICAgICAgICAgICAgICAgKG1heFRva2VucyAvIHByZXZpb3VzUmV0cnlUaHJvdHRsZXIubWF4VG9rZW5zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9rZW5zID0gbWF4VG9rZW5zO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZENhbGxTdWNjZWVkZWQoKSB7XHJcbiAgICAgICAgdGhpcy50b2tlbnMgPSBNYXRoLm1heCh0aGlzLnRva2VucyArIHRoaXMudG9rZW5SYXRpbywgdGhpcy5tYXhUb2tlbnMpO1xyXG4gICAgfVxyXG4gICAgYWRkQ2FsbEZhaWxlZCgpIHtcclxuICAgICAgICB0aGlzLnRva2VucyA9IE1hdGgubWluKHRoaXMudG9rZW5zIC0gMSwgMCk7XHJcbiAgICB9XHJcbiAgICBjYW5SZXRyeUNhbGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zID4gdGhpcy5tYXhUb2tlbnMgLyAyO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmV0cnlUaHJvdHRsZXIgPSBSZXRyeVRocm90dGxlcjtcclxuY2xhc3MgTWVzc2FnZUJ1ZmZlclRyYWNrZXIge1xyXG4gICAgY29uc3RydWN0b3IodG90YWxMaW1pdCwgbGltaXRQZXJDYWxsKSB7XHJcbiAgICAgICAgdGhpcy50b3RhbExpbWl0ID0gdG90YWxMaW1pdDtcclxuICAgICAgICB0aGlzLmxpbWl0UGVyQ2FsbCA9IGxpbWl0UGVyQ2FsbDtcclxuICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGVkID0gMDtcclxuICAgICAgICB0aGlzLmFsbG9jYXRlZFBlckNhbGwgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZShzaXplLCBjYWxsSWQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFBlckNhbGwgPSAoX2EgPSB0aGlzLmFsbG9jYXRlZFBlckNhbGwuZ2V0KGNhbGxJZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XHJcbiAgICAgICAgaWYgKHRoaXMubGltaXRQZXJDYWxsIC0gY3VycmVudFBlckNhbGwgPCBzaXplIHx8XHJcbiAgICAgICAgICAgIHRoaXMudG90YWxMaW1pdCAtIHRoaXMudG90YWxBbGxvY2F0ZWQgPCBzaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLnNldChjYWxsSWQsIGN1cnJlbnRQZXJDYWxsICsgc2l6ZSk7XHJcbiAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRlZCArPSBzaXplO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZnJlZShzaXplLCBjYWxsSWQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKHRoaXMudG90YWxBbGxvY2F0ZWQgPCBzaXplKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBidWZmZXIgYWxsb2NhdGlvbiBzdGF0ZTogY2FsbCAke2NhbGxJZH0gZnJlZWQgJHtzaXplfSA+IHRvdGFsIGFsbG9jYXRlZCAke3RoaXMudG90YWxBbGxvY2F0ZWR9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgLT0gc2l6ZTtcclxuICAgICAgICBjb25zdCBjdXJyZW50UGVyQ2FsbCA9IChfYSA9IHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5nZXQoY2FsbElkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgICAgICBpZiAoY3VycmVudFBlckNhbGwgPCBzaXplKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBidWZmZXIgYWxsb2NhdGlvbiBzdGF0ZTogY2FsbCAke2NhbGxJZH0gZnJlZWQgJHtzaXplfSA+IGFsbG9jYXRlZCBmb3IgY2FsbCAke2N1cnJlbnRQZXJDYWxsfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFsbG9jYXRlZFBlckNhbGwuc2V0KGNhbGxJZCwgY3VycmVudFBlckNhbGwgLSBzaXplKTtcclxuICAgIH1cclxuICAgIGZyZWVBbGwoY2FsbElkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJDYWxsID0gKF9hID0gdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmdldChjYWxsSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xyXG4gICAgICAgIGlmICh0aGlzLnRvdGFsQWxsb2NhdGVkIDwgY3VycmVudFBlckNhbGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ1ZmZlciBhbGxvY2F0aW9uIHN0YXRlOiBjYWxsICR7Y2FsbElkfSBhbGxvY2F0ZWQgJHtjdXJyZW50UGVyQ2FsbH0gPiB0b3RhbCBhbGxvY2F0ZWQgJHt0aGlzLnRvdGFsQWxsb2NhdGVkfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGVkIC09IGN1cnJlbnRQZXJDYWxsO1xyXG4gICAgICAgIHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5kZWxldGUoY2FsbElkKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk1lc3NhZ2VCdWZmZXJUcmFja2VyID0gTWVzc2FnZUJ1ZmZlclRyYWNrZXI7XHJcbmNvbnN0IFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVkgPSAnZ3JwYy1wcmV2aW91cy1ycGMtYXR0ZW1wdHMnO1xyXG5jbGFzcyBSZXRyeWluZ0NhbGwge1xyXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgY2FsbENvbmZpZywgbWV0aG9kTmFtZSwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lLCBjYWxsTnVtYmVyLCBidWZmZXJUcmFja2VyLCByZXRyeVRocm90dGxlcikge1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XHJcbiAgICAgICAgdGhpcy5jYWxsQ29uZmlnID0gY2FsbENvbmZpZztcclxuICAgICAgICB0aGlzLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xyXG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xyXG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBkZWFkbGluZTtcclxuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyVHJhY2tlciA9IGJ1ZmZlclRyYWNrZXI7XHJcbiAgICAgICAgdGhpcy5yZXRyeVRocm90dGxlciA9IHJldHJ5VGhyb3R0bGVyO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbE1ldGFkYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxscyA9IFtdO1xyXG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb2Zmc2V0IG9mIG1lc3NhZ2UgaW5kaWNlcyBpbiB0aGUgd3JpdGVCdWZmZXIuIEZvciBleGFtcGxlLCBpZlxyXG4gICAgICAgICAqIHdyaXRlQnVmZmVyT2Zmc2V0IGlzIDEwLCBtZXNzYWdlIDEwIGlzIGluIHdyaXRlQnVmZmVyWzBdIGFuZCBtZXNzYWdlIDE1XHJcbiAgICAgICAgICogaXMgaW4gd3JpdGVCdWZmZXJbNV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlck9mZnNldCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhY2tzIHdoZXRoZXIgYSByZWFkIGhhcyBiZWVuIHN0YXJ0ZWQsIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIHRvIHN0YXJ0XHJcbiAgICAgICAgICogcmVhZHMgb24gbmV3IGNoaWxkIGNhbGxzLiBUaGlzIG9ubHkgbWF0dGVycyBmb3IgdGhlIGZpcnN0IHJlYWQsIGJlY2F1c2VcclxuICAgICAgICAgKiBvbmNlIGEgbWVzc2FnZSBjb21lcyBpbiB0aGUgY2hpbGQgY2FsbCBiZWNvbWVzIGNvbW1pdHRlZCBhbmQgdGhlcmUgd2lsbFxyXG4gICAgICAgICAqIGJlIG5vIG5ldyBjaGlsZCBjYWxscy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlYWRTdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE51bWJlciBvZiBhdHRlbXB0cyBzbyBmYXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmF0dGVtcHRzID0gMDtcclxuICAgICAgICB0aGlzLmhlZGdpbmdUaW1lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb21taXR0ZWRDYWxsSW5kZXggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbFJldHJ5QmFja29mZlNlYyA9IDA7XHJcbiAgICAgICAgdGhpcy5uZXh0UmV0cnlCYWNrb2ZmU2VjID0gMDtcclxuICAgICAgICBpZiAoY2FsbENvbmZpZy5tZXRob2RDb25maWcucmV0cnlQb2xpY3kpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdSRVRSWSc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5UG9saWN5ID0gY2FsbENvbmZpZy5tZXRob2RDb25maWcucmV0cnlQb2xpY3k7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyA9IHRoaXMuaW5pdGlhbFJldHJ5QmFja29mZlNlYyA9IE51bWJlcihyZXRyeVBvbGljeS5pbml0aWFsQmFja29mZi5zdWJzdHJpbmcoMCwgcmV0cnlQb2xpY3kuaW5pdGlhbEJhY2tvZmYubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnSEVER0lORyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1RSQU5TUEFSRU5UX09OTFknO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldENhbGxOdW1iZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbE51bWJlcjtcclxuICAgIH1cclxuICAgIHRyYWNlKHRleHQpIHtcclxuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbE51bWJlciArICddICcgKyB0ZXh0KTtcclxuICAgIH1cclxuICAgIHJlcG9ydFN0YXR1cyhzdGF0dXNPYmplY3QpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcclxuICAgICAgICAgICAgc3RhdHVzT2JqZWN0LmNvZGUgK1xyXG4gICAgICAgICAgICAnIGRldGFpbHM9XCInICtcclxuICAgICAgICAgICAgc3RhdHVzT2JqZWN0LmRldGFpbHMgK1xyXG4gICAgICAgICAgICAnXCInKTtcclxuICAgICAgICB0aGlzLmJ1ZmZlclRyYWNrZXIuZnJlZUFsbCh0aGlzLmNhbGxOdW1iZXIpO1xyXG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgPSB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ICsgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xyXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgY29uc3RydWN0IHN0YXR1cyBvYmplY3QgdG8gcmVtb3ZlIHByb2dyZXNzIGZpZWxkXHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMubGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vblJlY2VpdmVTdGF0dXMoe1xyXG4gICAgICAgICAgICAgICAgY29kZTogc3RhdHVzT2JqZWN0LmNvZGUsXHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBzdGF0dXNPYmplY3QuZGV0YWlscyxcclxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0dXNPYmplY3QubWV0YWRhdGEsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcclxuICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyh7IGNvZGU6IHN0YXR1cywgZGV0YWlscywgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkgfSk7XHJcbiAgICAgICAgZm9yIChjb25zdCB7IGNhbGwgfSBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xyXG4gICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbW1pdHRlZENhbGxJbmRleCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmRlcmx5aW5nQ2FsbHNbdGhpcy5jb21taXR0ZWRDYWxsSW5kZXhdLmNhbGwuZ2V0UGVlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRCdWZmZXJFbnRyeShtZXNzYWdlSW5kZXgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLndyaXRlQnVmZmVyW21lc3NhZ2VJbmRleCAtIHRoaXMud3JpdGVCdWZmZXJPZmZzZXRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7XHJcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ0ZSRUVEJyxcclxuICAgICAgICAgICAgYWxsb2NhdGVkOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldE5leHRCdWZmZXJJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUJ1ZmZlck9mZnNldCArIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY2xlYXJTZW50TWVzc2FnZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdDT01NSVRURUQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXggPSB0aGlzLnVuZGVybHlpbmdDYWxsc1t0aGlzLmNvbW1pdHRlZENhbGxJbmRleF0ubmV4dE1lc3NhZ2VUb1NlbmQ7XHJcbiAgICAgICAgZm9yIChsZXQgbWVzc2FnZUluZGV4ID0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldDsgbWVzc2FnZUluZGV4IDwgZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXg7IG1lc3NhZ2VJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckVudHJ5ID0gdGhpcy5nZXRCdWZmZXJFbnRyeShtZXNzYWdlSW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyRW50cnkuYWxsb2NhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlclRyYWNrZXIuZnJlZShidWZmZXJFbnRyeS5tZXNzYWdlLm1lc3NhZ2UubGVuZ3RoLCB0aGlzLmNhbGxOdW1iZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSB0aGlzLndyaXRlQnVmZmVyLnNsaWNlKGVhcmxpZXN0TmVlZGVkTWVzc2FnZUluZGV4IC0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlck9mZnNldCA9IGVhcmxpZXN0TmVlZGVkTWVzc2FnZUluZGV4O1xyXG4gICAgfVxyXG4gICAgY29tbWl0Q2FsbChpbmRleCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnQ09NTUlUVEVEJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxsc1tpbmRleF0uc3RhdGUgPT09ICdDT01QTEVURUQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFjZSgnQ29tbWl0dGluZyBjYWxsIFsnICtcclxuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbaW5kZXhdLmNhbGwuZ2V0Q2FsbE51bWJlcigpICtcclxuICAgICAgICAgICAgJ10gYXQgaW5kZXggJyArXHJcbiAgICAgICAgICAgIGluZGV4KTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gJ0NPTU1JVFRFRCc7XHJcbiAgICAgICAgdGhpcy5jb21taXR0ZWRDYWxsSW5kZXggPSBpbmRleDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudW5kZXJseWluZ0NhbGxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW2ldLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbaV0uc3RhdGUgPSAnQ09NUExFVEVEJztcclxuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbaV0uY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdEaXNjYXJkZWQgaW4gZmF2b3Igb2Ygb3RoZXIgaGVkZ2VkIGF0dGVtcHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbGVhclNlbnRNZXNzYWdlcygpO1xyXG4gICAgfVxyXG4gICAgY29tbWl0Q2FsbFdpdGhNb3N0TWVzc2FnZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdDT01NSVRURUQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG1vc3RNZXNzYWdlcyA9IC0xO1xyXG4gICAgICAgIGxldCBjYWxsV2l0aE1vc3RNZXNzYWdlcyA9IC0xO1xyXG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjaGlsZENhbGxdIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRDYWxsLnN0YXRlID09PSAnQUNUSVZFJyAmJlxyXG4gICAgICAgICAgICAgICAgY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kID4gbW9zdE1lc3NhZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBtb3N0TWVzc2FnZXMgPSBjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQ7XHJcbiAgICAgICAgICAgICAgICBjYWxsV2l0aE1vc3RNZXNzYWdlcyA9IGluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYWxsV2l0aE1vc3RNZXNzYWdlcyA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLyogVGhlcmUgYXJlIG5vIGFjdGl2ZSBjYWxscywgZGlzYWJsZSByZXRyaWVzIHRvIGZvcmNlIHRoZSBuZXh0IGNhbGwgdGhhdFxyXG4gICAgICAgICAgICAgKiBpcyBzdGFydGVkIHRvIGJlIGNvbW1pdHRlZC4gKi9cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdUUkFOU1BBUkVOVF9PTkxZJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsV2l0aE1vc3RNZXNzYWdlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNTdGF0dXNDb2RlSW5MaXN0KGxpc3QsIGNvZGUpIHtcclxuICAgICAgICByZXR1cm4gbGlzdC5zb21lKHZhbHVlID0+IHZhbHVlID09PSBjb2RlIHx8XHJcbiAgICAgICAgICAgIHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzW2NvZGVdLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0TmV4dFJldHJ5QmFja29mZk1zKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCByZXRyeVBvbGljeSA9IChfYSA9IHRoaXMuY2FsbENvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeTtcclxuICAgICAgICBpZiAoIXJldHJ5UG9saWN5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXh0QmFja29mZk1zID0gTWF0aC5yYW5kb20oKSAqIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyAqIDEwMDA7XHJcbiAgICAgICAgY29uc3QgbWF4QmFja29mZlNlYyA9IE51bWJlcihyZXRyeVBvbGljeS5tYXhCYWNrb2ZmLnN1YnN0cmluZygwLCByZXRyeVBvbGljeS5tYXhCYWNrb2ZmLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICB0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgPSBNYXRoLm1pbih0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgKiByZXRyeVBvbGljeS5iYWNrb2ZmTXVsdGlwbGllciwgbWF4QmFja29mZlNlYyk7XHJcbiAgICAgICAgcmV0dXJuIG5leHRCYWNrb2ZmTXM7XHJcbiAgICB9XHJcbiAgICBtYXliZVJldHJ5Q2FsbChwdXNoYmFjaywgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ1JFVFJZJykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmV0cnlQb2xpY3kgPSB0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLnJldHJ5UG9saWN5O1xyXG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzID49IE1hdGgubWluKHJldHJ5UG9saWN5Lm1heEF0dGVtcHRzLCA1KSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJldHJ5RGVsYXlNcztcclxuICAgICAgICBpZiAocHVzaGJhY2sgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0cnlEZWxheU1zID0gdGhpcy5nZXROZXh0UmV0cnlCYWNrb2ZmTXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHVzaGJhY2sgPCAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnVFJBTlNQQVJFTlRfT05MWSc7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0cnlEZWxheU1zID0gcHVzaGJhY2s7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyA9IHRoaXMuaW5pdGlhbFJldHJ5QmFja29mZlNlYztcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnUkVUUlknKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChfYiA9IChfYSA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5SZXRyeUNhbGwoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRzICs9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgcmV0cnlEZWxheU1zKTtcclxuICAgIH1cclxuICAgIGNvdW50QWN0aXZlQ2FsbHMoKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgdGhpcy51bmRlcmx5aW5nQ2FsbHMpIHtcclxuICAgICAgICAgICAgaWYgKChjYWxsID09PSBudWxsIHx8IGNhbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGwuc3RhdGUpID09PSAnQUNUSVZFJykge1xyXG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY291bnQ7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVQcm9jZXNzZWRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgsIHB1c2hiYWNrKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0NPTU1JVFRFRCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1RSQU5TUEFSRU5UX09OTFknOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0hFREdJTkcnOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0dXNDb2RlSW5MaXN0KChfYSA9IHRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeS5ub25GYXRhbFN0YXR1c0NvZGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSwgc3RhdHVzLmNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gdGhpcy5yZXRyeVRocm90dGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZENhbGxGYWlsZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsYXlNcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHVzaGJhY2sgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlNcyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHB1c2hiYWNrIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1RSQU5TUEFSRU5UX09OTFknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlNcyA9IHB1c2hiYWNrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYWZ0ZXIgdHJ5aW5nIHRvIHN0YXJ0IGEgY2FsbCB0aGVyZSBhcmUgbm8gYWN0aXZlIGNhbGxzLCB0aGlzIHdhcyB0aGUgbGFzdCBvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnRBY3RpdmVDYWxscygpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCBkZWxheU1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnUkVUUlknOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0dXNDb2RlSW5MaXN0KHRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcucmV0cnlQb2xpY3kucmV0cnlhYmxlU3RhdHVzQ29kZXMsIHN0YXR1cy5jb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRDYWxsRmFpbGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZVJldHJ5Q2FsbChwdXNoYmFjaywgcmV0cmllZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmV0cmllZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0UHVzaGJhY2sobWV0YWRhdGEpIHtcclxuICAgICAgICBjb25zdCBtZFZhbHVlID0gbWV0YWRhdGEuZ2V0KCdncnBjLXJldHJ5LXB1c2hiYWNrLW1zJyk7XHJcbiAgICAgICAgaWYgKG1kVmFsdWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobWRWYWx1ZVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYW5kbGVDaGlsZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbY2FsbEluZGV4XS5zdGF0ZSA9PT0gJ0NPTVBMRVRFRCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyYWNlKCdzdGF0ZT0nICtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSArXHJcbiAgICAgICAgICAgICcgaGFuZGxpbmcgc3RhdHVzIHdpdGggcHJvZ3Jlc3MgJyArXHJcbiAgICAgICAgICAgIHN0YXR1cy5wcm9ncmVzcyArXHJcbiAgICAgICAgICAgICcgZnJvbSBjaGlsZCBbJyArXHJcbiAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2NhbGxJbmRleF0uY2FsbC5nZXRDYWxsTnVtYmVyKCkgK1xyXG4gICAgICAgICAgICAnXSBpbiBzdGF0ZSAnICtcclxuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2FsbEluZGV4XS5zdGF0ZSk7XHJcbiAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2FsbEluZGV4XS5zdGF0ZSA9ICdDT01QTEVURUQnO1xyXG4gICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XHJcbiAgICAgICAgICAgIChfYSA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRDYWxsU3VjY2VlZGVkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnQ09NTUlUVEVEJykge1xyXG4gICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHB1c2hiYWNrID0gdGhpcy5nZXRQdXNoYmFjayhzdGF0dXMubWV0YWRhdGEpO1xyXG4gICAgICAgIHN3aXRjaCAoc3RhdHVzLnByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ05PVF9TVEFSVEVEJzpcclxuICAgICAgICAgICAgICAgIC8vIFJQQyBuZXZlciBsZWF2ZXMgdGhlIGNsaWVudCwgYWx3YXlzIHNhZmUgdG8gcmV0cnlcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnUkVGVVNFRCc6XHJcbiAgICAgICAgICAgICAgICAvLyBSUEMgcmVhY2hlcyB0aGUgc2VydmVyIGxpYnJhcnksIGJ1dCBub3QgdGhlIHNlcnZlciBhcHBsaWNhdGlvbiBsb2dpY1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwYXJlbnRSZXRyeVVzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVByb2Nlc3NlZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCwgcHVzaGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydE5ld0F0dGVtcHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdEUk9QJzpcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdQUk9DRVNTRUQnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQcm9jZXNzZWRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgsIHB1c2hiYWNrKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1heWJlU3RhcnRIZWRnaW5nQXR0ZW1wdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ0hFREdJTkcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3kpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoZWRnaW5nUG9saWN5ID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5O1xyXG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzID49IE1hdGgubWluKGhlZGdpbmdQb2xpY3kubWF4QXR0ZW1wdHMsIDUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hdHRlbXB0cyArPSAxO1xyXG4gICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XHJcbiAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ1RpbWVyKCk7XHJcbiAgICB9XHJcbiAgICBtYXliZVN0YXJ0SGVkZ2luZ1RpbWVyKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGlmICh0aGlzLmhlZGdpbmdUaW1lcikge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWRnaW5nVGltZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ0hFREdJTkcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3kpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoZWRnaW5nUG9saWN5ID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5O1xyXG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzID49IE1hdGgubWluKGhlZGdpbmdQb2xpY3kubWF4QXR0ZW1wdHMsIDUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGVkZ2luZ0RlbGF5U3RyaW5nID0gKF9hID0gaGVkZ2luZ1BvbGljeS5oZWRnaW5nRGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcwcyc7XHJcbiAgICAgICAgY29uc3QgaGVkZ2luZ0RlbGF5U2VjID0gTnVtYmVyKGhlZGdpbmdEZWxheVN0cmluZy5zdWJzdHJpbmcoMCwgaGVkZ2luZ0RlbGF5U3RyaW5nLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICB0aGlzLmhlZGdpbmdUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1heWJlU3RhcnRIZWRnaW5nQXR0ZW1wdCgpO1xyXG4gICAgICAgIH0sIGhlZGdpbmdEZWxheVNlYyAqIDEwMDApO1xyXG4gICAgICAgIChfYyA9IChfYiA9IHRoaXMuaGVkZ2luZ1RpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xyXG4gICAgfVxyXG4gICAgc3RhcnROZXdBdHRlbXB0KCkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGFubmVsLmNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsKHRoaXMuY2FsbENvbmZpZywgdGhpcy5tZXRob2ROYW1lLCB0aGlzLmhvc3QsIHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuZGVhZGxpbmUpO1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ0NyZWF0ZWQgY2hpbGQgY2FsbCBbJyArXHJcbiAgICAgICAgICAgIGNoaWxkLmdldENhbGxOdW1iZXIoKSArXHJcbiAgICAgICAgICAgICddIGZvciBhdHRlbXB0ICcgK1xyXG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRzKTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudW5kZXJseWluZ0NhbGxzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxscy5wdXNoKHtcclxuICAgICAgICAgICAgc3RhdGU6ICdBQ1RJVkUnLFxyXG4gICAgICAgICAgICBjYWxsOiBjaGlsZCxcclxuICAgICAgICAgICAgbmV4dE1lc3NhZ2VUb1NlbmQ6IDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNBdHRlbXB0cyA9IHRoaXMuYXR0ZW1wdHMgLSAxO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxNZXRhZGF0YSA9IHRoaXMuaW5pdGlhbE1ldGFkYXRhLmNsb25lKCk7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzQXR0ZW1wdHMgPiAwKSB7XHJcbiAgICAgICAgICAgIGluaXRpYWxNZXRhZGF0YS5zZXQoUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSwgYCR7cHJldmlvdXNBdHRlbXB0c31gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlY2VpdmVkTWV0YWRhdGEgPSBmYWxzZTtcclxuICAgICAgICBjaGlsZC5zdGFydChpbml0aWFsTWV0YWRhdGEsIHtcclxuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1ldGFkYXRhIGZyb20gY2hpbGQgWycgKyBjaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkTWV0YWRhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQXR0ZW1wdHMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuc2V0KFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVksIGAke3ByZXZpb3VzQXR0ZW1wdHN9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbaW5kZXhdLnN0YXRlID09PSAnQUNUSVZFJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiBtZXNzYWdlID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2UgZnJvbSBjaGlsZCBbJyArIGNoaWxkLmdldENhbGxOdW1iZXIoKSArICddJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW2luZGV4XS5zdGF0ZSA9PT0gJ0FDVElWRScpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogc3RhdHVzID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIHN0YXR1cyBmcm9tIGNoaWxkIFsnICsgY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcclxuICAgICAgICAgICAgICAgIGlmICghcmVjZWl2ZWRNZXRhZGF0YSAmJiBwcmV2aW91c0F0dGVtcHRzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5tZXRhZGF0YS5zZXQoUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSwgYCR7cHJldmlvdXNBdHRlbXB0c31gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRTdGF0dXMoc3RhdHVzLCBpbmRleCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zZW5kTmV4dENoaWxkTWVzc2FnZShpbmRleCk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZFN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgY2hpbGQuc3RhcnRSZWFkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnQgY2FsbGVkJyk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbE1ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgdGhpcy5hdHRlbXB0cyArPSAxO1xyXG4gICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XHJcbiAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ1RpbWVyKCk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkKGNoaWxkSW5kZXgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkQ2FsbCA9IHRoaXMudW5kZXJseWluZ0NhbGxzW2NoaWxkSW5kZXhdO1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJbmRleCA9IGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZDtcclxuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmdldEJ1ZmZlckVudHJ5KG1lc3NhZ2VJbmRleCkpLmNhbGxiYWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICAgICAgdGhpcy5jbGVhclNlbnRNZXNzYWdlcygpO1xyXG4gICAgICAgIGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCArPSAxO1xyXG4gICAgICAgIHRoaXMuc2VuZE5leHRDaGlsZE1lc3NhZ2UoY2hpbGRJbmRleCk7XHJcbiAgICB9XHJcbiAgICBzZW5kTmV4dENoaWxkTWVzc2FnZShjaGlsZEluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRDYWxsID0gdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2hpbGRJbmRleF07XHJcbiAgICAgICAgaWYgKGNoaWxkQ2FsbC5zdGF0ZSA9PT0gJ0NPTVBMRVRFRCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5nZXRCdWZmZXJFbnRyeShjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckVudHJ5ID0gdGhpcy5nZXRCdWZmZXJFbnRyeShjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGJ1ZmZlckVudHJ5LmVudHJ5VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnTUVTU0FHRSc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDYWxsLmNhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRXcml0ZUNvbXBsZXRlZChjaGlsZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9LCBidWZmZXJFbnRyeS5tZXNzYWdlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnSEFMRl9DTE9TRSc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDYWxsLmNhbGwuaGFsZkNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdGUkVFRCc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBiZSBwb3NzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ3dyaXRlKCkgY2FsbGVkIHdpdGggbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCB3cml0ZU9iaiA9IHtcclxuICAgICAgICAgICAgbWVzc2FnZSxcclxuICAgICAgICAgICAgZmxhZ3M6IGNvbnRleHQuZmxhZ3MsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBtZXNzYWdlSW5kZXggPSB0aGlzLmdldE5leHRCdWZmZXJJbmRleCgpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlckVudHJ5ID0ge1xyXG4gICAgICAgICAgICBlbnRyeVR5cGU6ICdNRVNTQUdFJyxcclxuICAgICAgICAgICAgbWVzc2FnZTogd3JpdGVPYmosXHJcbiAgICAgICAgICAgIGFsbG9jYXRlZDogdGhpcy5idWZmZXJUcmFja2VyLmFsbG9jYXRlKG1lc3NhZ2UubGVuZ3RoLCB0aGlzLmNhbGxOdW1iZXIpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKGJ1ZmZlckVudHJ5KTtcclxuICAgICAgICBpZiAoYnVmZmVyRW50cnkuYWxsb2NhdGVkKSB7XHJcbiAgICAgICAgICAgIChfYSA9IGNvbnRleHQuY2FsbGJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjYWxsSW5kZXgsIGNhbGxdIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGwuc3RhdGUgPT09ICdBQ1RJVkUnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5uZXh0TWVzc2FnZVRvU2VuZCA9PT0gbWVzc2FnZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkV3JpdGVDb21wbGV0ZWQoY2FsbEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9LCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsV2l0aE1vc3RNZXNzYWdlcygpO1xyXG4gICAgICAgICAgICAvLyBjb21taXRDYWxsV2l0aE1vc3RNZXNzYWdlcyBjYW4gZmFpbCBpZiB3ZSBhcmUgYmV0d2VlbiBwaW5nIGF0dGVtcHRzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbW1pdHRlZENhbGxJbmRleCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSB0aGlzLnVuZGVybHlpbmdDYWxsc1t0aGlzLmNvbW1pdHRlZENhbGxJbmRleF07XHJcbiAgICAgICAgICAgIGJ1ZmZlckVudHJ5LmNhbGxiYWNrID0gY29udGV4dC5jYWxsYmFjaztcclxuICAgICAgICAgICAgaWYgKGNhbGwuc3RhdGUgPT09ICdBQ1RJVkUnICYmIGNhbGwubmV4dE1lc3NhZ2VUb1NlbmQgPT09IG1lc3NhZ2VJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbC5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkV3JpdGVDb21wbGV0ZWQodGhpcy5jb21taXR0ZWRDYWxsSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0UmVhZCgpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCdzdGFydFJlYWQgY2FsbGVkJyk7XHJcbiAgICAgICAgdGhpcy5yZWFkU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgZm9yIChjb25zdCB1bmRlcmx5aW5nQ2FsbCBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xyXG4gICAgICAgICAgICBpZiAoKHVuZGVybHlpbmdDYWxsID09PSBudWxsIHx8IHVuZGVybHlpbmdDYWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bmRlcmx5aW5nQ2FsbC5zdGF0ZSkgPT09ICdBQ1RJVkUnKSB7XHJcbiAgICAgICAgICAgICAgICB1bmRlcmx5aW5nQ2FsbC5jYWxsLnN0YXJ0UmVhZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFsZkNsb3NlKCkge1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ2hhbGZDbG9zZSBjYWxsZWQnKTtcclxuICAgICAgICBjb25zdCBoYWxmQ2xvc2VJbmRleCA9IHRoaXMuZ2V0TmV4dEJ1ZmZlckluZGV4KCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHtcclxuICAgICAgICAgICAgZW50cnlUeXBlOiAnSEFMRl9DTE9TRScsXHJcbiAgICAgICAgICAgIGFsbG9jYXRlZDogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzKSB7XHJcbiAgICAgICAgICAgIGlmICgoY2FsbCA9PT0gbnVsbCB8fCBjYWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsLnN0YXRlKSA9PT0gJ0FDVElWRScgJiZcclxuICAgICAgICAgICAgICAgIGNhbGwubmV4dE1lc3NhZ2VUb1NlbmQgPT09IGhhbGZDbG9zZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsLm5leHRNZXNzYWdlVG9TZW5kICs9IDE7XHJcbiAgICAgICAgICAgICAgICBjYWxsLmNhbGwuaGFsZkNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRDcmVkZW50aWFscyhuZXdDcmVkZW50aWFscykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcclxuICAgIH1cclxuICAgIGdldE1ldGhvZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2ROYW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0SG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ob3N0O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmV0cnlpbmdDYWxsID0gUmV0cnlpbmdDYWxsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeWluZy1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server-call.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-call.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\r\nconst events_1 = __webpack_require__(/*! events */ \"events\");\r\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\r\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\r\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst error_1 = __webpack_require__(/*! ./error */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/error.js\");\r\nconst TRACER_NAME = 'server_call';\r\nfunction trace(text) {\r\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\r\n}\r\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\r\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\r\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\r\nconst GRPC_STATUS_HEADER = 'grpc-status';\r\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\r\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\r\nconst deadlineUnitsToMs = {\r\n    H: 3600000,\r\n    M: 60000,\r\n    S: 1000,\r\n    m: 1,\r\n    u: 0.001,\r\n    n: 0.000001,\r\n};\r\nconst defaultCompressionHeaders = {\r\n    // TODO(cjihrig): Remove these encoding headers from the default response\r\n    // once compression is integrated.\r\n    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\r\n    [GRPC_ENCODING_HEADER]: 'identity',\r\n};\r\nconst defaultResponseHeaders = {\r\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\r\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\r\n};\r\nconst defaultResponseOptions = {\r\n    waitForTrailers: true,\r\n};\r\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\r\n    constructor(call, metadata, request) {\r\n        super();\r\n        this.call = call;\r\n        this.metadata = metadata;\r\n        this.request = request;\r\n        this.cancelled = false;\r\n        this.call.setupSurfaceCall(this);\r\n    }\r\n    getPeer() {\r\n        return this.call.getPeer();\r\n    }\r\n    sendMetadata(responseMetadata) {\r\n        this.call.sendMetadata(responseMetadata);\r\n    }\r\n    getDeadline() {\r\n        return this.call.getDeadline();\r\n    }\r\n    getPath() {\r\n        return this.call.getPath();\r\n    }\r\n}\r\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\r\nclass ServerReadableStreamImpl extends stream_1.Readable {\r\n    constructor(call, metadata, deserialize, encoding) {\r\n        super({ objectMode: true });\r\n        this.call = call;\r\n        this.metadata = metadata;\r\n        this.deserialize = deserialize;\r\n        this.cancelled = false;\r\n        this.call.setupSurfaceCall(this);\r\n        this.call.setupReadable(this, encoding);\r\n    }\r\n    _read(size) {\r\n        if (!this.call.consumeUnpushedMessages(this)) {\r\n            return;\r\n        }\r\n        this.call.resume();\r\n    }\r\n    getPeer() {\r\n        return this.call.getPeer();\r\n    }\r\n    sendMetadata(responseMetadata) {\r\n        this.call.sendMetadata(responseMetadata);\r\n    }\r\n    getDeadline() {\r\n        return this.call.getDeadline();\r\n    }\r\n    getPath() {\r\n        return this.call.getPath();\r\n    }\r\n}\r\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\r\nclass ServerWritableStreamImpl extends stream_1.Writable {\r\n    constructor(call, metadata, serialize, request) {\r\n        super({ objectMode: true });\r\n        this.call = call;\r\n        this.metadata = metadata;\r\n        this.serialize = serialize;\r\n        this.request = request;\r\n        this.cancelled = false;\r\n        this.trailingMetadata = new metadata_1.Metadata();\r\n        this.call.setupSurfaceCall(this);\r\n        this.on('error', err => {\r\n            this.call.sendError(err);\r\n            this.end();\r\n        });\r\n    }\r\n    getPeer() {\r\n        return this.call.getPeer();\r\n    }\r\n    sendMetadata(responseMetadata) {\r\n        this.call.sendMetadata(responseMetadata);\r\n    }\r\n    getDeadline() {\r\n        return this.call.getDeadline();\r\n    }\r\n    getPath() {\r\n        return this.call.getPath();\r\n    }\r\n    _write(chunk, encoding, \r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    callback) {\r\n        try {\r\n            const response = this.call.serializeMessage(chunk);\r\n            if (!this.call.write(response)) {\r\n                this.call.once('drain', callback);\r\n                return;\r\n            }\r\n        }\r\n        catch (err) {\r\n            this.emit('error', {\r\n                details: (0, error_1.getErrorMessage)(err),\r\n                code: constants_1.Status.INTERNAL,\r\n            });\r\n        }\r\n        callback();\r\n    }\r\n    _final(callback) {\r\n        this.call.sendStatus({\r\n            code: constants_1.Status.OK,\r\n            details: 'OK',\r\n            metadata: this.trailingMetadata,\r\n        });\r\n        callback(null);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    end(metadata) {\r\n        if (metadata) {\r\n            this.trailingMetadata = metadata;\r\n        }\r\n        return super.end();\r\n    }\r\n}\r\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\r\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\r\n    constructor(call, metadata, serialize, deserialize, encoding) {\r\n        super({ objectMode: true });\r\n        this.call = call;\r\n        this.metadata = metadata;\r\n        this.serialize = serialize;\r\n        this.deserialize = deserialize;\r\n        this.cancelled = false;\r\n        this.trailingMetadata = new metadata_1.Metadata();\r\n        this.call.setupSurfaceCall(this);\r\n        this.call.setupReadable(this, encoding);\r\n        this.on('error', err => {\r\n            this.call.sendError(err);\r\n            this.end();\r\n        });\r\n    }\r\n    getPeer() {\r\n        return this.call.getPeer();\r\n    }\r\n    sendMetadata(responseMetadata) {\r\n        this.call.sendMetadata(responseMetadata);\r\n    }\r\n    getDeadline() {\r\n        return this.call.getDeadline();\r\n    }\r\n    getPath() {\r\n        return this.call.getPath();\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    end(metadata) {\r\n        if (metadata) {\r\n            this.trailingMetadata = metadata;\r\n        }\r\n        return super.end();\r\n    }\r\n}\r\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\r\nServerDuplexStreamImpl.prototype._read =\r\n    ServerReadableStreamImpl.prototype._read;\r\nServerDuplexStreamImpl.prototype._write =\r\n    ServerWritableStreamImpl.prototype._write;\r\nServerDuplexStreamImpl.prototype._final =\r\n    ServerWritableStreamImpl.prototype._final;\r\n// Internal class that wraps the HTTP2 request.\r\nclass Http2ServerCallStream extends events_1.EventEmitter {\r\n    constructor(stream, handler, options) {\r\n        super();\r\n        this.stream = stream;\r\n        this.handler = handler;\r\n        this.cancelled = false;\r\n        this.deadlineTimer = null;\r\n        this.statusSent = false;\r\n        this.deadline = Infinity;\r\n        this.wantTrailers = false;\r\n        this.metadataSent = false;\r\n        this.canPush = false;\r\n        this.isPushPending = false;\r\n        this.bufferedMessages = [];\r\n        this.messagesToPush = [];\r\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\r\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\r\n        this.stream.once('error', (err) => {\r\n            /* We need an error handler to avoid uncaught error event exceptions, but\r\n             * there is nothing we can reasonably do here. Any error event should\r\n             * have a corresponding close event, which handles emitting the cancelled\r\n             * event. And the stream is now in a bad state, so we can't reasonably\r\n             * expect to be able to send an error over it. */\r\n        });\r\n        this.stream.once('close', () => {\r\n            var _a;\r\n            trace('Request to method ' +\r\n                ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\r\n                ' stream closed with rstCode ' +\r\n                this.stream.rstCode);\r\n            if (!this.statusSent) {\r\n                this.cancelled = true;\r\n                this.emit('cancelled', 'cancelled');\r\n                this.emit('streamEnd', false);\r\n                this.sendStatus({\r\n                    code: constants_1.Status.CANCELLED,\r\n                    details: 'Cancelled by client',\r\n                    metadata: null,\r\n                });\r\n                if (this.deadlineTimer)\r\n                    clearTimeout(this.deadlineTimer);\r\n            }\r\n        });\r\n        this.stream.on('drain', () => {\r\n            this.emit('drain');\r\n        });\r\n        if ('grpc.max_send_message_length' in options) {\r\n            this.maxSendMessageSize = options['grpc.max_send_message_length'];\r\n        }\r\n        if ('grpc.max_receive_message_length' in options) {\r\n            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\r\n        }\r\n    }\r\n    checkCancelled() {\r\n        /* In some cases the stream can become destroyed before the close event\r\n         * fires. That creates a race condition that this check works around */\r\n        if (this.stream.destroyed || this.stream.closed) {\r\n            this.cancelled = true;\r\n        }\r\n        return this.cancelled;\r\n    }\r\n    getDecompressedMessage(message, encoding) {\r\n        const messageContents = message.subarray(5);\r\n        if (encoding === 'identity') {\r\n            return messageContents;\r\n        }\r\n        else if (encoding === 'deflate' || encoding === 'gzip') {\r\n            let decompresser;\r\n            if (encoding === 'deflate') {\r\n                decompresser = zlib.createInflate();\r\n            }\r\n            else {\r\n                decompresser = zlib.createGunzip();\r\n            }\r\n            return new Promise((resolve, reject) => {\r\n                let totalLength = 0;\r\n                const messageParts = [];\r\n                decompresser.on('data', (chunk) => {\r\n                    messageParts.push(chunk);\r\n                    totalLength += chunk.byteLength;\r\n                    if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {\r\n                        decompresser.destroy();\r\n                        reject({\r\n                            code: constants_1.Status.RESOURCE_EXHAUSTED,\r\n                            details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`\r\n                        });\r\n                    }\r\n                });\r\n                decompresser.on('end', () => {\r\n                    resolve(Buffer.concat(messageParts));\r\n                });\r\n                decompresser.write(messageContents);\r\n                decompresser.end();\r\n            });\r\n        }\r\n        else {\r\n            return Promise.reject({\r\n                code: constants_1.Status.UNIMPLEMENTED,\r\n                details: `Received message compressed with unsupported encoding \"${encoding}\"`,\r\n            });\r\n        }\r\n    }\r\n    sendMetadata(customMetadata) {\r\n        if (this.checkCancelled()) {\r\n            return;\r\n        }\r\n        if (this.metadataSent) {\r\n            return;\r\n        }\r\n        this.metadataSent = true;\r\n        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\r\n        // TODO(cjihrig): Include compression headers.\r\n        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);\r\n        this.stream.respond(headers, defaultResponseOptions);\r\n    }\r\n    receiveMetadata(headers) {\r\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\r\n        if (logging.isTracerEnabled(TRACER_NAME)) {\r\n            trace('Request to ' +\r\n                this.handler.path +\r\n                ' received headers ' +\r\n                JSON.stringify(metadata.toJSON()));\r\n        }\r\n        // TODO(cjihrig): Receive compression metadata.\r\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\r\n        if (timeoutHeader.length > 0) {\r\n            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\r\n            if (match === null) {\r\n                const err = new Error('Invalid deadline');\r\n                err.code = constants_1.Status.OUT_OF_RANGE;\r\n                this.sendError(err);\r\n                return metadata;\r\n            }\r\n            const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\r\n            const now = new Date();\r\n            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\r\n            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\r\n            metadata.remove(GRPC_TIMEOUT_HEADER);\r\n        }\r\n        // Remove several headers that should not be propagated to the application\r\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\r\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\r\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\r\n        metadata.remove('grpc-accept-encoding');\r\n        return metadata;\r\n    }\r\n    receiveUnaryMessage(encoding) {\r\n        return new Promise((resolve, reject) => {\r\n            const { stream } = this;\r\n            let receivedLength = 0;\r\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n            const call = this;\r\n            const body = [];\r\n            const limit = this.maxReceiveMessageSize;\r\n            this.stream.on('data', onData);\r\n            this.stream.on('end', onEnd);\r\n            this.stream.on('error', onEnd);\r\n            function onData(chunk) {\r\n                receivedLength += chunk.byteLength;\r\n                if (limit !== -1 && receivedLength > limit) {\r\n                    stream.removeListener('data', onData);\r\n                    stream.removeListener('end', onEnd);\r\n                    stream.removeListener('error', onEnd);\r\n                    reject({\r\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\r\n                        details: `Received message larger than max (${receivedLength} vs. ${limit})`,\r\n                    });\r\n                    return;\r\n                }\r\n                body.push(chunk);\r\n            }\r\n            function onEnd(err) {\r\n                stream.removeListener('data', onData);\r\n                stream.removeListener('end', onEnd);\r\n                stream.removeListener('error', onEnd);\r\n                if (err !== undefined) {\r\n                    reject({ code: constants_1.Status.INTERNAL, details: err.message });\r\n                    return;\r\n                }\r\n                if (receivedLength === 0) {\r\n                    reject({\r\n                        code: constants_1.Status.INTERNAL,\r\n                        details: 'received empty unary message',\r\n                    });\r\n                    return;\r\n                }\r\n                call.emit('receiveMessage');\r\n                const requestBytes = Buffer.concat(body, receivedLength);\r\n                const compressed = requestBytes.readUInt8(0) === 1;\r\n                const compressedMessageEncoding = compressed ? encoding : 'identity';\r\n                const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\r\n                if (Buffer.isBuffer(decompressedMessage)) {\r\n                    resolve(call.deserializeMessageWithInternalError(decompressedMessage));\r\n                    return;\r\n                }\r\n                decompressedMessage.then(decompressed => resolve(call.deserializeMessageWithInternalError(decompressed)), (err) => reject(err.code\r\n                    ? err\r\n                    : {\r\n                        code: constants_1.Status.INTERNAL,\r\n                        details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`,\r\n                    }));\r\n            }\r\n        });\r\n    }\r\n    async deserializeMessageWithInternalError(buffer) {\r\n        try {\r\n            return this.deserializeMessage(buffer);\r\n        }\r\n        catch (err) {\r\n            throw {\r\n                details: (0, error_1.getErrorMessage)(err),\r\n                code: constants_1.Status.INTERNAL,\r\n            };\r\n        }\r\n    }\r\n    serializeMessage(value) {\r\n        const messageBuffer = this.handler.serialize(value);\r\n        // TODO(cjihrig): Call compression aware serializeMessage().\r\n        const byteLength = messageBuffer.byteLength;\r\n        const output = Buffer.allocUnsafe(byteLength + 5);\r\n        output.writeUInt8(0, 0);\r\n        output.writeUInt32BE(byteLength, 1);\r\n        messageBuffer.copy(output, 5);\r\n        return output;\r\n    }\r\n    deserializeMessage(bytes) {\r\n        return this.handler.deserialize(bytes);\r\n    }\r\n    async sendUnaryMessage(err, value, metadata, flags) {\r\n        if (this.checkCancelled()) {\r\n            return;\r\n        }\r\n        if (metadata === undefined) {\r\n            metadata = null;\r\n        }\r\n        if (err) {\r\n            if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\r\n                err.metadata = metadata;\r\n            }\r\n            this.sendError(err);\r\n            return;\r\n        }\r\n        try {\r\n            const response = this.serializeMessage(value);\r\n            this.write(response);\r\n            this.sendStatus({ code: constants_1.Status.OK, details: 'OK', metadata });\r\n        }\r\n        catch (err) {\r\n            this.sendError({\r\n                details: (0, error_1.getErrorMessage)(err),\r\n                code: constants_1.Status.INTERNAL,\r\n            });\r\n        }\r\n    }\r\n    sendStatus(statusObj) {\r\n        var _a, _b;\r\n        this.emit('callEnd', statusObj.code);\r\n        this.emit('streamEnd', statusObj.code === constants_1.Status.OK);\r\n        if (this.checkCancelled()) {\r\n            return;\r\n        }\r\n        trace('Request to method ' +\r\n            ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\r\n            ' ended with status code: ' +\r\n            constants_1.Status[statusObj.code] +\r\n            ' details: ' +\r\n            statusObj.details);\r\n        if (this.deadlineTimer)\r\n            clearTimeout(this.deadlineTimer);\r\n        if (this.stream.headersSent) {\r\n            if (!this.wantTrailers) {\r\n                this.wantTrailers = true;\r\n                this.stream.once('wantTrailers', () => {\r\n                    var _a;\r\n                    const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: statusObj.code, [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details) }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\r\n                    this.stream.sendTrailers(trailersToSend);\r\n                    this.statusSent = true;\r\n                });\r\n                this.stream.end();\r\n            }\r\n        }\r\n        else {\r\n            // Trailers-only response\r\n            const trailersToSend = Object.assign(Object.assign({ [GRPC_STATUS_HEADER]: statusObj.code, [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details) }, defaultResponseHeaders), (_b = statusObj.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());\r\n            this.stream.respond(trailersToSend, { endStream: true });\r\n            this.statusSent = true;\r\n        }\r\n    }\r\n    sendError(error) {\r\n        const status = {\r\n            code: constants_1.Status.UNKNOWN,\r\n            details: 'message' in error ? error.message : 'Unknown Error',\r\n            metadata: 'metadata' in error && error.metadata !== undefined\r\n                ? error.metadata\r\n                : null,\r\n        };\r\n        if ('code' in error &&\r\n            typeof error.code === 'number' &&\r\n            Number.isInteger(error.code)) {\r\n            status.code = error.code;\r\n            if ('details' in error && typeof error.details === 'string') {\r\n                status.details = error.details;\r\n            }\r\n        }\r\n        this.sendStatus(status);\r\n    }\r\n    write(chunk) {\r\n        if (this.checkCancelled()) {\r\n            return;\r\n        }\r\n        if (this.maxSendMessageSize !== -1 &&\r\n            chunk.length > this.maxSendMessageSize) {\r\n            this.sendError({\r\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\r\n                details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,\r\n            });\r\n            return;\r\n        }\r\n        this.sendMetadata();\r\n        this.emit('sendMessage');\r\n        return this.stream.write(chunk);\r\n    }\r\n    resume() {\r\n        this.stream.resume();\r\n    }\r\n    setupSurfaceCall(call) {\r\n        this.once('cancelled', reason => {\r\n            call.cancelled = true;\r\n            call.emit('cancelled', reason);\r\n        });\r\n        this.once('callEnd', status => call.emit('callEnd', status));\r\n    }\r\n    setupReadable(readable, encoding) {\r\n        const decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);\r\n        let readsDone = false;\r\n        let pendingMessageProcessing = false;\r\n        let pushedEnd = false;\r\n        const maybePushEnd = async () => {\r\n            if (!pushedEnd && readsDone && !pendingMessageProcessing) {\r\n                pushedEnd = true;\r\n                await this.pushOrBufferMessage(readable, null);\r\n            }\r\n        };\r\n        this.stream.on('data', async (data) => {\r\n            let messages;\r\n            try {\r\n                messages = decoder.write(data);\r\n            }\r\n            catch (e) {\r\n                this.sendError({\r\n                    code: constants_1.Status.RESOURCE_EXHAUSTED,\r\n                    details: e.message\r\n                });\r\n                return;\r\n            }\r\n            pendingMessageProcessing = true;\r\n            this.stream.pause();\r\n            for (const message of messages) {\r\n                this.emit('receiveMessage');\r\n                const compressed = message.readUInt8(0) === 1;\r\n                const compressedMessageEncoding = compressed ? encoding : 'identity';\r\n                let decompressedMessage;\r\n                try {\r\n                    decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\r\n                }\r\n                catch (e) {\r\n                    this.sendError(e);\r\n                    return;\r\n                }\r\n                // Encountered an error with decompression; it'll already have been propogated back\r\n                // Just return early\r\n                if (!decompressedMessage)\r\n                    return;\r\n                await this.pushOrBufferMessage(readable, decompressedMessage);\r\n            }\r\n            pendingMessageProcessing = false;\r\n            this.stream.resume();\r\n            await maybePushEnd();\r\n        });\r\n        this.stream.once('end', async () => {\r\n            readsDone = true;\r\n            await maybePushEnd();\r\n        });\r\n    }\r\n    consumeUnpushedMessages(readable) {\r\n        this.canPush = true;\r\n        while (this.messagesToPush.length > 0) {\r\n            const nextMessage = this.messagesToPush.shift();\r\n            const canPush = readable.push(nextMessage);\r\n            if (nextMessage === null || canPush === false) {\r\n                this.canPush = false;\r\n                break;\r\n            }\r\n        }\r\n        return this.canPush;\r\n    }\r\n    async pushOrBufferMessage(readable, messageBytes) {\r\n        if (this.isPushPending) {\r\n            this.bufferedMessages.push(messageBytes);\r\n        }\r\n        else {\r\n            await this.pushMessage(readable, messageBytes);\r\n        }\r\n    }\r\n    async pushMessage(readable, messageBytes) {\r\n        if (messageBytes === null) {\r\n            trace('Received end of stream');\r\n            if (this.canPush) {\r\n                readable.push(null);\r\n            }\r\n            else {\r\n                this.messagesToPush.push(null);\r\n            }\r\n            return;\r\n        }\r\n        trace('Received message of length ' + messageBytes.length);\r\n        this.isPushPending = true;\r\n        try {\r\n            const deserialized = await this.deserializeMessage(messageBytes);\r\n            if (this.canPush) {\r\n                if (!readable.push(deserialized)) {\r\n                    this.canPush = false;\r\n                    this.stream.pause();\r\n                }\r\n            }\r\n            else {\r\n                this.messagesToPush.push(deserialized);\r\n            }\r\n        }\r\n        catch (error) {\r\n            // Ignore any remaining messages when errors occur.\r\n            this.bufferedMessages.length = 0;\r\n            let code = (0, error_1.getErrorCode)(error);\r\n            if (code === null || code < constants_1.Status.OK || code > constants_1.Status.UNAUTHENTICATED) {\r\n                code = constants_1.Status.INTERNAL;\r\n            }\r\n            readable.emit('error', {\r\n                details: (0, error_1.getErrorMessage)(error),\r\n                code: code,\r\n            });\r\n        }\r\n        this.isPushPending = false;\r\n        if (this.bufferedMessages.length > 0) {\r\n            await this.pushMessage(readable, this.bufferedMessages.shift());\r\n        }\r\n    }\r\n    getPeer() {\r\n        var _a;\r\n        const socket = (_a = this.stream.session) === null || _a === void 0 ? void 0 : _a.socket;\r\n        if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {\r\n            if (socket.remotePort) {\r\n                return `${socket.remoteAddress}:${socket.remotePort}`;\r\n            }\r\n            else {\r\n                return socket.remoteAddress;\r\n            }\r\n        }\r\n        else {\r\n            return 'unknown';\r\n        }\r\n    }\r\n    getDeadline() {\r\n        return this.deadline;\r\n    }\r\n    getPath() {\r\n        return this.handler.path;\r\n    }\r\n}\r\nexports.Http2ServerCallStream = Http2ServerCallStream;\r\nfunction handleExpiredDeadline(call) {\r\n    const err = new Error('Deadline exceeded');\r\n    err.code = constants_1.Status.DEADLINE_EXCEEDED;\r\n    call.sendError(err);\r\n    call.cancelled = true;\r\n    call.emit('cancelled', 'deadline');\r\n}\r\n//# sourceMappingURL=server-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyw4QkFBOEIsR0FBRyxnQ0FBZ0MsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkI7QUFDbEssaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLElBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLDJCQUEyQjtBQUM1SCx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFNBQVM7QUFDNUYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZ0JBQWdCLE1BQU0sTUFBTTtBQUNsRyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlEQUF5RDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFNBQVMsUUFBUSxVQUFVO0FBQ2hHLHFCQUFxQjtBQUNyQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQXNEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMkZBQTJGO0FBQ3RKO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwyRkFBMkY7QUFDNUosa0RBQWtELGlCQUFpQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWMsTUFBTSx3QkFBd0I7QUFDdEcsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUIsR0FBRyxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanM/ZWEyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5IdHRwMlNlcnZlckNhbGxTdHJlYW0gPSBleHBvcnRzLlNlcnZlckR1cGxleFN0cmVhbUltcGwgPSBleHBvcnRzLlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5TZXJ2ZXJVbmFyeUNhbGxJbXBsID0gdm9pZCAwO1xyXG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XHJcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xyXG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XHJcbmNvbnN0IHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcclxuY29uc3Qgc3RyZWFtX2RlY29kZXJfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbS1kZWNvZGVyXCIpO1xyXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdzZXJ2ZXJfY2FsbCc7XHJcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcclxuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XHJcbn1cclxuY29uc3QgR1JQQ19BQ0NFUFRfRU5DT0RJTkdfSEVBREVSID0gJ2dycGMtYWNjZXB0LWVuY29kaW5nJztcclxuY29uc3QgR1JQQ19FTkNPRElOR19IRUFERVIgPSAnZ3JwYy1lbmNvZGluZyc7XHJcbmNvbnN0IEdSUENfTUVTU0FHRV9IRUFERVIgPSAnZ3JwYy1tZXNzYWdlJztcclxuY29uc3QgR1JQQ19TVEFUVVNfSEVBREVSID0gJ2dycGMtc3RhdHVzJztcclxuY29uc3QgR1JQQ19USU1FT1VUX0hFQURFUiA9ICdncnBjLXRpbWVvdXQnO1xyXG5jb25zdCBERUFETElORV9SRUdFWCA9IC8oXFxkezEsOH0pXFxzKihbSE1TbXVuXSkvO1xyXG5jb25zdCBkZWFkbGluZVVuaXRzVG9NcyA9IHtcclxuICAgIEg6IDM2MDAwMDAsXHJcbiAgICBNOiA2MDAwMCxcclxuICAgIFM6IDEwMDAsXHJcbiAgICBtOiAxLFxyXG4gICAgdTogMC4wMDEsXHJcbiAgICBuOiAwLjAwMDAwMSxcclxufTtcclxuY29uc3QgZGVmYXVsdENvbXByZXNzaW9uSGVhZGVycyA9IHtcclxuICAgIC8vIFRPRE8oY2ppaHJpZyk6IFJlbW92ZSB0aGVzZSBlbmNvZGluZyBoZWFkZXJzIGZyb20gdGhlIGRlZmF1bHQgcmVzcG9uc2VcclxuICAgIC8vIG9uY2UgY29tcHJlc3Npb24gaXMgaW50ZWdyYXRlZC5cclxuICAgIFtHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVJdOiAnaWRlbnRpdHksZGVmbGF0ZSxnemlwJyxcclxuICAgIFtHUlBDX0VOQ09ESU5HX0hFQURFUl06ICdpZGVudGl0eScsXHJcbn07XHJcbmNvbnN0IGRlZmF1bHRSZXNwb25zZUhlYWRlcnMgPSB7XHJcbiAgICBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9TVEFUVVNdOiBodHRwMi5jb25zdGFudHMuSFRUUF9TVEFUVVNfT0ssXHJcbiAgICBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdOiAnYXBwbGljYXRpb24vZ3JwYytwcm90bycsXHJcbn07XHJcbmNvbnN0IGRlZmF1bHRSZXNwb25zZU9wdGlvbnMgPSB7XHJcbiAgICB3YWl0Rm9yVHJhaWxlcnM6IHRydWUsXHJcbn07XHJcbmNsYXNzIFNlcnZlclVuYXJ5Q2FsbEltcGwgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHJlcXVlc3QpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcclxuICAgIH1cclxuICAgIGdldFBlZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XHJcbiAgICB9XHJcbiAgICBzZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XHJcbiAgICB9XHJcbiAgICBnZXREZWFkbGluZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XHJcbiAgICB9XHJcbiAgICBnZXRQYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU2VydmVyVW5hcnlDYWxsSW1wbCA9IFNlcnZlclVuYXJ5Q2FsbEltcGw7XHJcbmNsYXNzIFNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLlJlYWRhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGFkYXRhLCBkZXNlcmlhbGl6ZSwgZW5jb2RpbmcpIHtcclxuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwU3VyZmFjZUNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwUmVhZGFibGUodGhpcywgZW5jb2RpbmcpO1xyXG4gICAgfVxyXG4gICAgX3JlYWQoc2l6ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5jYWxsLmNvbnN1bWVVbnB1c2hlZE1lc3NhZ2VzKHRoaXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsLnJlc3VtZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0UGVlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcclxuICAgIH1cclxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIGdldERlYWRsaW5lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcclxuICAgIH1cclxuICAgIGdldFBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQYXRoKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgPSBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGw7XHJcbmNsYXNzIFNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLldyaXRhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGFkYXRhLCBzZXJpYWxpemUsIHJlcXVlc3QpIHtcclxuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcclxuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XHJcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwU3VyZmFjZUNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCBlcnIgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGwuc2VuZEVycm9yKGVycik7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xyXG4gICAgfVxyXG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLmNhbGwuc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpO1xyXG4gICAgfVxyXG4gICAgZ2V0RGVhZGxpbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXREZWFkbGluZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0UGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBhdGgoKTtcclxuICAgIH1cclxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLmNhbGwuc2VyaWFsaXplTWVzc2FnZShjaHVuayk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxsLndyaXRlKHJlc3BvbnNlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsLm9uY2UoJ2RyYWluJywgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6ICgwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZXJyKSxcclxuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgICBfZmluYWwoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLmNhbGwuc2VuZFN0YXR1cyh7XHJcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcclxuICAgICAgICAgICAgZGV0YWlsczogJ09LJyxcclxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMudHJhaWxpbmdNZXRhZGF0YSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBlbmQobWV0YWRhdGEpIHtcclxuICAgICAgICBpZiAobWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdXBlci5lbmQoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCA9IFNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbDtcclxuY2xhc3MgU2VydmVyRHVwbGV4U3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBtZXRhZGF0YSwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgZW5jb2RpbmcpIHtcclxuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XHJcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcclxuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmNhbGwuc2V0dXBSZWFkYWJsZSh0aGlzLCBlbmNvZGluZyk7XHJcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCBlcnIgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGwuc2VuZEVycm9yKGVycik7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xyXG4gICAgfVxyXG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLmNhbGwuc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpO1xyXG4gICAgfVxyXG4gICAgZ2V0RGVhZGxpbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXREZWFkbGluZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0UGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBhdGgoKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBlbmQobWV0YWRhdGEpIHtcclxuICAgICAgICBpZiAobWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdXBlci5lbmQoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlNlcnZlckR1cGxleFN0cmVhbUltcGwgPSBTZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsO1xyXG5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsLnByb3RvdHlwZS5fcmVhZCA9XHJcbiAgICBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwucHJvdG90eXBlLl9yZWFkO1xyXG5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsLnByb3RvdHlwZS5fd3JpdGUgPVxyXG4gICAgU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsLnByb3RvdHlwZS5fd3JpdGU7XHJcblNlcnZlckR1cGxleFN0cmVhbUltcGwucHJvdG90eXBlLl9maW5hbCA9XHJcbiAgICBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwucHJvdG90eXBlLl9maW5hbDtcclxuLy8gSW50ZXJuYWwgY2xhc3MgdGhhdCB3cmFwcyB0aGUgSFRUUDIgcmVxdWVzdC5cclxuY2xhc3MgSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHN0cmVhbSwgaGFuZGxlciwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGF0dXNTZW50ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IEluZmluaXR5O1xyXG4gICAgICAgIHRoaXMud2FudFRyYWlsZXJzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YVNlbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VzVG9QdXNoID0gW107XHJcbiAgICAgICAgdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPSBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIO1xyXG4gICAgICAgIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplID0gY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSDtcclxuICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCdlcnJvcicsIChlcnIpID0+IHtcclxuICAgICAgICAgICAgLyogV2UgbmVlZCBhbiBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHVuY2F1Z2h0IGVycm9yIGV2ZW50IGV4Y2VwdGlvbnMsIGJ1dFxyXG4gICAgICAgICAgICAgKiB0aGVyZSBpcyBub3RoaW5nIHdlIGNhbiByZWFzb25hYmx5IGRvIGhlcmUuIEFueSBlcnJvciBldmVudCBzaG91bGRcclxuICAgICAgICAgICAgICogaGF2ZSBhIGNvcnJlc3BvbmRpbmcgY2xvc2UgZXZlbnQsIHdoaWNoIGhhbmRsZXMgZW1pdHRpbmcgdGhlIGNhbmNlbGxlZFxyXG4gICAgICAgICAgICAgKiBldmVudC4gQW5kIHRoZSBzdHJlYW0gaXMgbm93IGluIGEgYmFkIHN0YXRlLCBzbyB3ZSBjYW4ndCByZWFzb25hYmx5XHJcbiAgICAgICAgICAgICAqIGV4cGVjdCB0byBiZSBhYmxlIHRvIHNlbmQgYW4gZXJyb3Igb3ZlciBpdC4gKi9cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byBtZXRob2QgJyArXHJcbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy5oYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCkgK1xyXG4gICAgICAgICAgICAgICAgJyBzdHJlYW0gY2xvc2VkIHdpdGggcnN0Q29kZSAnICtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJzdENvZGUpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdHVzU2VudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjYW5jZWxsZWQnLCAnY2FuY2VsbGVkJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0cmVhbUVuZCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCxcclxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnQ2FuY2VsbGVkIGJ5IGNsaWVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYWRsaW5lVGltZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnN0cmVhbS5vbignZHJhaW4nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPSBvcHRpb25zWydncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSA9IG9wdGlvbnNbJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjaGVja0NhbmNlbGxlZCgpIHtcclxuICAgICAgICAvKiBJbiBzb21lIGNhc2VzIHRoZSBzdHJlYW0gY2FuIGJlY29tZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjbG9zZSBldmVudFxyXG4gICAgICAgICAqIGZpcmVzLiBUaGF0IGNyZWF0ZXMgYSByYWNlIGNvbmRpdGlvbiB0aGF0IHRoaXMgY2hlY2sgd29ya3MgYXJvdW5kICovXHJcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmRlc3Ryb3llZCB8fCB0aGlzLnN0cmVhbS5jbG9zZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jYW5jZWxsZWQ7XHJcbiAgICB9XHJcbiAgICBnZXREZWNvbXByZXNzZWRNZXNzYWdlKG1lc3NhZ2UsIGVuY29kaW5nKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZUNvbnRlbnRzID0gbWVzc2FnZS5zdWJhcnJheSg1KTtcclxuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdpZGVudGl0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VDb250ZW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZW5jb2RpbmcgPT09ICdkZWZsYXRlJyB8fCBlbmNvZGluZyA9PT0gJ2d6aXAnKSB7XHJcbiAgICAgICAgICAgIGxldCBkZWNvbXByZXNzZXI7XHJcbiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2RlZmxhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIgPSB6bGliLmNyZWF0ZUluZmxhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlY29tcHJlc3NlciA9IHpsaWIuY3JlYXRlR3VuemlwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB0b3RhbExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci5vbignZGF0YScsIChjaHVuaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJ0cy5wdXNoKGNodW5rKTtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSAhPT0gLTEgJiYgdG90YWxMZW5ndGggPiB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIHRoYXQgZGVjb21wcmVzc2VzIHRvIGEgc2l6ZSBsYXJnZXIgdGhhbiAke3RoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplfWBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2VuZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKEJ1ZmZlci5jb25jYXQobWVzc2FnZVBhcnRzKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci53cml0ZShtZXNzYWdlQ29udGVudHMpO1xyXG4gICAgICAgICAgICAgICAgZGVjb21wcmVzc2VyLmVuZCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcclxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIGNvbXByZXNzZWQgd2l0aCB1bnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7ZW5jb2Rpbmd9XCJgLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kTWV0YWRhdGEoY3VzdG9tTWV0YWRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGFTZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YVNlbnQgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IGN1c3RvbSA9IGN1c3RvbU1ldGFkYXRhID8gY3VzdG9tTWV0YWRhdGEudG9IdHRwMkhlYWRlcnMoKSA6IG51bGw7XHJcbiAgICAgICAgLy8gVE9ETyhjamlocmlnKTogSW5jbHVkZSBjb21wcmVzc2lvbiBoZWFkZXJzLlxyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFJlc3BvbnNlSGVhZGVycyksIGRlZmF1bHRDb21wcmVzc2lvbkhlYWRlcnMpLCBjdXN0b20pO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtLnJlc3BvbmQoaGVhZGVycywgZGVmYXVsdFJlc3BvbnNlT3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICByZWNlaXZlTWV0YWRhdGEoaGVhZGVycykge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFfMS5NZXRhZGF0YS5mcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpO1xyXG4gICAgICAgIGlmIChsb2dnaW5nLmlzVHJhY2VyRW5hYmxlZChUUkFDRVJfTkFNRSkpIHtcclxuICAgICAgICAgICAgdHJhY2UoJ1JlcXVlc3QgdG8gJyArXHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXIucGF0aCArXHJcbiAgICAgICAgICAgICAgICAnIHJlY2VpdmVkIGhlYWRlcnMgJyArXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShtZXRhZGF0YS50b0pTT04oKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPKGNqaWhyaWcpOiBSZWNlaXZlIGNvbXByZXNzaW9uIG1ldGFkYXRhLlxyXG4gICAgICAgIGNvbnN0IHRpbWVvdXRIZWFkZXIgPSBtZXRhZGF0YS5nZXQoR1JQQ19USU1FT1VUX0hFQURFUik7XHJcbiAgICAgICAgaWYgKHRpbWVvdXRIZWFkZXIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHRpbWVvdXRIZWFkZXJbMF0udG9TdHJpbmcoKS5tYXRjaChERUFETElORV9SRUdFWCk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJbnZhbGlkIGRlYWRsaW5lJyk7XHJcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5PVVRfT0ZfUkFOR0U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRFcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoK21hdGNoWzFdICogZGVhZGxpbmVVbml0c1RvTXNbbWF0Y2hbMl1dKSB8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVhZGxpbmUgPSBub3cuc2V0TWlsbGlzZWNvbmRzKG5vdy5nZXRNaWxsaXNlY29uZHMoKSArIHRpbWVvdXQpO1xyXG4gICAgICAgICAgICB0aGlzLmRlYWRsaW5lVGltZXIgPSBzZXRUaW1lb3V0KGhhbmRsZUV4cGlyZWREZWFkbGluZSwgdGltZW91dCwgdGhpcyk7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhLnJlbW92ZShHUlBDX1RJTUVPVVRfSEVBREVSKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIHNldmVyYWwgaGVhZGVycyB0aGF0IHNob3VsZCBub3QgYmUgcHJvcGFnYXRlZCB0byB0aGUgYXBwbGljYXRpb25cclxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9BQ0NFUFRfRU5DT0RJTkcpO1xyXG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1RFKTtcclxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUpO1xyXG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKTtcclxuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XHJcbiAgICB9XHJcbiAgICByZWNlaXZlVW5hcnlNZXNzYWdlKGVuY29kaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBzdHJlYW0gfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCByZWNlaXZlZExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xyXG4gICAgICAgICAgICBjb25zdCBjYWxsID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgYm9keSA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5vbignZGF0YScsIG9uRGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uKCdlbmQnLCBvbkVuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uKCdlcnJvcicsIG9uRW5kKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gb25EYXRhKGNodW5rKSB7XHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZExlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSAtMSAmJiByZWNlaXZlZExlbmd0aCA+IGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHtyZWNlaXZlZExlbmd0aH0gdnMuICR7bGltaXR9KWAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKGNodW5rKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBvbkVuZChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKTtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVuZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoeyBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsIGRldGFpbHM6IGVyci5tZXNzYWdlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZExlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ3JlY2VpdmVkIGVtcHR5IHVuYXJ5IG1lc3NhZ2UnLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGwuZW1pdCgncmVjZWl2ZU1lc3NhZ2UnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RCeXRlcyA9IEJ1ZmZlci5jb25jYXQoYm9keSwgcmVjZWl2ZWRMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IHJlcXVlc3RCeXRlcy5yZWFkVUludDgoMCkgPT09IDE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nID0gY29tcHJlc3NlZCA/IGVuY29kaW5nIDogJ2lkZW50aXR5JztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZE1lc3NhZ2UgPSBjYWxsLmdldERlY29tcHJlc3NlZE1lc3NhZ2UocmVxdWVzdEJ5dGVzLCBjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nKTtcclxuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGVjb21wcmVzc2VkTWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNhbGwuZGVzZXJpYWxpemVNZXNzYWdlV2l0aEludGVybmFsRXJyb3IoZGVjb21wcmVzc2VkTWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlY29tcHJlc3NlZE1lc3NhZ2UudGhlbihkZWNvbXByZXNzZWQgPT4gcmVzb2x2ZShjYWxsLmRlc2VyaWFsaXplTWVzc2FnZVdpdGhJbnRlcm5hbEVycm9yKGRlY29tcHJlc3NlZCkpLCAoZXJyKSA9PiByZWplY3QoZXJyLmNvZGVcclxuICAgICAgICAgICAgICAgICAgICA/IGVyclxyXG4gICAgICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBcImdycGMtZW5jb2RpbmdcIiBoZWFkZXIgXCIke2VuY29kaW5nfVwiIGJ1dCAke2VuY29kaW5nfSBkZWNvbXByZXNzaW9uIGZhaWxlZGAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBkZXNlcmlhbGl6ZU1lc3NhZ2VXaXRoSW50ZXJuYWxFcnJvcihidWZmZXIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZU1lc3NhZ2UoYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGVyciksXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VyaWFsaXplTWVzc2FnZSh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VCdWZmZXIgPSB0aGlzLmhhbmRsZXIuc2VyaWFsaXplKHZhbHVlKTtcclxuICAgICAgICAvLyBUT0RPKGNqaWhyaWcpOiBDYWxsIGNvbXByZXNzaW9uIGF3YXJlIHNlcmlhbGl6ZU1lc3NhZ2UoKS5cclxuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gbWVzc2FnZUJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlTGVuZ3RoICsgNSk7XHJcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDgoMCwgMCk7XHJcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDMyQkUoYnl0ZUxlbmd0aCwgMSk7XHJcbiAgICAgICAgbWVzc2FnZUJ1ZmZlci5jb3B5KG91dHB1dCwgNSk7XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuICAgIGRlc2VyaWFsaXplTWVzc2FnZShieXRlcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGVzZXJpYWxpemUoYnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2VuZFVuYXJ5TWVzc2FnZShlcnIsIHZhbHVlLCBtZXRhZGF0YSwgZmxhZ3MpIHtcclxuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1ldGFkYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbWV0YWRhdGEgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVyciwgJ21ldGFkYXRhJykgJiYgbWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGVyci5tZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKGVycik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlKHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk9LLCBkZXRhaWxzOiAnT0snLCBtZXRhZGF0YSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRFcnJvcih7XHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGVyciksXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRTdGF0dXMoc3RhdHVzT2JqKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB0aGlzLmVtaXQoJ2NhbGxFbmQnLCBzdGF0dXNPYmouY29kZSk7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdzdHJlYW1FbmQnLCBzdGF0dXNPYmouY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKTtcclxuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2UoJ1JlcXVlc3QgdG8gbWV0aG9kICcgK1xyXG4gICAgICAgICAgICAoKF9hID0gdGhpcy5oYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCkgK1xyXG4gICAgICAgICAgICAnIGVuZGVkIHdpdGggc3RhdHVzIGNvZGU6ICcgK1xyXG4gICAgICAgICAgICBjb25zdGFudHNfMS5TdGF0dXNbc3RhdHVzT2JqLmNvZGVdICtcclxuICAgICAgICAgICAgJyBkZXRhaWxzOiAnICtcclxuICAgICAgICAgICAgc3RhdHVzT2JqLmRldGFpbHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmRlYWRsaW5lVGltZXIpXHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYWRsaW5lVGltZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLnN0cmVhbS5oZWFkZXJzU2VudCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMud2FudFRyYWlsZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndhbnRUcmFpbGVycyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCd3YW50VHJhaWxlcnMnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWlsZXJzVG9TZW5kID0gT2JqZWN0LmFzc2lnbih7IFtHUlBDX1NUQVRVU19IRUFERVJdOiBzdGF0dXNPYmouY29kZSwgW0dSUENfTUVTU0FHRV9IRUFERVJdOiBlbmNvZGVVUkkoc3RhdHVzT2JqLmRldGFpbHMpIH0sIChfYSA9IHN0YXR1c09iai5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSHR0cDJIZWFkZXJzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnNlbmRUcmFpbGVycyh0cmFpbGVyc1RvU2VuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNTZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0uZW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRyYWlsZXJzLW9ubHkgcmVzcG9uc2VcclxuICAgICAgICAgICAgY29uc3QgdHJhaWxlcnNUb1NlbmQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBbR1JQQ19TVEFUVVNfSEVBREVSXTogc3RhdHVzT2JqLmNvZGUsIFtHUlBDX01FU1NBR0VfSEVBREVSXTogZW5jb2RlVVJJKHN0YXR1c09iai5kZXRhaWxzKSB9LCBkZWZhdWx0UmVzcG9uc2VIZWFkZXJzKSwgKF9iID0gc3RhdHVzT2JqLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9IdHRwMkhlYWRlcnMoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlc3BvbmQodHJhaWxlcnNUb1NlbmQsIHsgZW5kU3RyZWFtOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1c1NlbnQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRFcnJvcihlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcclxuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sXHJcbiAgICAgICAgICAgIGRldGFpbHM6ICdtZXNzYWdlJyBpbiBlcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBFcnJvcicsXHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiAnbWV0YWRhdGEnIGluIGVycm9yICYmIGVycm9yLm1ldGFkYXRhICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gZXJyb3IubWV0YWRhdGFcclxuICAgICAgICAgICAgICAgIDogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICgnY29kZScgaW4gZXJyb3IgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIoZXJyb3IuY29kZSkpIHtcclxuICAgICAgICAgICAgc3RhdHVzLmNvZGUgPSBlcnJvci5jb2RlO1xyXG4gICAgICAgICAgICBpZiAoJ2RldGFpbHMnIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5kZXRhaWxzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgPSBlcnJvci5kZXRhaWxzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VuZFN0YXR1cyhzdGF0dXMpO1xyXG4gICAgfVxyXG4gICAgd3JpdGUoY2h1bmspIHtcclxuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplICE9PSAtMSAmJlxyXG4gICAgICAgICAgICBjaHVuay5sZW5ndGggPiB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRFcnJvcih7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxyXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFNlbnQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7Y2h1bmsubGVuZ3RofSB2cy4gJHt0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZX0pYCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZW5kTWV0YWRhdGEoKTtcclxuICAgICAgICB0aGlzLmVtaXQoJ3NlbmRNZXNzYWdlJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKGNodW5rKTtcclxuICAgIH1cclxuICAgIHJlc3VtZSgpIHtcclxuICAgICAgICB0aGlzLnN0cmVhbS5yZXN1bWUoKTtcclxuICAgIH1cclxuICAgIHNldHVwU3VyZmFjZUNhbGwoY2FsbCkge1xyXG4gICAgICAgIHRoaXMub25jZSgnY2FuY2VsbGVkJywgcmVhc29uID0+IHtcclxuICAgICAgICAgICAgY2FsbC5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjYWxsLmVtaXQoJ2NhbmNlbGxlZCcsIHJlYXNvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5vbmNlKCdjYWxsRW5kJywgc3RhdHVzID0+IGNhbGwuZW1pdCgnY2FsbEVuZCcsIHN0YXR1cykpO1xyXG4gICAgfVxyXG4gICAgc2V0dXBSZWFkYWJsZShyZWFkYWJsZSwgZW5jb2RpbmcpIHtcclxuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IHN0cmVhbV9kZWNvZGVyXzEuU3RyZWFtRGVjb2Rlcih0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSk7XHJcbiAgICAgICAgbGV0IHJlYWRzRG9uZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcgPSBmYWxzZTtcclxuICAgICAgICBsZXQgcHVzaGVkRW5kID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgbWF5YmVQdXNoRW5kID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXB1c2hlZEVuZCAmJiByZWFkc0RvbmUgJiYgIXBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZykge1xyXG4gICAgICAgICAgICAgICAgcHVzaGVkRW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVzaE9yQnVmZmVyTWVzc2FnZShyZWFkYWJsZSwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdkYXRhJywgYXN5bmMgKGRhdGEpID0+IHtcclxuICAgICAgICAgICAgbGV0IG1lc3NhZ2VzO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZXMgPSBkZWNvZGVyLndyaXRlKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcclxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWNlaXZlTWVzc2FnZScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IG1lc3NhZ2UucmVhZFVJbnQ4KDApID09PSAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyA9IGNvbXByZXNzZWQgPyBlbmNvZGluZyA6ICdpZGVudGl0eSc7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGVjb21wcmVzc2VkTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVjb21wcmVzc2VkTWVzc2FnZSA9IGF3YWl0IHRoaXMuZ2V0RGVjb21wcmVzc2VkTWVzc2FnZShtZXNzYWdlLCBjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRW5jb3VudGVyZWQgYW4gZXJyb3Igd2l0aCBkZWNvbXByZXNzaW9uOyBpdCdsbCBhbHJlYWR5IGhhdmUgYmVlbiBwcm9wb2dhdGVkIGJhY2tcclxuICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIGVhcmx5XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRlY29tcHJlc3NlZE1lc3NhZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdXNoT3JCdWZmZXJNZXNzYWdlKHJlYWRhYmxlLCBkZWNvbXByZXNzZWRNZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zdHJlYW0ucmVzdW1lKCk7XHJcbiAgICAgICAgICAgIGF3YWl0IG1heWJlUHVzaEVuZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2VuZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgcmVhZHNEb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgYXdhaXQgbWF5YmVQdXNoRW5kKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdW1lVW5wdXNoZWRNZXNzYWdlcyhyZWFkYWJsZSkge1xyXG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IHRydWU7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMubWVzc2FnZXNUb1B1c2gubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0TWVzc2FnZSA9IHRoaXMubWVzc2FnZXNUb1B1c2guc2hpZnQoKTtcclxuICAgICAgICAgICAgY29uc3QgY2FuUHVzaCA9IHJlYWRhYmxlLnB1c2gobmV4dE1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAobmV4dE1lc3NhZ2UgPT09IG51bGwgfHwgY2FuUHVzaCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuUHVzaDtcclxuICAgIH1cclxuICAgIGFzeW5jIHB1c2hPckJ1ZmZlck1lc3NhZ2UocmVhZGFibGUsIG1lc3NhZ2VCeXRlcykge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUHVzaFBlbmRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJlZE1lc3NhZ2VzLnB1c2gobWVzc2FnZUJ5dGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHVzaE1lc3NhZ2UocmVhZGFibGUsIG1lc3NhZ2VCeXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgcHVzaE1lc3NhZ2UocmVhZGFibGUsIG1lc3NhZ2VCeXRlcykge1xyXG4gICAgICAgIGlmIChtZXNzYWdlQnl0ZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdHJhY2UoJ1JlY2VpdmVkIGVuZCBvZiBzdHJlYW0nKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FuUHVzaCkge1xyXG4gICAgICAgICAgICAgICAgcmVhZGFibGUucHVzaChudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNUb1B1c2gucHVzaChudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNlKCdSZWNlaXZlZCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZUJ5dGVzLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWQgPSBhd2FpdCB0aGlzLmRlc2VyaWFsaXplTWVzc2FnZShtZXNzYWdlQnl0ZXMpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYW5QdXNoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWRhYmxlLnB1c2goZGVzZXJpYWxpemVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzVG9QdXNoLnB1c2goZGVzZXJpYWxpemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gSWdub3JlIGFueSByZW1haW5pbmcgbWVzc2FnZXMgd2hlbiBlcnJvcnMgb2NjdXIuXHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyZWRNZXNzYWdlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBsZXQgY29kZSA9ICgwLCBlcnJvcl8xLmdldEVycm9yQ29kZSkoZXJyb3IpO1xyXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlIDwgY29uc3RhbnRzXzEuU3RhdHVzLk9LIHx8IGNvZGUgPiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVVRIRU5USUNBVEVEKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlYWRhYmxlLmVtaXQoJ2Vycm9yJywge1xyXG4gICAgICAgICAgICAgICAgZGV0YWlsczogKDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnJvciksXHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyZWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHVzaE1lc3NhZ2UocmVhZGFibGUsIHRoaXMuYnVmZmVyZWRNZXNzYWdlcy5zaGlmdCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBzb2NrZXQgPSAoX2EgPSB0aGlzLnN0cmVhbS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29ja2V0O1xyXG4gICAgICAgIGlmIChzb2NrZXQgPT09IG51bGwgfHwgc29ja2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb2NrZXQucmVtb3RlQWRkcmVzcykge1xyXG4gICAgICAgICAgICBpZiAoc29ja2V0LnJlbW90ZVBvcnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzb2NrZXQucmVtb3RlQWRkcmVzc306JHtzb2NrZXQucmVtb3RlUG9ydH1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5yZW1vdGVBZGRyZXNzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldERlYWRsaW5lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlYWRsaW5lO1xyXG4gICAgfVxyXG4gICAgZ2V0UGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLnBhdGg7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5IdHRwMlNlcnZlckNhbGxTdHJlYW0gPSBIdHRwMlNlcnZlckNhbGxTdHJlYW07XHJcbmZ1bmN0aW9uIGhhbmRsZUV4cGlyZWREZWFkbGluZShjYWxsKSB7XHJcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0RlYWRsaW5lIGV4Y2VlZGVkJyk7XHJcbiAgICBlcnIuY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRDtcclxuICAgIGNhbGwuc2VuZEVycm9yKGVycik7XHJcbiAgICBjYWxsLmNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICBjYWxsLmVtaXQoJ2NhbmNlbGxlZCcsICdkZWFkbGluZScpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-credentials.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ServerCredentials = void 0;\r\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\r\nclass ServerCredentials {\r\n    static createInsecure() {\r\n        return new InsecureServerCredentials();\r\n    }\r\n    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {\r\n        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {\r\n            throw new TypeError('rootCerts must be null or a Buffer');\r\n        }\r\n        if (!Array.isArray(keyCertPairs)) {\r\n            throw new TypeError('keyCertPairs must be an array');\r\n        }\r\n        if (typeof checkClientCertificate !== 'boolean') {\r\n            throw new TypeError('checkClientCertificate must be a boolean');\r\n        }\r\n        const cert = [];\r\n        const key = [];\r\n        for (let i = 0; i < keyCertPairs.length; i++) {\r\n            const pair = keyCertPairs[i];\r\n            if (pair === null || typeof pair !== 'object') {\r\n                throw new TypeError(`keyCertPair[${i}] must be an object`);\r\n            }\r\n            if (!Buffer.isBuffer(pair.private_key)) {\r\n                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\r\n            }\r\n            if (!Buffer.isBuffer(pair.cert_chain)) {\r\n                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\r\n            }\r\n            cert.push(pair.cert_chain);\r\n            key.push(pair.private_key);\r\n        }\r\n        return new SecureServerCredentials({\r\n            ca: rootCerts || (0, tls_helpers_1.getDefaultRootsData)() || undefined,\r\n            cert,\r\n            key,\r\n            requestCert: checkClientCertificate,\r\n            ciphers: tls_helpers_1.CIPHER_SUITES,\r\n        });\r\n    }\r\n}\r\nexports.ServerCredentials = ServerCredentials;\r\nclass InsecureServerCredentials extends ServerCredentials {\r\n    _isSecure() {\r\n        return false;\r\n    }\r\n    _getSettings() {\r\n        return null;\r\n    }\r\n}\r\nclass SecureServerCredentials extends ServerCredentials {\r\n    constructor(options) {\r\n        super();\r\n        this.options = options;\r\n    }\r\n    _isSecure() {\r\n        return true;\r\n    }\r\n    _getSettings() {\r\n        return this.options;\r\n    }\r\n}\r\n//# sourceMappingURL=server-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzP2ViM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSB2b2lkIDA7XHJcbmNvbnN0IHRsc19oZWxwZXJzXzEgPSByZXF1aXJlKFwiLi90bHMtaGVscGVyc1wiKTtcclxuY2xhc3MgU2VydmVyQ3JlZGVudGlhbHMge1xyXG4gICAgc3RhdGljIGNyZWF0ZUluc2VjdXJlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5zZWN1cmVTZXJ2ZXJDcmVkZW50aWFscygpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZVNzbChyb290Q2VydHMsIGtleUNlcnRQYWlycywgY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKHJvb3RDZXJ0cyAhPT0gbnVsbCAmJiAhQnVmZmVyLmlzQnVmZmVyKHJvb3RDZXJ0cykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncm9vdENlcnRzIG11c3QgYmUgbnVsbCBvciBhIEJ1ZmZlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5Q2VydFBhaXJzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZXlDZXJ0UGFpcnMgbXVzdCBiZSBhbiBhcnJheScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUgIT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaGVja0NsaWVudENlcnRpZmljYXRlIG11c3QgYmUgYSBib29sZWFuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNlcnQgPSBbXTtcclxuICAgICAgICBjb25zdCBrZXkgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleUNlcnRQYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwYWlyID0ga2V5Q2VydFBhaXJzW2ldO1xyXG4gICAgICAgICAgICBpZiAocGFpciA9PT0gbnVsbCB8fCB0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dIG11c3QgYmUgYW4gb2JqZWN0YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFpci5wcml2YXRlX2tleSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dLnByaXZhdGVfa2V5IG11c3QgYmUgYSBCdWZmZXJgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYWlyLmNlcnRfY2hhaW4pKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBrZXlDZXJ0UGFpclske2l9XS5jZXJ0X2NoYWluIG11c3QgYmUgYSBCdWZmZXJgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjZXJ0LnB1c2gocGFpci5jZXJ0X2NoYWluKTtcclxuICAgICAgICAgICAga2V5LnB1c2gocGFpci5wcml2YXRlX2tleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlU2VydmVyQ3JlZGVudGlhbHMoe1xyXG4gICAgICAgICAgICBjYTogcm9vdENlcnRzIHx8ICgwLCB0bHNfaGVscGVyc18xLmdldERlZmF1bHRSb290c0RhdGEpKCkgfHwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjZXJ0LFxyXG4gICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgIHJlcXVlc3RDZXJ0OiBjaGVja0NsaWVudENlcnRpZmljYXRlLFxyXG4gICAgICAgICAgICBjaXBoZXJzOiB0bHNfaGVscGVyc18xLkNJUEhFUl9TVUlURVMsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TZXJ2ZXJDcmVkZW50aWFscyA9IFNlcnZlckNyZWRlbnRpYWxzO1xyXG5jbGFzcyBJbnNlY3VyZVNlcnZlckNyZWRlbnRpYWxzIGV4dGVuZHMgU2VydmVyQ3JlZGVudGlhbHMge1xyXG4gICAgX2lzU2VjdXJlKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIF9nZXRTZXR0aW5ncygpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBTZWN1cmVTZXJ2ZXJDcmVkZW50aWFscyBleHRlbmRzIFNlcnZlckNyZWRlbnRpYWxzIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBfaXNTZWN1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBfZ2V0U2V0dGluZ3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcclxuICAgIH1cclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXItY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/server.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Server = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst server_call_1 = __webpack_require__(/*! ./server-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-call.js\");\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst { HTTP2_HEADER_PATH } = http2.constants;\nconst TRACER_NAME = \"server\";\nfunction noop() {}\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch(handlerType){\n        case \"unary\":\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case \"clientStream\":\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case \"serverStream\":\n            return (call)=>{\n                call.emit(\"error\", unimplementedStatusResponse);\n            };\n        case \"bidi\":\n            return (call)=>{\n                call.emit(\"error\", unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\nclass Server {\n    constructor(options){\n        var _a, _b, _c, _d;\n        this.http2ServerList = [];\n        this.handlers = new Map();\n        this.sessions = new Map();\n        this.started = false;\n        this.shutdown = false;\n        this.serverAddressString = \"null\";\n        // Channelz Info\n        this.channelzEnabled = true;\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.options = options !== null && options !== void 0 ? options : {};\n        if (this.options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzServer)(()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Server created\");\n        }\n        this.maxConnectionAgeMs = (_a = this.options[\"grpc.max_connection_age_ms\"]) !== null && _a !== void 0 ? _a : UNLIMITED_CONNECTION_AGE_MS;\n        this.maxConnectionAgeGraceMs = (_b = this.options[\"grpc.max_connection_age_grace_ms\"]) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;\n        this.keepaliveTimeMs = (_c = this.options[\"grpc.keepalive_time_ms\"]) !== null && _c !== void 0 ? _c : KEEPALIVE_MAX_TIME_MS;\n        this.keepaliveTimeoutMs = (_d = this.options[\"grpc.keepalive_timeout_ms\"]) !== null && _d !== void 0 ? _d : KEEPALIVE_TIMEOUT_MS;\n        this.trace(\"Server constructed\");\n    }\n    getChannelzInfo() {\n        return {\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            listenerChildren: this.listenerChildrenTracker.getChildLists(),\n            sessionChildren: this.sessionChildrenTracker.getChildLists()\n        };\n    }\n    getChannelzSessionInfoGetter(session) {\n        return ()=>{\n            var _a, _b, _c;\n            const sessionInfo = this.sessions.get(session);\n            const sessionSocket = session.socket;\n            const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n            const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n            let tlsInfo;\n            if (session.encrypted) {\n                const tlsSocket = sessionSocket;\n                const cipherInfo = tlsSocket.getCipher();\n                const certificate = tlsSocket.getCertificate();\n                const peerCertificate = tlsSocket.getPeerCertificate();\n                tlsInfo = {\n                    cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                    cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                    localCertificate: certificate && \"raw\" in certificate ? certificate.raw : null,\n                    remoteCertificate: peerCertificate && \"raw\" in peerCertificate ? peerCertificate.raw : null\n                };\n            } else {\n                tlsInfo = null;\n            }\n            const socketInfo = {\n                remoteAddress: remoteAddress,\n                localAddress: localAddress,\n                security: tlsInfo,\n                remoteName: null,\n                streamsStarted: sessionInfo.streamTracker.callsStarted,\n                streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n                streamsFailed: sessionInfo.streamTracker.callsFailed,\n                messagesSent: sessionInfo.messagesSent,\n                messagesReceived: sessionInfo.messagesReceived,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n                lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n                lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n                localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n                remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n            };\n            return socketInfo;\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + text);\n    }\n    addProtoService() {\n        throw new Error(\"Not implemented. Use addService() instead\");\n    }\n    addService(service, implementation) {\n        if (service === null || typeof service !== \"object\" || implementation === null || typeof implementation !== \"object\") {\n            throw new Error(\"addService() requires two objects as arguments\");\n        }\n        const serviceKeys = Object.keys(service);\n        if (serviceKeys.length === 0) {\n            throw new Error(\"Cannot add an empty service to a server\");\n        }\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            let methodType;\n            if (attrs.requestStream) {\n                if (attrs.responseStream) {\n                    methodType = \"bidi\";\n                } else {\n                    methodType = \"clientStream\";\n                }\n            } else {\n                if (attrs.responseStream) {\n                    methodType = \"serverStream\";\n                } else {\n                    methodType = \"unary\";\n                }\n            }\n            let implFn = implementation[name];\n            let impl;\n            if (implFn === undefined && typeof attrs.originalName === \"string\") {\n                implFn = implementation[attrs.originalName];\n            }\n            if (implFn !== undefined) {\n                impl = implFn.bind(implementation);\n            } else {\n                impl = getDefaultHandler(methodType, name);\n            }\n            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n            if (success === false) {\n                throw new Error(`Method handler for ${attrs.path} already provided.`);\n            }\n        });\n    }\n    removeService(service) {\n        if (service === null || typeof service !== \"object\") {\n            throw new Error(\"removeService() requires object as argument\");\n        }\n        const serviceKeys = Object.keys(service);\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            this.unregister(attrs.path);\n        });\n    }\n    bind(port, creds) {\n        throw new Error(\"Not implemented. Use bindAsync() instead\");\n    }\n    bindAsync(port, creds, callback) {\n        if (this.started === true) {\n            throw new Error(\"server is already started\");\n        }\n        if (this.shutdown) {\n            throw new Error(\"bindAsync called after shutdown\");\n        }\n        if (typeof port !== \"string\") {\n            throw new TypeError(\"port must be a string\");\n        }\n        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n            throw new TypeError(\"creds must be a ServerCredentials object\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new TypeError(\"callback must be a function\");\n        }\n        const initialPortUri = (0, uri_parser_1.parseUri)(port);\n        if (initialPortUri === null) {\n            throw new Error(`Could not parse port \"${port}\"`);\n        }\n        const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);\n        if (portUri === null) {\n            throw new Error(`Could not get a default scheme for port \"${port}\"`);\n        }\n        const serverOptions = {\n            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n        };\n        if (\"grpc-node.max_session_memory\" in this.options) {\n            serverOptions.maxSessionMemory = this.options[\"grpc-node.max_session_memory\"];\n        } else {\n            /* By default, set a very large max session memory limit, to effectively\r\n             * disable enforcement of the limit. Some testing indicates that Node's\r\n             * behavior degrades badly when this limit is reached, so we solve that\r\n             * by disabling the check entirely. */ serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        if (\"grpc.max_concurrent_streams\" in this.options) {\n            serverOptions.settings = {\n                maxConcurrentStreams: this.options[\"grpc.max_concurrent_streams\"]\n            };\n        }\n        const deferredCallback = (error, port)=>{\n            process.nextTick(()=>callback(error, port));\n        };\n        const setupServer = ()=>{\n            let http2Server;\n            if (creds._isSecure()) {\n                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n                secureServerOptions.enableTrace = this.options[\"grpc-node.tls_enable_trace\"] === 1;\n                http2Server = http2.createSecureServer(secureServerOptions);\n                http2Server.on(\"secureConnection\", (socket)=>{\n                    /* These errors need to be handled by the user of Http2SecureServer,\r\n                     * according to https://github.com/nodejs/node/issues/35824 */ socket.on(\"error\", (e)=>{\n                        this.trace(\"An incoming TLS connection closed with error: \" + e.message);\n                    });\n                });\n            } else {\n                http2Server = http2.createServer(serverOptions);\n            }\n            http2Server.setTimeout(0, noop);\n            this._setupHandlers(http2Server);\n            return http2Server;\n        };\n        const bindSpecificPort = (addressList, portNum, previousCount)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: portNum,\n                    count: previousCount\n                });\n            }\n            return Promise.all(addressList.map((address)=>{\n                this.trace(\"Attempting to bind \" + (0, subchannel_address_1.subchannelAddressToString)(address));\n                let addr;\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n                    addr = {\n                        host: address.host,\n                        port: portNum\n                    };\n                } else {\n                    addr = address;\n                }\n                const http2Server = setupServer();\n                return new Promise((resolve, reject)=>{\n                    const onError = (err)=>{\n                        this.trace(\"Failed to bind \" + (0, subchannel_address_1.subchannelAddressToString)(address) + \" with error \" + err.message);\n                        resolve(err);\n                    };\n                    http2Server.once(\"error\", onError);\n                    http2Server.listen(addr, ()=>{\n                        if (this.shutdown) {\n                            http2Server.close();\n                            resolve(new Error(\"bindAsync failed because server is shutdown\"));\n                            return;\n                        }\n                        const boundAddress = http2Server.address();\n                        let boundSubchannelAddress;\n                        if (typeof boundAddress === \"string\") {\n                            boundSubchannelAddress = {\n                                path: boundAddress\n                            };\n                        } else {\n                            boundSubchannelAddress = {\n                                host: boundAddress.address,\n                                port: boundAddress.port\n                            };\n                        }\n                        const channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), ()=>{\n                            return {\n                                localAddress: boundSubchannelAddress,\n                                remoteAddress: null,\n                                security: null,\n                                remoteName: null,\n                                streamsStarted: 0,\n                                streamsSucceeded: 0,\n                                streamsFailed: 0,\n                                messagesSent: 0,\n                                messagesReceived: 0,\n                                keepAlivesSent: 0,\n                                lastLocalStreamCreatedTimestamp: null,\n                                lastRemoteStreamCreatedTimestamp: null,\n                                lastMessageSentTimestamp: null,\n                                lastMessageReceivedTimestamp: null,\n                                localFlowControlWindow: null,\n                                remoteFlowControlWindow: null\n                            };\n                        }, this.channelzEnabled);\n                        if (this.channelzEnabled) {\n                            this.listenerChildrenTracker.refChild(channelzRef);\n                        }\n                        this.http2ServerList.push({\n                            server: http2Server,\n                            channelzRef: channelzRef\n                        });\n                        this.trace(\"Successfully bound \" + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n                        resolve(\"port\" in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n                        http2Server.removeListener(\"error\", onError);\n                    });\n                });\n            })).then((results)=>{\n                let count = 0;\n                for (const result of results){\n                    if (typeof result === \"number\") {\n                        count += 1;\n                        if (result !== portNum) {\n                            throw new Error(\"Invalid state: multiple port numbers added from single address\");\n                        }\n                    }\n                }\n                return {\n                    port: portNum,\n                    count: count + previousCount\n                };\n            });\n        };\n        const bindWildcardPort = (addressList)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: 0,\n                    count: 0\n                });\n            }\n            const address = addressList[0];\n            const http2Server = setupServer();\n            return new Promise((resolve, reject)=>{\n                const onError = (err)=>{\n                    this.trace(\"Failed to bind \" + (0, subchannel_address_1.subchannelAddressToString)(address) + \" with error \" + err.message);\n                    resolve(bindWildcardPort(addressList.slice(1)));\n                };\n                http2Server.once(\"error\", onError);\n                http2Server.listen(address, ()=>{\n                    if (this.shutdown) {\n                        http2Server.close();\n                        resolve({\n                            port: 0,\n                            count: 0\n                        });\n                        return;\n                    }\n                    const boundAddress = http2Server.address();\n                    const boundSubchannelAddress = {\n                        host: boundAddress.address,\n                        port: boundAddress.port\n                    };\n                    const channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), ()=>{\n                        return {\n                            localAddress: boundSubchannelAddress,\n                            remoteAddress: null,\n                            security: null,\n                            remoteName: null,\n                            streamsStarted: 0,\n                            streamsSucceeded: 0,\n                            streamsFailed: 0,\n                            messagesSent: 0,\n                            messagesReceived: 0,\n                            keepAlivesSent: 0,\n                            lastLocalStreamCreatedTimestamp: null,\n                            lastRemoteStreamCreatedTimestamp: null,\n                            lastMessageSentTimestamp: null,\n                            lastMessageReceivedTimestamp: null,\n                            localFlowControlWindow: null,\n                            remoteFlowControlWindow: null\n                        };\n                    }, this.channelzEnabled);\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.refChild(channelzRef);\n                    }\n                    this.http2ServerList.push({\n                        server: http2Server,\n                        channelzRef: channelzRef\n                    });\n                    this.trace(\"Successfully bound \" + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n                    resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n                    http2Server.removeListener(\"error\", onError);\n                });\n            });\n        };\n        const resolverListener = {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError)=>{\n                // We only want one resolution result. Discard all future results\n                resolverListener.onSuccessfulResolution = ()=>{};\n                if (this.shutdown) {\n                    deferredCallback(new Error(`bindAsync failed because server is shutdown`), 0);\n                }\n                if (addressList.length === 0) {\n                    deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n                    return;\n                }\n                let bindResultPromise;\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0])) {\n                    if (addressList[0].port === 0) {\n                        bindResultPromise = bindWildcardPort(addressList);\n                    } else {\n                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n                    }\n                } else {\n                    // Use an arbitrary non-zero port for non-TCP addresses\n                    bindResultPromise = bindSpecificPort(addressList, 1, 0);\n                }\n                bindResultPromise.then((bindResult)=>{\n                    if (bindResult.count === 0) {\n                        const errorString = `No address added out of total ${addressList.length} resolved`;\n                        logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                        deferredCallback(new Error(errorString), 0);\n                    } else {\n                        if (bindResult.count < addressList.length) {\n                            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                        }\n                        deferredCallback(null, bindResult.port);\n                    }\n                }, (error)=>{\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                    deferredCallback(new Error(errorString), 0);\n                });\n            },\n            onError: (error)=>{\n                deferredCallback(new Error(error.details), 0);\n            }\n        };\n        const resolver = (0, resolver_1.createResolver)(portUri, resolverListener, this.options);\n        resolver.updateResolution();\n    }\n    forceShutdown() {\n        // Close the server if it is still running.\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        (0, channelz_1.unregisterChannelzRef)(ref);\n                    }\n                });\n            }\n        }\n        this.started = false;\n        this.shutdown = true;\n        // Always destroy any available sessions. It's possible that one or more\n        // tryShutdown() calls are in progress. Don't wait on them to finish.\n        this.sessions.forEach((channelzInfo, session)=>{\n            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n            // recognize destroy(code) as a valid signature.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            session.destroy(http2.constants.NGHTTP2_CANCEL);\n        });\n        this.sessions.clear();\n        if (this.channelzEnabled) {\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        }\n    }\n    register(name, handler, serialize, deserialize, type) {\n        if (this.handlers.has(name)) {\n            return false;\n        }\n        this.handlers.set(name, {\n            func: handler,\n            serialize,\n            deserialize,\n            type,\n            path: name\n        });\n        return true;\n    }\n    unregister(name) {\n        return this.handlers.delete(name);\n    }\n    start() {\n        if (this.http2ServerList.length === 0 || this.http2ServerList.every(({ server: http2Server })=>http2Server.listening !== true)) {\n            throw new Error(\"server must be bound in order to start\");\n        }\n        if (this.started === true) {\n            throw new Error(\"server is already started\");\n        }\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Starting\");\n        }\n        this.started = true;\n    }\n    tryShutdown(callback) {\n        const wrappedCallback = (error)=>{\n            if (this.channelzEnabled) {\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n            }\n            callback(error);\n        };\n        let pendingChecks = 0;\n        function maybeCallback() {\n            pendingChecks--;\n            if (pendingChecks === 0) {\n                wrappedCallback();\n            }\n        }\n        // Close the server if necessary.\n        this.started = false;\n        this.shutdown = true;\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                pendingChecks++;\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        (0, channelz_1.unregisterChannelzRef)(ref);\n                    }\n                    maybeCallback();\n                });\n            }\n        }\n        this.sessions.forEach((channelzInfo, session)=>{\n            if (!session.closed) {\n                pendingChecks += 1;\n                session.close(maybeCallback);\n            }\n        });\n        if (pendingChecks === 0) {\n            wrappedCallback();\n        }\n    }\n    addHttp2Port() {\n        throw new Error(\"Not yet implemented\");\n    }\n    /**\r\n     * Get the channelz reference object for this server. The returned value is\r\n     * garbage if channelz is disabled for this server.\r\n     * @returns\r\n     */ getChannelzRef() {\n        return this.channelzRef;\n    }\n    _verifyContentType(stream, headers) {\n        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n        if (typeof contentType !== \"string\" || !contentType.startsWith(\"application/grpc\")) {\n            stream.respond({\n                [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n            }, {\n                endStream: true\n            });\n            return false;\n        }\n        return true;\n    }\n    _retrieveHandler(path) {\n        this.trace(\"Received call to method \" + path + \" at address \" + this.serverAddressString);\n        const handler = this.handlers.get(path);\n        if (handler === undefined) {\n            this.trace(\"No handler registered for method \" + path + \". Sending UNIMPLEMENTED status.\");\n            return null;\n        }\n        return handler;\n    }\n    _respondWithError(err, stream, channelzSessionInfo = null) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n        if (err.code === undefined) {\n            err.code = constants_1.Status.INTERNAL;\n        }\n        if (this.channelzEnabled) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        }\n        call.sendError(err);\n    }\n    _channelzHandler(stream, headers) {\n        const channelzSessionInfo = this.sessions.get(stream.session);\n        this.callTracker.addCallStarted();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n        if (!this._verifyContentType(stream, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            return;\n        }\n        const path = headers[HTTP2_HEADER_PATH];\n        const handler = this._retrieveHandler(path);\n        if (!handler) {\n            this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        call.once(\"callEnd\", (code)=>{\n            if (code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            } else {\n                this.callTracker.addCallFailed();\n            }\n        });\n        if (channelzSessionInfo) {\n            call.once(\"streamEnd\", (success)=>{\n                if (success) {\n                    channelzSessionInfo.streamTracker.addCallSucceeded();\n                } else {\n                    channelzSessionInfo.streamTracker.addCallFailed();\n                }\n            });\n            call.on(\"sendMessage\", ()=>{\n                channelzSessionInfo.messagesSent += 1;\n                channelzSessionInfo.lastMessageSentTimestamp = new Date();\n            });\n            call.on(\"receiveMessage\", ()=>{\n                channelzSessionInfo.messagesReceived += 1;\n                channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n            });\n        }\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _streamHandler(stream, headers) {\n        if (this._verifyContentType(stream, headers) !== true) {\n            return;\n        }\n        const path = headers[HTTP2_HEADER_PATH];\n        const handler = this._retrieveHandler(path);\n        if (!handler) {\n            this._respondWithError(getUnimplementedStatusResponse(path), stream, null);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _runHandlerForCall(call, handler, headers) {\n        var _a;\n        const metadata = call.receiveMetadata(headers);\n        const encoding = (_a = metadata.get(\"grpc-encoding\")[0]) !== null && _a !== void 0 ? _a : \"identity\";\n        metadata.remove(\"grpc-encoding\");\n        const { type } = handler;\n        if (type === \"unary\") {\n            handleUnary(call, handler, metadata, encoding);\n        } else if (type === \"clientStream\") {\n            handleClientStreaming(call, handler, metadata, encoding);\n        } else if (type === \"serverStream\") {\n            handleServerStreaming(call, handler, metadata, encoding);\n        } else if (type === \"bidi\") {\n            handleBidiStreaming(call, handler, metadata, encoding);\n        } else {\n            return false;\n        }\n        return true;\n    }\n    _setupHandlers(http2Server) {\n        if (http2Server === null) {\n            return;\n        }\n        const serverAddress = http2Server.address();\n        let serverAddressString = \"null\";\n        if (serverAddress) {\n            if (typeof serverAddress === \"string\") {\n                serverAddressString = serverAddress;\n            } else {\n                serverAddressString = serverAddress.address + \":\" + serverAddress.port;\n            }\n        }\n        this.serverAddressString = serverAddressString;\n        const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n        http2Server.on(\"stream\", handler.bind(this));\n        http2Server.on(\"session\", (session)=>{\n            var _a, _b, _c, _d, _e;\n            if (!this.started) {\n                session.destroy();\n                return;\n            }\n            const channelzRef = (0, channelz_1.registerChannelzSocket)((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : \"unknown\", this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n            const channelzSessionInfo = {\n                ref: channelzRef,\n                streamTracker: new channelz_1.ChannelzCallTracker(),\n                messagesSent: 0,\n                messagesReceived: 0,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null\n            };\n            this.sessions.set(session, channelzSessionInfo);\n            const clientAddress = session.socket.remoteAddress;\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Connection established by client \" + clientAddress);\n                this.sessionChildrenTracker.refChild(channelzRef);\n            }\n            let connectionAgeTimer = null;\n            let connectionAgeGraceTimer = null;\n            let sessionClosedByServer = false;\n            if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                // Apply a random jitter within a +/-10% range\n                const jitterMagnitude = this.maxConnectionAgeMs / 10;\n                const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n                connectionAgeTimer = (_c = (_b = setTimeout(()=>{\n                    var _a, _b;\n                    sessionClosedByServer = true;\n                    if (this.channelzEnabled) {\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by max connection age from \" + clientAddress);\n                    }\n                    try {\n                        session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), Buffer.from(\"max_age\"));\n                    } catch (e) {\n                        // The goaway can't be sent because the session is already closed\n                        session.destroy();\n                        return;\n                    }\n                    session.close();\n                    /* Allow a grace period after sending the GOAWAY before forcibly\r\n                     * closing the connection. */ if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                        connectionAgeGraceTimer = (_b = (_a = setTimeout(()=>{\n                            session.destroy();\n                        }, this.maxConnectionAgeGraceMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    }\n                }, this.maxConnectionAgeMs + jitter)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n            }\n            const keeapliveTimeTimer = (_e = (_d = setInterval(()=>{\n                var _a, _b;\n                const timeoutTImer = (_b = (_a = setTimeout(()=>{\n                    sessionClosedByServer = true;\n                    if (this.channelzEnabled) {\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by keepalive timeout from \" + clientAddress);\n                    }\n                    session.close();\n                }, this.keepaliveTimeoutMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n                try {\n                    session.ping((err, duration, payload)=>{\n                        clearTimeout(timeoutTImer);\n                    });\n                } catch (e) {\n                    // The ping can't be sent because the session is already closed\n                    session.destroy();\n                }\n            }, this.keepaliveTimeMs)).unref) === null || _e === void 0 ? void 0 : _e.call(_d);\n            session.on(\"close\", ()=>{\n                if (this.channelzEnabled) {\n                    if (!sessionClosedByServer) {\n                        this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by client \" + clientAddress);\n                    }\n                    this.sessionChildrenTracker.unrefChild(channelzRef);\n                    (0, channelz_1.unregisterChannelzRef)(channelzRef);\n                }\n                if (connectionAgeTimer) {\n                    clearTimeout(connectionAgeTimer);\n                }\n                if (connectionAgeGraceTimer) {\n                    clearTimeout(connectionAgeGraceTimer);\n                }\n                if (keeapliveTimeTimer) {\n                    clearTimeout(keeapliveTimeTimer);\n                }\n                this.sessions.delete(session);\n            });\n        });\n    }\n}\nexports.Server = Server;\nasync function handleUnary(call, handler, metadata, encoding) {\n    try {\n        const request = await call.receiveUnaryMessage(encoding);\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n        handler.func(emitter, (err, value, trailer, flags)=>{\n            call.sendUnaryMessage(err, value, trailer, flags);\n        });\n    } catch (err) {\n        call.sendError(err);\n    }\n}\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n    function respond(err, value, trailer, flags) {\n        stream.destroy();\n        call.sendUnaryMessage(err, value, trailer, flags);\n    }\n    if (call.cancelled) {\n        return;\n    }\n    stream.on(\"error\", respond);\n    handler.func(stream, respond);\n}\nasync function handleServerStreaming(call, handler, metadata, encoding) {\n    try {\n        const request = await call.receiveUnaryMessage(encoding);\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n        handler.func(stream);\n    } catch (err) {\n        call.sendError(err);\n    }\n}\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n    if (call.cancelled) {\n        return;\n    }\n    handler.func(stream);\n} //# sourceMappingURL=server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxNQUFBQSxRQUFBQyxtQkFBQUEsQ0FBQTtBQUlBLE1BQUFDLGNBQUFELG1CQUFBQSxDQUFBO0FBR0EsTUFBQUUsZ0JBQUFGLG1CQUFBQSxDQUFBO0FBcUJBLE1BQUFHLHVCQUFBSCxtQkFBQUEsQ0FBQTtBQUVBLE1BQUFJLGFBQUFKLG1CQUFBQSxDQUFBO0FBS0EsTUFBQUssVUFBQUwsbUJBQUFBLENBQUE7QUFDQSxNQUFBTSx1QkFBQU4sbUJBQUFBLENBQUE7QUFPQSxNQUFBTyxlQUFBUCxtQkFBQUEsQ0FBQTtBQUNBLE1BQUFRLGFBQUFSLG1CQUFBQSxDQUFBO0FBZUEsTUFBTVMsOEJBQThCLENBQUUsTUFBSztBQUMzQyxNQUFNQyx3QkFBd0IsQ0FBRSxNQUFLO0FBQ3JDLE1BQU1DLHVCQUF1QjtBQUU3QixNQUFNLEVBQUVDLGlCQUFpQixFQUFFLEdBQUdiLE1BQU1jLFNBQVM7QUFFN0MsTUFBTUMsY0FBYztBQU9wQixTQUFTQyxRQUFjO0FBRXZCLFNBQVNDLCtCQUNQQyxVQUFrQjtJQUVsQixPQUFPO1FBQ0xDLE1BQU1qQixZQUFBa0IsTUFBTSxDQUFDQyxhQUFhO1FBQzFCQyxTQUFTLDRDQUE0Q0osV0FBVSxDQUFFOztBQUVyRTtBQWFBLFNBQVNLLGtCQUFrQkMsV0FBd0IsRUFBRU4sVUFBa0I7SUFDckUsTUFBTU8sOEJBQ0pSLCtCQUErQkM7SUFDakMsT0FBUU07UUFDTixLQUFLO1lBQ0gsT0FBTyxDQUNMRSxNQUNBQztnQkFFQUEsU0FBU0YsNkJBQTZDO1lBQ3hEO1FBQ0YsS0FBSztZQUNILE9BQU8sQ0FDTEMsTUFDQUM7Z0JBRUFBLFNBQVNGLDZCQUE2QztZQUN4RDtRQUNGLEtBQUs7WUFDSCxPQUFPLENBQUNDO2dCQUNOQSxLQUFLRSxJQUFJLENBQUMsU0FBU0g7WUFDckI7UUFDRixLQUFLO1lBQ0gsT0FBTyxDQUFDQztnQkFDTkEsS0FBS0UsSUFBSSxDQUFDLFNBQVNIO1lBQ3JCO1FBQ0Y7WUFDRSxNQUFNLElBQUlJLE1BQU0sdUJBQXVCTCxZQUFXLENBQUU7SUFDeEQ7QUFDRjtBQVdBLE1BQWFNO0lBOEJYQyxZQUFZQyxPQUF3Qjs7UUE3QjVCLEtBQUFDLGVBQWUsR0FHakIsRUFBRTtRQUVBLEtBQUFDLFFBQVEsR0FBZ0MsSUFBSUM7UUFJNUMsS0FBQUMsUUFBUSxHQUFHLElBQUlEO1FBQ2YsS0FBQUUsT0FBTyxHQUFHO1FBQ1YsS0FBQUMsUUFBUSxHQUFHO1FBRVgsS0FBQUMsbUJBQW1CLEdBQUc7UUFFOUIsZ0JBQWdCO1FBQ0MsS0FBQUMsZUFBZSxHQUFZO1FBRXBDLEtBQUFDLGFBQWEsR0FBRyxJQUFJaEMsV0FBQWlDLGFBQWE7UUFDakMsS0FBQUMsV0FBVyxHQUFHLElBQUlsQyxXQUFBbUMsbUJBQW1CO1FBQ3JDLEtBQUFDLHVCQUF1QixHQUFHLElBQUlwQyxXQUFBcUMsdUJBQXVCO1FBQ3JELEtBQUFDLHNCQUFzQixHQUFHLElBQUl0QyxXQUFBcUMsdUJBQXVCO1FBUzFELElBQUksQ0FBQ2QsT0FBTyxHQUFHQSxZQUFPLFFBQVBBLFlBQU8sU0FBUEEsVUFBVztRQUMxQixJQUFJLElBQUksQ0FBQ0EsT0FBTyxDQUFDLHVCQUF1QixLQUFLLEdBQUc7WUFDOUMsSUFBSSxDQUFDUSxlQUFlLEdBQUc7UUFDekI7UUFDQSxJQUFJLENBQUNRLFdBQVcsR0FBRyxJQUFBdkMsV0FBQXdDLHNCQUFzQixFQUN2QyxJQUFNLElBQUksQ0FBQ0MsZUFBZSxJQUMxQixJQUFJLENBQUNWLGVBQWU7UUFFdEIsSUFBSSxJQUFJLENBQUNBLGVBQWUsRUFBRTtZQUN4QixJQUFJLENBQUNDLGFBQWEsQ0FBQ1UsUUFBUSxDQUFDLFdBQVc7UUFDekM7UUFDQSxJQUFJLENBQUNDLGtCQUFrQixHQUNyQixDQUFBQyxLQUFBLElBQUksQ0FBQ3JCLE9BQU8sQ0FBQyw2QkFBNkIsY0FBQXFCLE9BQUEsU0FBQUEsS0FBSTNDO1FBQ2hELElBQUksQ0FBQzRDLHVCQUF1QixHQUMxQixDQUFBQyxLQUFBLElBQUksQ0FBQ3ZCLE9BQU8sQ0FBQyxtQ0FBbUMsY0FBQXVCLE9BQUEsU0FBQUEsS0FDaEQ3QztRQUNGLElBQUksQ0FBQzhDLGVBQWUsR0FDbEIsQ0FBQUMsS0FBQSxJQUFJLENBQUN6QixPQUFPLENBQUMseUJBQXlCLGNBQUF5QixPQUFBLFNBQUFBLEtBQUk5QztRQUM1QyxJQUFJLENBQUMrQyxrQkFBa0IsR0FDckIsQ0FBQUMsS0FBQSxJQUFJLENBQUMzQixPQUFPLENBQUMsNEJBQTRCLGNBQUEyQixPQUFBLFNBQUFBLEtBQUkvQztRQUMvQyxJQUFJLENBQUNnRCxLQUFLLENBQUM7SUFDYjtJQUVRVixrQkFBZTtRQUNyQixPQUFPO1lBQ0xVLE9BQU8sSUFBSSxDQUFDbkIsYUFBYTtZQUN6QkUsYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDN0JrQixrQkFBa0IsSUFBSSxDQUFDaEIsdUJBQXVCLENBQUNpQixhQUFhO1lBQzVEQyxpQkFBaUIsSUFBSSxDQUFDaEIsc0JBQXNCLENBQUNlLGFBQWE7O0lBRTlEO0lBRVFFLDZCQUNOQyxPQUFpQztRQUVqQyxPQUFPOztZQUNMLE1BQU1DLGNBQWMsSUFBSSxDQUFDOUIsUUFBUSxDQUFDK0IsR0FBRyxDQUFDRjtZQUN0QyxNQUFNRyxnQkFBZ0JILFFBQVFJLE1BQU07WUFDcEMsTUFBTUMsZ0JBQWdCRixjQUFjRSxhQUFhLEdBQzdDLElBQUEvRCxxQkFBQWdFLHlCQUF5QixFQUN2QkgsY0FBY0UsYUFBYSxFQUMzQkYsY0FBY0ksVUFBVSxJQUUxQjtZQUNKLE1BQU1DLGVBQWVMLGNBQWNLLFlBQVksR0FDM0MsSUFBQWxFLHFCQUFBZ0UseUJBQXlCLEVBQ3ZCSCxjQUFjSyxZQUFhLEVBQzNCTCxjQUFjTSxTQUFTLElBRXpCO1lBQ0osSUFBSUM7WUFDSixJQUFJVixRQUFRVyxTQUFTLEVBQUU7Z0JBQ3JCLE1BQU1DLFlBQXVCVDtnQkFDN0IsTUFBTVUsYUFDSkQsVUFBVUUsU0FBUztnQkFDckIsTUFBTUMsY0FBY0gsVUFBVUksY0FBYztnQkFDNUMsTUFBTUMsa0JBQWtCTCxVQUFVTSxrQkFBa0I7Z0JBQ3BEUixVQUFVO29CQUNSUyx5QkFBeUIsQ0FBQS9CLEtBQUF5QixXQUFXTyxZQUFZLGNBQUFoQyxPQUFBLFNBQUFBLEtBQUk7b0JBQ3BEaUMsc0JBQXNCUixXQUFXTyxZQUFZLEdBQ3pDLE9BQ0FQLFdBQVdTLElBQUk7b0JBQ25CQyxrQkFDRVIsZUFBZSxTQUFTQSxjQUFjQSxZQUFZUyxHQUFHLEdBQUc7b0JBQzFEQyxtQkFDRVIsbUJBQW1CLFNBQVNBLGtCQUN4QkEsZ0JBQWdCTyxHQUFHLEdBQ25COztZQUVWLE9BQU87Z0JBQ0xkLFVBQVU7WUFDWjtZQUNBLE1BQU1nQixhQUF5QjtnQkFDN0JyQixlQUFlQTtnQkFDZkcsY0FBY0E7Z0JBQ2RtQixVQUFVakI7Z0JBQ1ZrQixZQUFZO2dCQUNaQyxnQkFBZ0I1QixZQUFZNkIsYUFBYSxDQUFDQyxZQUFZO2dCQUN0REMsa0JBQWtCL0IsWUFBWTZCLGFBQWEsQ0FBQ0csY0FBYztnQkFDMURDLGVBQWVqQyxZQUFZNkIsYUFBYSxDQUFDSyxXQUFXO2dCQUNwREMsY0FBY25DLFlBQVltQyxZQUFZO2dCQUN0Q0Msa0JBQWtCcEMsWUFBWW9DLGdCQUFnQjtnQkFDOUNDLGdCQUFnQjtnQkFDaEJDLGlDQUFpQztnQkFDakNDLGtDQUNFdkMsWUFBWTZCLGFBQWEsQ0FBQ1csd0JBQXdCO2dCQUNwREMsMEJBQTBCekMsWUFBWXlDLHdCQUF3QjtnQkFDOURDLDhCQUE4QjFDLFlBQVkwQyw0QkFBNEI7Z0JBQ3RFQyx3QkFBd0IsQ0FBQXRELEtBQUFVLFFBQVE2QyxLQUFLLENBQUNDLGVBQWUsY0FBQXhELE9BQUEsU0FBQUEsS0FBSTtnQkFDekR5RCx5QkFBeUIsQ0FBQXZELEtBQUFRLFFBQVE2QyxLQUFLLENBQUNHLGdCQUFnQixjQUFBeEQsT0FBQSxTQUFBQSxLQUFJOztZQUU3RCxPQUFPa0M7UUFDVDtJQUNGO0lBRVEvQixNQUFNc0QsSUFBWTtRQUN4QjVHLFFBQVFzRCxLQUFLLENBQ1gxRCxZQUFBaUgsWUFBWSxDQUFDQyxLQUFLLEVBQ2xCckcsYUFDQSxNQUFNLElBQUksQ0FBQ2lDLFdBQVcsQ0FBQ3FFLEVBQUUsR0FBRyxPQUFPSDtJQUV2QztJQUVBSSxrQkFBZTtRQUNiLE1BQU0sSUFBSXpGLE1BQU07SUFDbEI7SUFFQTBGLFdBQ0VDLE9BQTBCLEVBQzFCQyxjQUE0QztRQUU1QyxJQUNFRCxZQUFZLFFBQ1osT0FBT0EsWUFBWSxZQUNuQkMsbUJBQW1CLFFBQ25CLE9BQU9BLG1CQUFtQixVQUMxQjtZQUNBLE1BQU0sSUFBSTVGLE1BQU07UUFDbEI7UUFFQSxNQUFNNkYsY0FBY0MsT0FBT0MsSUFBSSxDQUFDSjtRQUVoQyxJQUFJRSxZQUFZRyxNQUFNLEtBQUssR0FBRztZQUM1QixNQUFNLElBQUloRyxNQUFNO1FBQ2xCO1FBRUE2RixZQUFZSSxPQUFPLENBQUN2QyxDQUFBQTtZQUNsQixNQUFNd0MsUUFBUVAsT0FBTyxDQUFDakMsS0FBSztZQUMzQixJQUFJeUM7WUFFSixJQUFJRCxNQUFNRSxhQUFhLEVBQUU7Z0JBQ3ZCLElBQUlGLE1BQU1HLGNBQWMsRUFBRTtvQkFDeEJGLGFBQWE7Z0JBQ2YsT0FBTztvQkFDTEEsYUFBYTtnQkFDZjtZQUNGLE9BQU87Z0JBQ0wsSUFBSUQsTUFBTUcsY0FBYyxFQUFFO29CQUN4QkYsYUFBYTtnQkFDZixPQUFPO29CQUNMQSxhQUFhO2dCQUNmO1lBQ0Y7WUFFQSxJQUFJRyxTQUFTVixjQUFjLENBQUNsQyxLQUFLO1lBQ2pDLElBQUk2QztZQUVKLElBQUlELFdBQVdFLGFBQWEsT0FBT04sTUFBTU8sWUFBWSxLQUFLLFVBQVU7Z0JBQ2xFSCxTQUFTVixjQUFjLENBQUNNLE1BQU1PLFlBQVksQ0FBQztZQUM3QztZQUVBLElBQUlILFdBQVdFLFdBQVc7Z0JBQ3hCRCxPQUFPRCxPQUFPSSxJQUFJLENBQUNkO1lBQ3JCLE9BQU87Z0JBQ0xXLE9BQU83RyxrQkFBa0J5RyxZQUFZekM7WUFDdkM7WUFFQSxNQUFNaUQsVUFBVSxJQUFJLENBQUNDLFFBQVEsQ0FDM0JWLE1BQU1XLElBQUksRUFDVk4sTUFDQUwsTUFBTVksaUJBQWlCLEVBQ3ZCWixNQUFNYSxrQkFBa0IsRUFDeEJaO1lBR0YsSUFBSVEsWUFBWSxPQUFPO2dCQUNyQixNQUFNLElBQUkzRyxNQUFNLHNCQUFzQmtHLE1BQU1XLElBQUksb0JBQW9CO1lBQ3RFO1FBQ0Y7SUFDRjtJQUVBRyxjQUFjckIsT0FBMEI7UUFDdEMsSUFBSUEsWUFBWSxRQUFRLE9BQU9BLFlBQVksVUFBVTtZQUNuRCxNQUFNLElBQUkzRixNQUFNO1FBQ2xCO1FBRUEsTUFBTTZGLGNBQWNDLE9BQU9DLElBQUksQ0FBQ0o7UUFDaENFLFlBQVlJLE9BQU8sQ0FBQ3ZDLENBQUFBO1lBQ2xCLE1BQU13QyxRQUFRUCxPQUFPLENBQUNqQyxLQUFLO1lBQzNCLElBQUksQ0FBQ3VELFVBQVUsQ0FBQ2YsTUFBTVcsSUFBSTtRQUM1QjtJQUNGO0lBRUFILEtBQUtRLElBQVksRUFBRUMsS0FBd0I7UUFDekMsTUFBTSxJQUFJbkgsTUFBTTtJQUNsQjtJQUVBb0gsVUFDRUYsSUFBWSxFQUNaQyxLQUF3QixFQUN4QnJILFFBQXFEO1FBRXJELElBQUksSUFBSSxDQUFDVSxPQUFPLEtBQUssTUFBTTtZQUN6QixNQUFNLElBQUlSLE1BQU07UUFDbEI7UUFFQSxJQUFJLElBQUksQ0FBQ1MsUUFBUSxFQUFFO1lBQ2pCLE1BQU0sSUFBSVQsTUFBTTtRQUNsQjtRQUVBLElBQUksT0FBT2tILFNBQVMsVUFBVTtZQUM1QixNQUFNLElBQUlHLFVBQVU7UUFDdEI7UUFFQSxJQUFJRixVQUFVLFFBQVEsQ0FBRUEsQ0FBQUEsaUJBQWlCNUkscUJBQUErSSxpQkFBaUIsR0FBRztZQUMzRCxNQUFNLElBQUlELFVBQVU7UUFDdEI7UUFFQSxJQUFJLE9BQU92SCxhQUFhLFlBQVk7WUFDbEMsTUFBTSxJQUFJdUgsVUFBVTtRQUN0QjtRQUVBLE1BQU1FLGlCQUFpQixJQUFBNUksYUFBQTZJLFFBQVEsRUFBQ047UUFDaEMsSUFBSUssbUJBQW1CLE1BQU07WUFDM0IsTUFBTSxJQUFJdkgsTUFBTSx5QkFBeUJrSCxLQUFJLEVBQUc7UUFDbEQ7UUFDQSxNQUFNTyxVQUFVLElBQUFqSixXQUFBa0osbUJBQW1CLEVBQUNIO1FBQ3BDLElBQUlFLFlBQVksTUFBTTtZQUNwQixNQUFNLElBQUl6SCxNQUFNLDRDQUE0Q2tILEtBQUksRUFBRztRQUNyRTtRQUVBLE1BQU1TLGdCQUFxQztZQUN6Q0MsMEJBQTBCQyxPQUFPQyxnQkFBZ0I7O1FBRW5ELElBQUksa0NBQWtDLElBQUksQ0FBQzNILE9BQU8sRUFBRTtZQUNsRHdILGNBQWNJLGdCQUFnQixHQUM1QixJQUFJLENBQUM1SCxPQUFPLENBQUMsK0JBQStCO1FBQ2hELE9BQU87WUFDTDs7O21EQUlBd0gsY0FBY0ksZ0JBQWdCLEdBQUdGLE9BQU9DLGdCQUFnQjtRQUMxRDtRQUNBLElBQUksaUNBQWlDLElBQUksQ0FBQzNILE9BQU8sRUFBRTtZQUNqRHdILGNBQWNLLFFBQVEsR0FBRztnQkFDdkJDLHNCQUFzQixJQUFJLENBQUM5SCxPQUFPLENBQUMsOEJBQThCOztRQUVyRTtRQUVBLE1BQU0rSCxtQkFBbUIsQ0FBQ0MsT0FBcUJqQjtZQUM3Q2tCLFFBQVFDLFFBQVEsQ0FBQyxJQUFNdkksU0FBU3FJLE9BQU9qQjtRQUN6QztRQUVBLE1BQU1vQixjQUFjO1lBQ2xCLElBQUlDO1lBQ0osSUFBSXBCLE1BQU1xQixTQUFTLElBQUk7Z0JBQ3JCLE1BQU1DLHNCQUFzQjNDLE9BQU80QyxNQUFNLENBQ3ZDZixlQUNBUixNQUFNd0IsWUFBWTtnQkFFcEJGLG9CQUFvQkcsV0FBVyxHQUM3QixJQUFJLENBQUN6SSxPQUFPLENBQUMsNkJBQTZCLEtBQUs7Z0JBQ2pEb0ksY0FBY3BLLE1BQU0wSyxrQkFBa0IsQ0FBQ0o7Z0JBQ3ZDRixZQUFZTyxFQUFFLENBQUMsb0JBQW9CLENBQUN0RztvQkFDbEM7bUZBRUFBLE9BQU9zRyxFQUFFLENBQUMsU0FBUyxDQUFDQzt3QkFDbEIsSUFBSSxDQUFDaEgsS0FBSyxDQUNSLG1EQUFtRGdILEVBQUVDLE9BQU87b0JBRWhFO2dCQUNGO1lBQ0YsT0FBTztnQkFDTFQsY0FBY3BLLE1BQU04SyxZQUFZLENBQUN0QjtZQUNuQztZQUVBWSxZQUFZVyxVQUFVLENBQUMsR0FBRy9KO1lBQzFCLElBQUksQ0FBQ2dLLGNBQWMsQ0FBQ1o7WUFDcEIsT0FBT0E7UUFDVDtRQUVBLE1BQU1hLG1CQUFtQixDQUN2QkMsYUFDQUMsU0FDQUM7WUFFQSxJQUFJRixZQUFZckQsTUFBTSxLQUFLLEdBQUc7Z0JBQzVCLE9BQU93RCxRQUFRQyxPQUFPLENBQUM7b0JBQUV2QyxNQUFNb0M7b0JBQVNJLE9BQU9IO2dCQUFhO1lBQzlEO1lBQ0EsT0FBT0MsUUFBUUcsR0FBRyxDQUNoQk4sWUFBWU8sR0FBRyxDQUFDQyxDQUFBQTtnQkFDZCxJQUFJLENBQUM5SCxLQUFLLENBQ1Isd0JBQXdCLElBQUFyRCxxQkFBQW9MLHlCQUF5QixFQUFDRDtnQkFFcEQsSUFBSUU7Z0JBQ0osSUFBSSxJQUFBckwscUJBQUFzTCxzQkFBc0IsRUFBQ0gsVUFBVTtvQkFDbkNFLE9BQU87d0JBQ0xFLE1BQU9KLFFBQWlDSSxJQUFJO3dCQUM1Qy9DLE1BQU1vQzs7Z0JBRVYsT0FBTztvQkFDTFMsT0FBT0Y7Z0JBQ1Q7Z0JBRUEsTUFBTXRCLGNBQWNEO2dCQUNwQixPQUFPLElBQUlrQixRQUF3QixDQUFDQyxTQUFTUztvQkFDM0MsTUFBTUMsVUFBVSxDQUFDQzt3QkFDZixJQUFJLENBQUNySSxLQUFLLENBQ1Isb0JBQ0UsSUFBQXJELHFCQUFBb0wseUJBQXlCLEVBQUNELFdBQzFCLGlCQUNBTyxJQUFJcEIsT0FBTzt3QkFFZlMsUUFBUVc7b0JBQ1Y7b0JBRUE3QixZQUFZOEIsSUFBSSxDQUFDLFNBQVNGO29CQUUxQjVCLFlBQVkrQixNQUFNLENBQUNQLE1BQU07d0JBQ3ZCLElBQUksSUFBSSxDQUFDdEosUUFBUSxFQUFFOzRCQUNqQjhILFlBQVlnQyxLQUFLOzRCQUNqQmQsUUFBUSxJQUFJekosTUFBTTs0QkFDbEI7d0JBQ0Y7d0JBQ0EsTUFBTXdLLGVBQWVqQyxZQUFZc0IsT0FBTzt3QkFDeEMsSUFBSVk7d0JBQ0osSUFBSSxPQUFPRCxpQkFBaUIsVUFBVTs0QkFDcENDLHlCQUF5QjtnQ0FDdkI1RCxNQUFNMkQ7O3dCQUVWLE9BQU87NEJBQ0xDLHlCQUF5QjtnQ0FDdkJSLE1BQU1PLGFBQWFYLE9BQU87Z0NBQzFCM0MsTUFBTXNELGFBQWF0RCxJQUFJOzt3QkFFM0I7d0JBRUEsTUFBTS9GLGNBQWMsSUFBQXZDLFdBQUE4TCxzQkFBc0IsRUFDeEMsSUFBQWhNLHFCQUFBb0wseUJBQXlCLEVBQUNXLHlCQUMxQjs0QkFDRSxPQUFPO2dDQUNMN0gsY0FBYzZIO2dDQUNkaEksZUFBZTtnQ0FDZnNCLFVBQVU7Z0NBQ1ZDLFlBQVk7Z0NBQ1pDLGdCQUFnQjtnQ0FDaEJHLGtCQUFrQjtnQ0FDbEJFLGVBQWU7Z0NBQ2ZFLGNBQWM7Z0NBQ2RDLGtCQUFrQjtnQ0FDbEJDLGdCQUFnQjtnQ0FDaEJDLGlDQUFpQztnQ0FDakNDLGtDQUFrQztnQ0FDbENFLDBCQUEwQjtnQ0FDMUJDLDhCQUE4QjtnQ0FDOUJDLHdCQUF3QjtnQ0FDeEJHLHlCQUF5Qjs7d0JBRTdCLEdBQ0EsSUFBSSxDQUFDeEUsZUFBZTt3QkFFdEIsSUFBSSxJQUFJLENBQUNBLGVBQWUsRUFBRTs0QkFDeEIsSUFBSSxDQUFDSyx1QkFBdUIsQ0FBQzJKLFFBQVEsQ0FBQ3hKO3dCQUN4Qzt3QkFDQSxJQUFJLENBQUNmLGVBQWUsQ0FBQ3dLLElBQUksQ0FBQzs0QkFDeEJDLFFBQVF0Qzs0QkFDUnBILGFBQWFBOzt3QkFFZixJQUFJLENBQUNZLEtBQUssQ0FDUix3QkFDRSxJQUFBckQscUJBQUFvTCx5QkFBeUIsRUFBQ1c7d0JBRTlCaEIsUUFDRSxVQUFVZ0IseUJBQ05BLHVCQUF1QnZELElBQUksR0FDM0JvQzt3QkFFTmYsWUFBWXVDLGNBQWMsQ0FBQyxTQUFTWDtvQkFDdEM7Z0JBQ0Y7WUFDRixJQUNBWSxJQUFJLENBQUNDLENBQUFBO2dCQUNMLElBQUl0QixRQUFRO2dCQUNaLEtBQUssTUFBTXVCLFVBQVVELFFBQVM7b0JBQzVCLElBQUksT0FBT0MsV0FBVyxVQUFVO3dCQUM5QnZCLFNBQVM7d0JBQ1QsSUFBSXVCLFdBQVczQixTQUFTOzRCQUN0QixNQUFNLElBQUl0SixNQUNSO3dCQUVKO29CQUNGO2dCQUNGO2dCQUNBLE9BQU87b0JBQ0xrSCxNQUFNb0M7b0JBQ05JLE9BQU9BLFFBQVFIOztZQUVuQjtRQUNGO1FBRUEsTUFBTTJCLG1CQUFtQixDQUN2QjdCO1lBRUEsSUFBSUEsWUFBWXJELE1BQU0sS0FBSyxHQUFHO2dCQUM1QixPQUFPd0QsUUFBUUMsT0FBTyxDQUFhO29CQUFFdkMsTUFBTTtvQkFBR3dDLE9BQU87Z0JBQUM7WUFDeEQ7WUFDQSxNQUFNRyxVQUFVUixXQUFXLENBQUMsRUFBRTtZQUM5QixNQUFNZCxjQUFjRDtZQUNwQixPQUFPLElBQUlrQixRQUFvQixDQUFDQyxTQUFTUztnQkFDdkMsTUFBTUMsVUFBVSxDQUFDQztvQkFDZixJQUFJLENBQUNySSxLQUFLLENBQ1Isb0JBQ0UsSUFBQXJELHFCQUFBb0wseUJBQXlCLEVBQUNELFdBQzFCLGlCQUNBTyxJQUFJcEIsT0FBTztvQkFFZlMsUUFBUXlCLGlCQUFpQjdCLFlBQVk4QixLQUFLLENBQUM7Z0JBQzdDO2dCQUVBNUMsWUFBWThCLElBQUksQ0FBQyxTQUFTRjtnQkFFMUI1QixZQUFZK0IsTUFBTSxDQUFDVCxTQUFTO29CQUMxQixJQUFJLElBQUksQ0FBQ3BKLFFBQVEsRUFBRTt3QkFDakI4SCxZQUFZZ0MsS0FBSzt3QkFDakJkLFFBQVE7NEJBQUN2QyxNQUFNOzRCQUFHd0MsT0FBTzt3QkFBQzt3QkFDMUI7b0JBQ0Y7b0JBQ0EsTUFBTWMsZUFBZWpDLFlBQVlzQixPQUFPO29CQUN4QyxNQUFNWSx5QkFBNEM7d0JBQ2hEUixNQUFNTyxhQUFhWCxPQUFPO3dCQUMxQjNDLE1BQU1zRCxhQUFhdEQsSUFBSTs7b0JBRXpCLE1BQU0vRixjQUFjLElBQUF2QyxXQUFBOEwsc0JBQXNCLEVBQ3hDLElBQUFoTSxxQkFBQW9MLHlCQUF5QixFQUFDVyx5QkFDMUI7d0JBQ0UsT0FBTzs0QkFDTDdILGNBQWM2SDs0QkFDZGhJLGVBQWU7NEJBQ2ZzQixVQUFVOzRCQUNWQyxZQUFZOzRCQUNaQyxnQkFBZ0I7NEJBQ2hCRyxrQkFBa0I7NEJBQ2xCRSxlQUFlOzRCQUNmRSxjQUFjOzRCQUNkQyxrQkFBa0I7NEJBQ2xCQyxnQkFBZ0I7NEJBQ2hCQyxpQ0FBaUM7NEJBQ2pDQyxrQ0FBa0M7NEJBQ2xDRSwwQkFBMEI7NEJBQzFCQyw4QkFBOEI7NEJBQzlCQyx3QkFBd0I7NEJBQ3hCRyx5QkFBeUI7O29CQUU3QixHQUNBLElBQUksQ0FBQ3hFLGVBQWU7b0JBRXRCLElBQUksSUFBSSxDQUFDQSxlQUFlLEVBQUU7d0JBQ3hCLElBQUksQ0FBQ0ssdUJBQXVCLENBQUMySixRQUFRLENBQUN4SjtvQkFDeEM7b0JBQ0EsSUFBSSxDQUFDZixlQUFlLENBQUN3SyxJQUFJLENBQUM7d0JBQ3hCQyxRQUFRdEM7d0JBQ1JwSCxhQUFhQTs7b0JBRWYsSUFBSSxDQUFDWSxLQUFLLENBQ1Isd0JBQ0UsSUFBQXJELHFCQUFBb0wseUJBQXlCLEVBQUNXO29CQUU5QmhCLFFBQVFMLGlCQUFpQkMsWUFBWThCLEtBQUssQ0FBQyxJQUFJWCxhQUFhdEQsSUFBSSxFQUFFO29CQUNsRXFCLFlBQVl1QyxjQUFjLENBQUMsU0FBU1g7Z0JBQ3RDO1lBQ0Y7UUFDRjtRQUVBLE1BQU1pQixtQkFBcUM7WUFDekNDLHdCQUF3QixDQUN0QmhDLGFBQ0FpQyxlQUNBQztnQkFFQSxpRUFBaUU7Z0JBQ2pFSCxpQkFBaUJDLHNCQUFzQixHQUFHLEtBQU87Z0JBQ2pELElBQUksSUFBSSxDQUFDNUssUUFBUSxFQUFFO29CQUNqQnlILGlCQUNFLElBQUlsSSxNQUFNLDZDQUE2QyxHQUN2RDtnQkFFSjtnQkFDQSxJQUFJcUosWUFBWXJELE1BQU0sS0FBSyxHQUFHO29CQUM1QmtDLGlCQUNFLElBQUlsSSxNQUFNLGtDQUFrQ2tILEtBQUksQ0FBRSxHQUNsRDtvQkFFRjtnQkFDRjtnQkFDQSxJQUFJc0U7Z0JBQ0osSUFBSSxJQUFBOU0scUJBQUFzTCxzQkFBc0IsRUFBQ1gsV0FBVyxDQUFDLEVBQUUsR0FBRztvQkFDMUMsSUFBSUEsV0FBVyxDQUFDLEVBQUUsQ0FBQ25DLElBQUksS0FBSyxHQUFHO3dCQUM3QnNFLG9CQUFvQk4saUJBQWlCN0I7b0JBQ3ZDLE9BQU87d0JBQ0xtQyxvQkFBb0JwQyxpQkFDbEJDLGFBQ0FBLFdBQVcsQ0FBQyxFQUFFLENBQUNuQyxJQUFJLEVBQ25CO29CQUVKO2dCQUNGLE9BQU87b0JBQ0wsdURBQXVEO29CQUN2RHNFLG9CQUFvQnBDLGlCQUFpQkMsYUFBYSxHQUFHO2dCQUN2RDtnQkFDQW1DLGtCQUFrQlQsSUFBSSxDQUNwQlUsQ0FBQUE7b0JBQ0UsSUFBSUEsV0FBVy9CLEtBQUssS0FBSyxHQUFHO3dCQUMxQixNQUFNZ0MsY0FBYyxpQ0FBaUNyQyxZQUFZckQsTUFBTSxXQUFXO3dCQUNsRnZILFFBQVFrTixHQUFHLENBQUN0TixZQUFBaUgsWUFBWSxDQUFDc0csS0FBSyxFQUFFRjt3QkFDaEN4RCxpQkFBaUIsSUFBSWxJLE1BQU0wTCxjQUFjO29CQUMzQyxPQUFPO3dCQUNMLElBQUlELFdBQVcvQixLQUFLLEdBQUdMLFlBQVlyRCxNQUFNLEVBQUU7NEJBQ3pDdkgsUUFBUWtOLEdBQUcsQ0FDVHROLFlBQUFpSCxZQUFZLENBQUN1RyxJQUFJLEVBQ2pCLGdCQUFnQkosV0FBVy9CLEtBQUssaUNBQWlDTCxZQUFZckQsTUFBTSxXQUFXO3dCQUVsRzt3QkFDQWtDLGlCQUFpQixNQUFNdUQsV0FBV3ZFLElBQUk7b0JBQ3hDO2dCQUNGLEdBQ0FpQixDQUFBQTtvQkFDRSxNQUFNdUQsY0FBYyxpQ0FBaUNyQyxZQUFZckQsTUFBTSxXQUFXO29CQUNsRnZILFFBQVFrTixHQUFHLENBQUN0TixZQUFBaUgsWUFBWSxDQUFDc0csS0FBSyxFQUFFRjtvQkFDaEN4RCxpQkFBaUIsSUFBSWxJLE1BQU0wTCxjQUFjO2dCQUMzQztZQUVKO1lBQ0F2QixTQUFTaEMsQ0FBQUE7Z0JBQ1BELGlCQUFpQixJQUFJbEksTUFBTW1JLE1BQU0xSSxPQUFPLEdBQUc7WUFDN0M7O1FBR0YsTUFBTXFNLFdBQVcsSUFBQXROLFdBQUF1TixjQUFjLEVBQUN0RSxTQUFTMkQsa0JBQWtCLElBQUksQ0FBQ2pMLE9BQU87UUFDdkUyTCxTQUFTRSxnQkFBZ0I7SUFDM0I7SUFFQUMsZ0JBQWE7UUFDWCwyQ0FBMkM7UUFFM0MsS0FBSyxNQUFNLEVBQUVwQixRQUFRdEMsV0FBVyxFQUFFcEgsYUFBYStLLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FDekQ5TCxlQUFlLENBQUU7WUFDbEIsSUFBSW1JLFlBQVk0RCxTQUFTLEVBQUU7Z0JBQ3pCNUQsWUFBWWdDLEtBQUssQ0FBQztvQkFDaEIsSUFBSSxJQUFJLENBQUM1SixlQUFlLEVBQUU7d0JBQ3hCLElBQUksQ0FBQ0ssdUJBQXVCLENBQUNvTCxVQUFVLENBQUNGO3dCQUN4QyxJQUFBdE4sV0FBQXlOLHFCQUFxQixFQUFDSDtvQkFDeEI7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDMUwsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFFaEIsd0VBQXdFO1FBQ3hFLHFFQUFxRTtRQUNyRSxJQUFJLENBQUNGLFFBQVEsQ0FBQzBGLE9BQU8sQ0FBQyxDQUFDcUcsY0FBY2xLO1lBQ25DLGdFQUFnRTtZQUNoRSxnREFBZ0Q7WUFDaEQsOERBQThEO1lBQzlEQSxRQUFRbUssT0FBTyxDQUFDcE8sTUFBTWMsU0FBUyxDQUFDdU4sY0FBcUI7UUFDdkQ7UUFDQSxJQUFJLENBQUNqTSxRQUFRLENBQUNrTSxLQUFLO1FBQ25CLElBQUksSUFBSSxDQUFDOUwsZUFBZSxFQUFFO1lBQ3hCLElBQUEvQixXQUFBeU4scUJBQXFCLEVBQUMsSUFBSSxDQUFDbEwsV0FBVztRQUN4QztJQUNGO0lBRUF5RixTQUNFbEQsSUFBWSxFQUNaZ0osT0FBOEMsRUFDOUNDLFNBQWtDLEVBQ2xDQyxXQUFxQyxFQUNyQ0MsSUFBWTtRQUVaLElBQUksSUFBSSxDQUFDeE0sUUFBUSxDQUFDeU0sR0FBRyxDQUFDcEosT0FBTztZQUMzQixPQUFPO1FBQ1Q7UUFFQSxJQUFJLENBQUNyRCxRQUFRLENBQUMwTSxHQUFHLENBQUNySixNQUFNO1lBQ3RCc0osTUFBTU47WUFDTkM7WUFDQUM7WUFDQUM7WUFDQWhHLE1BQU1uRDs7UUFFUixPQUFPO0lBQ1Q7SUFFQXVELFdBQVd2RCxJQUFZO1FBQ3JCLE9BQU8sSUFBSSxDQUFDckQsUUFBUSxDQUFDNE0sTUFBTSxDQUFDdko7SUFDOUI7SUFFQXdKLFFBQUs7UUFDSCxJQUNFLElBQUksQ0FBQzlNLGVBQWUsQ0FBQzRGLE1BQU0sS0FBSyxLQUNoQyxJQUFJLENBQUM1RixlQUFlLENBQUMrTSxLQUFLLENBQ3hCLENBQUMsRUFBRXRDLFFBQVF0QyxXQUFXLEVBQUUsR0FBS0EsWUFBWTRELFNBQVMsS0FBSyxPQUV6RDtZQUNBLE1BQU0sSUFBSW5NLE1BQU07UUFDbEI7UUFFQSxJQUFJLElBQUksQ0FBQ1EsT0FBTyxLQUFLLE1BQU07WUFDekIsTUFBTSxJQUFJUixNQUFNO1FBQ2xCO1FBQ0EsSUFBSSxJQUFJLENBQUNXLGVBQWUsRUFBRTtZQUN4QixJQUFJLENBQUNDLGFBQWEsQ0FBQ1UsUUFBUSxDQUFDLFdBQVc7UUFDekM7UUFDQSxJQUFJLENBQUNkLE9BQU8sR0FBRztJQUNqQjtJQUVBNE0sWUFBWXROLFFBQWlDO1FBQzNDLE1BQU11TixrQkFBa0IsQ0FBQ2xGO1lBQ3ZCLElBQUksSUFBSSxDQUFDeEgsZUFBZSxFQUFFO2dCQUN4QixJQUFBL0IsV0FBQXlOLHFCQUFxQixFQUFDLElBQUksQ0FBQ2xMLFdBQVc7WUFDeEM7WUFDQXJCLFNBQVNxSTtRQUNYO1FBQ0EsSUFBSW1GLGdCQUFnQjtRQUVwQixTQUFTQztZQUNQRDtZQUVBLElBQUlBLGtCQUFrQixHQUFHO2dCQUN2QkQ7WUFDRjtRQUNGO1FBRUEsaUNBQWlDO1FBQ2pDLElBQUksQ0FBQzdNLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBRWhCLEtBQUssTUFBTSxFQUFFb0ssUUFBUXRDLFdBQVcsRUFBRXBILGFBQWErSyxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQ3pEOUwsZUFBZSxDQUFFO1lBQ2xCLElBQUltSSxZQUFZNEQsU0FBUyxFQUFFO2dCQUN6Qm1CO2dCQUNBL0UsWUFBWWdDLEtBQUssQ0FBQztvQkFDaEIsSUFBSSxJQUFJLENBQUM1SixlQUFlLEVBQUU7d0JBQ3hCLElBQUksQ0FBQ0ssdUJBQXVCLENBQUNvTCxVQUFVLENBQUNGO3dCQUN4QyxJQUFBdE4sV0FBQXlOLHFCQUFxQixFQUFDSDtvQkFDeEI7b0JBQ0FxQjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxJQUFJLENBQUNoTixRQUFRLENBQUMwRixPQUFPLENBQUMsQ0FBQ3FHLGNBQWNsSztZQUNuQyxJQUFJLENBQUNBLFFBQVFvTCxNQUFNLEVBQUU7Z0JBQ25CRixpQkFBaUI7Z0JBQ2pCbEwsUUFBUW1JLEtBQUssQ0FBQ2dEO1lBQ2hCO1FBQ0Y7UUFDQSxJQUFJRCxrQkFBa0IsR0FBRztZQUN2QkQ7UUFDRjtJQUNGO0lBRUFJLGVBQVk7UUFDVixNQUFNLElBQUl6TixNQUFNO0lBQ2xCO0lBRUE7Ozs7UUFLQTBOLGlCQUFjO1FBQ1osT0FBTyxJQUFJLENBQUN2TSxXQUFXO0lBQ3pCO0lBRVF3TSxtQkFDTkMsTUFBK0IsRUFDL0JDLE9BQWtDO1FBRWxDLE1BQU1DLGNBQWNELE9BQU8sQ0FBQzFQLE1BQU1jLFNBQVMsQ0FBQzhPLHlCQUF5QixDQUFDO1FBRXRFLElBQ0UsT0FBT0QsZ0JBQWdCLFlBQ3ZCLENBQUNBLFlBQVlFLFVBQVUsQ0FBQyxxQkFDeEI7WUFDQUosT0FBT0ssT0FBTyxDQUNaO2dCQUNFLENBQUM5UCxNQUFNYyxTQUFTLENBQUNpUCxtQkFBbUIsQ0FBQyxFQUNuQy9QLE1BQU1jLFNBQVMsQ0FBQ2tQLGtDQUFrQztlQUV0RDtnQkFBRUMsV0FBVztZQUFJO1lBRW5CLE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVDtJQUVRQyxpQkFBaUJ4SCxJQUFZO1FBQ25DLElBQUksQ0FBQzlFLEtBQUssQ0FDUiw2QkFDRThFLE9BQ0EsaUJBQ0EsSUFBSSxDQUFDbkcsbUJBQW1CO1FBRzVCLE1BQU1nTSxVQUFVLElBQUksQ0FBQ3JNLFFBQVEsQ0FBQ2lDLEdBQUcsQ0FBQ3VFO1FBRWxDLElBQUk2RixZQUFZbEcsV0FBVztZQUN6QixJQUFJLENBQUN6RSxLQUFLLENBQ1Isc0NBQ0U4RSxPQUNBO1lBRUosT0FBTztRQUNUO1FBRUEsT0FBTzZGO0lBQ1Q7SUFFUTRCLGtCQUNObEUsR0FBTSxFQUNOd0QsTUFBK0IsRUFDL0JXLHNCQUFrRCxJQUFJO1FBRXRELE1BQU0xTyxPQUFPLElBQUl2QixjQUFBa1EscUJBQXFCLENBQUNaLFFBQVEsTUFBTyxJQUFJLENBQUN6TixPQUFPO1FBRWxFLElBQUlpSyxJQUFJOUssSUFBSSxLQUFLa0gsV0FBVztZQUMxQjRELElBQUk5SyxJQUFJLEdBQUdqQixZQUFBa0IsTUFBTSxDQUFDa1AsUUFBUTtRQUM1QjtRQUVBLElBQUksSUFBSSxDQUFDOU4sZUFBZSxFQUFFO1lBQ3hCLElBQUksQ0FBQ0csV0FBVyxDQUFDNE4sYUFBYTtZQUM5Qkgsd0JBQW1CLFFBQW5CQSx3QkFBbUIsa0JBQW5CQSxvQkFBcUJySyxhQUFhLENBQUN3SyxhQUFhO1FBQ2xEO1FBRUE3TyxLQUFLOE8sU0FBUyxDQUFDdkU7SUFDakI7SUFFUXdFLGlCQUNOaEIsTUFBK0IsRUFDL0JDLE9BQWtDO1FBRWxDLE1BQU1VLHNCQUFzQixJQUFJLENBQUNoTyxRQUFRLENBQUMrQixHQUFHLENBQzNDc0wsT0FBT3hMLE9BQW1DO1FBRzVDLElBQUksQ0FBQ3RCLFdBQVcsQ0FBQytOLGNBQWM7UUFDL0JOLHdCQUFtQixRQUFuQkEsd0JBQW1CLGtCQUFuQkEsb0JBQXFCckssYUFBYSxDQUFDMkssY0FBYztRQUVqRCxJQUFJLENBQUMsSUFBSSxDQUFDbEIsa0JBQWtCLENBQUNDLFFBQVFDLFVBQVU7WUFDN0MsSUFBSSxDQUFDL00sV0FBVyxDQUFDNE4sYUFBYTtZQUM5Qkgsd0JBQW1CLFFBQW5CQSx3QkFBbUIsa0JBQW5CQSxvQkFBcUJySyxhQUFhLENBQUN3SyxhQUFhO1lBQ2hEO1FBQ0Y7UUFFQSxNQUFNN0gsT0FBT2dILE9BQU8sQ0FBQzdPLGtCQUE0QjtRQUVqRCxNQUFNME4sVUFBVSxJQUFJLENBQUMyQixnQkFBZ0IsQ0FBQ3hIO1FBQ3RDLElBQUksQ0FBQzZGLFNBQVM7WUFDWixJQUFJLENBQUM0QixpQkFBaUIsQ0FDcEJsUCwrQkFBK0J5SCxPQUMvQitHLFFBQ0FXO1lBRUY7UUFDRjtRQUVBLE1BQU0xTyxPQUFPLElBQUl2QixjQUFBa1EscUJBQXFCLENBQUNaLFFBQVFsQixTQUFTLElBQUksQ0FBQ3ZNLE9BQU87UUFFcEVOLEtBQUt3SyxJQUFJLENBQUMsV0FBVyxDQUFDL0s7WUFDcEIsSUFBSUEsU0FBU2pCLFlBQUFrQixNQUFNLENBQUN1UCxFQUFFLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQ2hPLFdBQVcsQ0FBQ2lPLGdCQUFnQjtZQUNuQyxPQUFPO2dCQUNMLElBQUksQ0FBQ2pPLFdBQVcsQ0FBQzROLGFBQWE7WUFDaEM7UUFDRjtRQUVBLElBQUlILHFCQUFxQjtZQUN2QjFPLEtBQUt3SyxJQUFJLENBQUMsYUFBYSxDQUFDMUQ7Z0JBQ3RCLElBQUlBLFNBQVM7b0JBQ1g0SCxvQkFBb0JySyxhQUFhLENBQUM2SyxnQkFBZ0I7Z0JBQ3BELE9BQU87b0JBQ0xSLG9CQUFvQnJLLGFBQWEsQ0FBQ3dLLGFBQWE7Z0JBQ2pEO1lBQ0Y7WUFDQTdPLEtBQUtpSixFQUFFLENBQUMsZUFBZTtnQkFDckJ5RixvQkFBb0IvSixZQUFZLElBQUk7Z0JBQ3BDK0osb0JBQW9Cekosd0JBQXdCLEdBQUcsSUFBSWtLO1lBQ3JEO1lBQ0FuUCxLQUFLaUosRUFBRSxDQUFDLGtCQUFrQjtnQkFDeEJ5RixvQkFBb0I5SixnQkFBZ0IsSUFBSTtnQkFDeEM4SixvQkFBb0J4Siw0QkFBNEIsR0FBRyxJQUFJaUs7WUFDekQ7UUFDRjtRQUVBLElBQUksQ0FBQyxJQUFJLENBQUNDLGtCQUFrQixDQUFDcFAsTUFBTTZNLFNBQVNtQixVQUFVO1lBQ3BELElBQUksQ0FBQy9NLFdBQVcsQ0FBQzROLGFBQWE7WUFDOUJILHdCQUFtQixRQUFuQkEsd0JBQW1CLGtCQUFuQkEsb0JBQXFCckssYUFBYSxDQUFDd0ssYUFBYTtZQUVoRDdPLEtBQUs4TyxTQUFTLENBQUM7Z0JBQ2JyUCxNQUFNakIsWUFBQWtCLE1BQU0sQ0FBQ2tQLFFBQVE7Z0JBQ3JCaFAsU0FBUyx5QkFBeUJpTixRQUFRRyxJQUFJLEVBQUU7O1FBRXBEO0lBQ0Y7SUFFUXFDLGVBQ050QixNQUErQixFQUMvQkMsT0FBa0M7UUFFbEMsSUFBSSxJQUFJLENBQUNGLGtCQUFrQixDQUFDQyxRQUFRQyxhQUFhLE1BQU07WUFDckQ7UUFDRjtRQUVBLE1BQU1oSCxPQUFPZ0gsT0FBTyxDQUFDN08sa0JBQTRCO1FBRWpELE1BQU0wTixVQUFVLElBQUksQ0FBQzJCLGdCQUFnQixDQUFDeEg7UUFDdEMsSUFBSSxDQUFDNkYsU0FBUztZQUNaLElBQUksQ0FBQzRCLGlCQUFpQixDQUNwQmxQLCtCQUErQnlILE9BQy9CK0csUUFDQTtZQUVGO1FBQ0Y7UUFFQSxNQUFNL04sT0FBTyxJQUFJdkIsY0FBQWtRLHFCQUFxQixDQUFDWixRQUFRbEIsU0FBUyxJQUFJLENBQUN2TSxPQUFPO1FBQ3BFLElBQUksQ0FBQyxJQUFJLENBQUM4TyxrQkFBa0IsQ0FBQ3BQLE1BQU02TSxTQUFTbUIsVUFBVTtZQUNwRGhPLEtBQUs4TyxTQUFTLENBQUM7Z0JBQ2JyUCxNQUFNakIsWUFBQWtCLE1BQU0sQ0FBQ2tQLFFBQVE7Z0JBQ3JCaFAsU0FBUyx5QkFBeUJpTixRQUFRRyxJQUFJLEVBQUU7O1FBRXBEO0lBQ0Y7SUFFUW9DLG1CQUNOcFAsSUFBcUMsRUFDckM2TSxPQUEwQixFQUMxQm1CLE9BQWtDOztRQUVsQyxNQUFNc0IsV0FBV3RQLEtBQUt1UCxlQUFlLENBQUN2QjtRQUN0QyxNQUFNd0IsV0FDSixDQUFBN04sS0FBQzJOLFNBQVM3TSxHQUFHLENBQUMsZ0JBQWdCLENBQUMsRUFBeUIsY0FBQWQsT0FBQSxTQUFBQSxLQUFJO1FBQzlEMk4sU0FBU0csTUFBTSxDQUFDO1FBRWhCLE1BQU0sRUFBRXpDLElBQUksRUFBRSxHQUFHSDtRQUNqQixJQUFJRyxTQUFTLFNBQVM7WUFDcEIwQyxZQUFZMVAsTUFBTTZNLFNBQWdDeUMsVUFBVUU7UUFDOUQsT0FBTyxJQUFJeEMsU0FBUyxnQkFBZ0I7WUFDbEMyQyxzQkFDRTNQLE1BQ0E2TSxTQUNBeUMsVUFDQUU7UUFFSixPQUFPLElBQUl4QyxTQUFTLGdCQUFnQjtZQUNsQzRDLHNCQUNFNVAsTUFDQTZNLFNBQ0F5QyxVQUNBRTtRQUVKLE9BQU8sSUFBSXhDLFNBQVMsUUFBUTtZQUMxQjZDLG9CQUNFN1AsTUFDQTZNLFNBQ0F5QyxVQUNBRTtRQUVKLE9BQU87WUFDTCxPQUFPO1FBQ1Q7UUFFQSxPQUFPO0lBQ1Q7SUFFUWxHLGVBQ05aLFdBQXdEO1FBRXhELElBQUlBLGdCQUFnQixNQUFNO1lBQ3hCO1FBQ0Y7UUFFQSxNQUFNb0gsZ0JBQWdCcEgsWUFBWXNCLE9BQU87UUFDekMsSUFBSW5KLHNCQUFzQjtRQUMxQixJQUFJaVAsZUFBZTtZQUNqQixJQUFJLE9BQU9BLGtCQUFrQixVQUFVO2dCQUNyQ2pQLHNCQUFzQmlQO1lBQ3hCLE9BQU87Z0JBQ0xqUCxzQkFBc0JpUCxjQUFjOUYsT0FBTyxHQUFHLE1BQU04RixjQUFjekksSUFBSTtZQUN4RTtRQUNGO1FBQ0EsSUFBSSxDQUFDeEcsbUJBQW1CLEdBQUdBO1FBRTNCLE1BQU1nTSxVQUFVLElBQUksQ0FBQy9MLGVBQWUsR0FDaEMsSUFBSSxDQUFDaU8sZ0JBQWdCLEdBQ3JCLElBQUksQ0FBQ00sY0FBYztRQUV2QjNHLFlBQVlPLEVBQUUsQ0FBQyxVQUFVNEQsUUFBUWhHLElBQUksQ0FBQyxJQUFJO1FBQzFDNkIsWUFBWU8sRUFBRSxDQUFDLFdBQVcxRyxDQUFBQTs7WUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQzVCLE9BQU8sRUFBRTtnQkFDakI0QixRQUFRbUssT0FBTztnQkFDZjtZQUNGO1lBRUEsTUFBTXBMLGNBQWMsSUFBQXZDLFdBQUE4TCxzQkFBc0IsRUFDeEMsQ0FBQWxKLEtBQUFZLFFBQVFJLE1BQU0sQ0FBQ0MsYUFBYSxjQUFBakIsT0FBQSxTQUFBQSxLQUFJLFdBQ2hDLElBQUksQ0FBQ1csNEJBQTRCLENBQUNDLFVBQ2xDLElBQUksQ0FBQ3pCLGVBQWU7WUFHdEIsTUFBTTROLHNCQUEyQztnQkFDL0NyQyxLQUFLL0s7Z0JBQ0wrQyxlQUFlLElBQUl0RixXQUFBbUMsbUJBQW1CO2dCQUN0Q3lELGNBQWM7Z0JBQ2RDLGtCQUFrQjtnQkFDbEJLLDBCQUEwQjtnQkFDMUJDLDhCQUE4Qjs7WUFHaEMsSUFBSSxDQUFDeEUsUUFBUSxDQUFDd00sR0FBRyxDQUFDM0ssU0FBU21NO1lBQzNCLE1BQU1xQixnQkFBZ0J4TixRQUFRSSxNQUFNLENBQUNDLGFBQWE7WUFDbEQsSUFBSSxJQUFJLENBQUM5QixlQUFlLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQ0MsYUFBYSxDQUFDVSxRQUFRLENBQ3pCLFdBQ0Esc0NBQXNDc087Z0JBRXhDLElBQUksQ0FBQzFPLHNCQUFzQixDQUFDeUosUUFBUSxDQUFDeEo7WUFDdkM7WUFDQSxJQUFJME8scUJBQTRDO1lBQ2hELElBQUlDLDBCQUFpRDtZQUNyRCxJQUFJQyx3QkFBd0I7WUFDNUIsSUFBSSxJQUFJLENBQUN4TyxrQkFBa0IsS0FBSzFDLDZCQUE2QjtnQkFDM0QsOENBQThDO2dCQUM5QyxNQUFNbVIsa0JBQWtCLElBQUksQ0FBQ3pPLGtCQUFrQixHQUFHO2dCQUNsRCxNQUFNME8sU0FBU0MsS0FBS0MsTUFBTSxLQUFLSCxrQkFBa0IsSUFBSUE7Z0JBQ3JESCxxQkFBcUIsQ0FBQWpPLEtBQUEsQ0FBQUYsS0FBQXdILFdBQVc7O29CQUM5QjZHLHdCQUF3QjtvQkFDeEIsSUFBSSxJQUFJLENBQUNwUCxlQUFlLEVBQUU7d0JBQ3hCLElBQUksQ0FBQ0MsYUFBYSxDQUFDVSxRQUFRLENBQ3pCLFdBQ0EsbURBQW1Ec087b0JBRXZEO29CQUNBLElBQUk7d0JBQ0Z4TixRQUFRZ08sTUFBTSxDQUNaalMsTUFBTWMsU0FBUyxDQUFDb1IsZ0JBQWdCLEVBQ2hDLENBQUUsTUFBSyxLQUNQQyxPQUFPQyxJQUFJLENBQUM7b0JBRWhCLEVBQUUsT0FBT3hILEdBQUc7d0JBQ1YsaUVBQWlFO3dCQUNqRTNHLFFBQVFtSyxPQUFPO3dCQUNmO29CQUNGO29CQUNBbkssUUFBUW1JLEtBQUs7b0JBQ2I7a0RBRUEsSUFBSSxJQUFJLENBQUM5SSx1QkFBdUIsS0FBSzVDLDZCQUE2Qjt3QkFDaEVpUiwwQkFBMEIsQ0FBQXBPLEtBQUEsQ0FBQUYsS0FBQTBILFdBQVc7NEJBQ25DOUcsUUFBUW1LLE9BQU87d0JBQ2pCLEdBQUcsSUFBSSxDQUFDOUssdUJBQXVCLEdBQUUrTyxLQUFLLGNBQUE5TyxPQUFBLGtCQUFBQSxHQUFBN0IsSUFBQSxDQUFBMkI7b0JBQ3hDO2dCQUNGLEdBQUcsSUFBSSxDQUFDRCxrQkFBa0IsR0FBRzBPLE9BQU0sRUFBRU8sS0FBSyxjQUFBNU8sT0FBQSxrQkFBQUEsR0FBQS9CLElBQUEsQ0FBQTZCO1lBQzVDO1lBQ0EsTUFBTStPLHFCQUE0QyxDQUFBQyxLQUFBLENBQUE1TyxLQUFBNk8sWUFBWTs7Z0JBQzVELE1BQU1DLGVBQWUsQ0FBQWxQLEtBQUEsQ0FBQUYsS0FBQTBILFdBQVc7b0JBQzlCNkcsd0JBQXdCO29CQUN4QixJQUFJLElBQUksQ0FBQ3BQLGVBQWUsRUFBRTt3QkFDeEIsSUFBSSxDQUFDQyxhQUFhLENBQUNVLFFBQVEsQ0FDekIsV0FDQSxrREFBa0RzTztvQkFFdEQ7b0JBQ0F4TixRQUFRbUksS0FBSztnQkFDZixHQUFHLElBQUksQ0FBQzFJLGtCQUFrQixHQUFFMk8sS0FBSyxjQUFBOU8sT0FBQSxrQkFBQUEsR0FBQTdCLElBQUEsQ0FBQTJCO2dCQUNqQyxJQUFJO29CQUNGWSxRQUFReU8sSUFBSSxDQUNWLENBQUN6RyxLQUFtQjBHLFVBQWtCQzt3QkFDcENDLGFBQWFKO29CQUNmO2dCQUVKLEVBQUUsT0FBTzdILEdBQUc7b0JBQ1YsK0RBQStEO29CQUMvRDNHLFFBQVFtSyxPQUFPO2dCQUNqQjtZQUNGLEdBQUcsSUFBSSxDQUFDNUssZUFBZSxHQUFFNk8sS0FBSyxjQUFBRSxPQUFBLGtCQUFBQSxHQUFBN1EsSUFBQSxDQUFBaUM7WUFDOUJNLFFBQVEwRyxFQUFFLENBQUMsU0FBUztnQkFDbEIsSUFBSSxJQUFJLENBQUNuSSxlQUFlLEVBQUU7b0JBQ3hCLElBQUksQ0FBQ29QLHVCQUF1Qjt3QkFDMUIsSUFBSSxDQUFDblAsYUFBYSxDQUFDVSxRQUFRLENBQ3pCLFdBQ0Esa0NBQWtDc087b0JBRXRDO29CQUNBLElBQUksQ0FBQzFPLHNCQUFzQixDQUFDa0wsVUFBVSxDQUFDakw7b0JBQ3ZDLElBQUF2QyxXQUFBeU4scUJBQXFCLEVBQUNsTDtnQkFDeEI7Z0JBQ0EsSUFBSTBPLG9CQUFvQjtvQkFDdEJtQixhQUFhbkI7Z0JBQ2Y7Z0JBQ0EsSUFBSUMseUJBQXlCO29CQUMzQmtCLGFBQWFsQjtnQkFDZjtnQkFDQSxJQUFJVyxvQkFBb0I7b0JBQ3RCTyxhQUFhUDtnQkFDZjtnQkFDQSxJQUFJLENBQUNsUSxRQUFRLENBQUMwTSxNQUFNLENBQUM3SztZQUN2QjtRQUNGO0lBQ0Y7O0FBMWdDRjZPLGNBQUEsR0FBQWhSO0FBNmdDQSxlQUFlc1AsWUFDYjFQLElBQXNELEVBQ3RENk0sT0FBZ0QsRUFDaER5QyxRQUFrQixFQUNsQkUsUUFBZ0I7SUFFaEIsSUFBSTtRQUNGLE1BQU02QixVQUFVLE1BQU1yUixLQUFLc1IsbUJBQW1CLENBQUM5QjtRQUUvQyxJQUFJNkIsWUFBWTFLLGFBQWEzRyxLQUFLdVIsU0FBUyxFQUFFO1lBQzNDO1FBQ0Y7UUFFQSxNQUFNQyxVQUFVLElBQUkvUyxjQUFBZ1QsbUJBQW1CLENBQ3JDelIsTUFDQXNQLFVBQ0ErQjtRQUdGeEUsUUFBUU0sSUFBSSxDQUNWcUUsU0FDQSxDQUNFakgsS0FDQW1ILE9BQ0FDLFNBQ0FDO1lBRUE1UixLQUFLNlIsZ0JBQWdCLENBQUN0SCxLQUFLbUgsT0FBT0MsU0FBU0M7UUFDN0M7SUFFSixFQUFFLE9BQU9ySCxLQUFLO1FBQ1p2SyxLQUFLOE8sU0FBUyxDQUFDdkU7SUFDakI7QUFDRjtBQUVBLFNBQVNvRixzQkFDUDNQLElBQXNELEVBQ3RENk0sT0FBMEQsRUFDMUR5QyxRQUFrQixFQUNsQkUsUUFBZ0I7SUFFaEIsTUFBTXpCLFNBQVMsSUFBSXRQLGNBQUFxVCx3QkFBd0IsQ0FDekM5UixNQUNBc1AsVUFDQXpDLFFBQVFFLFdBQVcsRUFDbkJ5QztJQUdGLFNBQVNwQixRQUNQN0QsR0FBc0QsRUFDdERtSCxLQUEyQixFQUMzQkMsT0FBa0IsRUFDbEJDLEtBQWM7UUFFZDdELE9BQU9yQixPQUFPO1FBQ2QxTSxLQUFLNlIsZ0JBQWdCLENBQUN0SCxLQUFLbUgsT0FBT0MsU0FBU0M7SUFDN0M7SUFFQSxJQUFJNVIsS0FBS3VSLFNBQVMsRUFBRTtRQUNsQjtJQUNGO0lBRUF4RCxPQUFPOUUsRUFBRSxDQUFDLFNBQVNtRjtJQUNuQnZCLFFBQVFNLElBQUksQ0FBQ1ksUUFBUUs7QUFDdkI7QUFFQSxlQUFld0Isc0JBQ2I1UCxJQUFzRCxFQUN0RDZNLE9BQTBELEVBQzFEeUMsUUFBa0IsRUFDbEJFLFFBQWdCO0lBRWhCLElBQUk7UUFDRixNQUFNNkIsVUFBVSxNQUFNclIsS0FBS3NSLG1CQUFtQixDQUFDOUI7UUFFL0MsSUFBSTZCLFlBQVkxSyxhQUFhM0csS0FBS3VSLFNBQVMsRUFBRTtZQUMzQztRQUNGO1FBRUEsTUFBTXhELFNBQVMsSUFBSXRQLGNBQUFzVCx3QkFBd0IsQ0FDekMvUixNQUNBc1AsVUFDQXpDLFFBQVFDLFNBQVMsRUFDakJ1RTtRQUdGeEUsUUFBUU0sSUFBSSxDQUFDWTtJQUNmLEVBQUUsT0FBT3hELEtBQUs7UUFDWnZLLEtBQUs4TyxTQUFTLENBQUN2RTtJQUNqQjtBQUNGO0FBRUEsU0FBU3NGLG9CQUNQN1AsSUFBc0QsRUFDdEQ2TSxPQUF3RCxFQUN4RHlDLFFBQWtCLEVBQ2xCRSxRQUFnQjtJQUVoQixNQUFNekIsU0FBUyxJQUFJdFAsY0FBQXVULHNCQUFzQixDQUN2Q2hTLE1BQ0FzUCxVQUNBekMsUUFBUUMsU0FBUyxFQUNqQkQsUUFBUUUsV0FBVyxFQUNuQnlDO0lBR0YsSUFBSXhQLEtBQUt1UixTQUFTLEVBQUU7UUFDbEI7SUFDRjtJQUVBMUUsUUFBUU0sSUFBSSxDQUFDWTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uLi8uLi9zcmMvc2VydmVyLnRzPzI2OTkiXSwibmFtZXMiOlsiaHR0cDIiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJzZXJ2ZXJfY2FsbF8xIiwic2VydmVyX2NyZWRlbnRpYWxzXzEiLCJyZXNvbHZlcl8xIiwibG9nZ2luZyIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwidXJpX3BhcnNlcl8xIiwiY2hhbm5lbHpfMSIsIlVOTElNSVRFRF9DT05ORUNUSU9OX0FHRV9NUyIsIktFRVBBTElWRV9NQVhfVElNRV9NUyIsIktFRVBBTElWRV9USU1FT1VUX01TIiwiSFRUUDJfSEVBREVSX1BBVEgiLCJjb25zdGFudHMiLCJUUkFDRVJfTkFNRSIsIm5vb3AiLCJnZXRVbmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UiLCJtZXRob2ROYW1lIiwiY29kZSIsIlN0YXR1cyIsIlVOSU1QTEVNRU5URUQiLCJkZXRhaWxzIiwiZ2V0RGVmYXVsdEhhbmRsZXIiLCJoYW5kbGVyVHlwZSIsInVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSIsImNhbGwiLCJjYWxsYmFjayIsImVtaXQiLCJFcnJvciIsIlNlcnZlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImh0dHAyU2VydmVyTGlzdCIsImhhbmRsZXJzIiwiTWFwIiwic2Vzc2lvbnMiLCJzdGFydGVkIiwic2h1dGRvd24iLCJzZXJ2ZXJBZGRyZXNzU3RyaW5nIiwiY2hhbm5lbHpFbmFibGVkIiwiY2hhbm5lbHpUcmFjZSIsIkNoYW5uZWx6VHJhY2UiLCJjYWxsVHJhY2tlciIsIkNoYW5uZWx6Q2FsbFRyYWNrZXIiLCJsaXN0ZW5lckNoaWxkcmVuVHJhY2tlciIsIkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyIiwic2Vzc2lvbkNoaWxkcmVuVHJhY2tlciIsImNoYW5uZWx6UmVmIiwicmVnaXN0ZXJDaGFubmVselNlcnZlciIsImdldENoYW5uZWx6SW5mbyIsImFkZFRyYWNlIiwibWF4Q29ubmVjdGlvbkFnZU1zIiwiX2EiLCJtYXhDb25uZWN0aW9uQWdlR3JhY2VNcyIsIl9iIiwia2VlcGFsaXZlVGltZU1zIiwiX2MiLCJrZWVwYWxpdmVUaW1lb3V0TXMiLCJfZCIsInRyYWNlIiwibGlzdGVuZXJDaGlsZHJlbiIsImdldENoaWxkTGlzdHMiLCJzZXNzaW9uQ2hpbGRyZW4iLCJnZXRDaGFubmVselNlc3Npb25JbmZvR2V0dGVyIiwic2Vzc2lvbiIsInNlc3Npb25JbmZvIiwiZ2V0Iiwic2Vzc2lvblNvY2tldCIsInNvY2tldCIsInJlbW90ZUFkZHJlc3MiLCJzdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzIiwicmVtb3RlUG9ydCIsImxvY2FsQWRkcmVzcyIsImxvY2FsUG9ydCIsInRsc0luZm8iLCJlbmNyeXB0ZWQiLCJ0bHNTb2NrZXQiLCJjaXBoZXJJbmZvIiwiZ2V0Q2lwaGVyIiwiY2VydGlmaWNhdGUiLCJnZXRDZXJ0aWZpY2F0ZSIsInBlZXJDZXJ0aWZpY2F0ZSIsImdldFBlZXJDZXJ0aWZpY2F0ZSIsImNpcGhlclN1aXRlU3RhbmRhcmROYW1lIiwic3RhbmRhcmROYW1lIiwiY2lwaGVyU3VpdGVPdGhlck5hbWUiLCJuYW1lIiwibG9jYWxDZXJ0aWZpY2F0ZSIsInJhdyIsInJlbW90ZUNlcnRpZmljYXRlIiwic29ja2V0SW5mbyIsInNlY3VyaXR5IiwicmVtb3RlTmFtZSIsInN0cmVhbXNTdGFydGVkIiwic3RyZWFtVHJhY2tlciIsImNhbGxzU3RhcnRlZCIsInN0cmVhbXNTdWNjZWVkZWQiLCJjYWxsc1N1Y2NlZWRlZCIsInN0cmVhbXNGYWlsZWQiLCJjYWxsc0ZhaWxlZCIsIm1lc3NhZ2VzU2VudCIsIm1lc3NhZ2VzUmVjZWl2ZWQiLCJrZWVwQWxpdmVzU2VudCIsImxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXAiLCJsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCIsImxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCIsImxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCIsImxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAiLCJsb2NhbEZsb3dDb250cm9sV2luZG93Iiwic3RhdGUiLCJsb2NhbFdpbmRvd1NpemUiLCJyZW1vdGVGbG93Q29udHJvbFdpbmRvdyIsInJlbW90ZVdpbmRvd1NpemUiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJpZCIsImFkZFByb3RvU2VydmljZSIsImFkZFNlcnZpY2UiLCJzZXJ2aWNlIiwiaW1wbGVtZW50YXRpb24iLCJzZXJ2aWNlS2V5cyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiYXR0cnMiLCJtZXRob2RUeXBlIiwicmVxdWVzdFN0cmVhbSIsInJlc3BvbnNlU3RyZWFtIiwiaW1wbEZuIiwiaW1wbCIsInVuZGVmaW5lZCIsIm9yaWdpbmFsTmFtZSIsImJpbmQiLCJzdWNjZXNzIiwicmVnaXN0ZXIiLCJwYXRoIiwicmVzcG9uc2VTZXJpYWxpemUiLCJyZXF1ZXN0RGVzZXJpYWxpemUiLCJyZW1vdmVTZXJ2aWNlIiwidW5yZWdpc3RlciIsInBvcnQiLCJjcmVkcyIsImJpbmRBc3luYyIsIlR5cGVFcnJvciIsIlNlcnZlckNyZWRlbnRpYWxzIiwiaW5pdGlhbFBvcnRVcmkiLCJwYXJzZVVyaSIsInBvcnRVcmkiLCJtYXBVcmlEZWZhdWx0U2NoZW1lIiwic2VydmVyT3B0aW9ucyIsIm1heFNlbmRIZWFkZXJCbG9ja0xlbmd0aCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJtYXhTZXNzaW9uTWVtb3J5Iiwic2V0dGluZ3MiLCJtYXhDb25jdXJyZW50U3RyZWFtcyIsImRlZmVycmVkQ2FsbGJhY2siLCJlcnJvciIsInByb2Nlc3MiLCJuZXh0VGljayIsInNldHVwU2VydmVyIiwiaHR0cDJTZXJ2ZXIiLCJfaXNTZWN1cmUiLCJzZWN1cmVTZXJ2ZXJPcHRpb25zIiwiYXNzaWduIiwiX2dldFNldHRpbmdzIiwiZW5hYmxlVHJhY2UiLCJjcmVhdGVTZWN1cmVTZXJ2ZXIiLCJvbiIsImUiLCJtZXNzYWdlIiwiY3JlYXRlU2VydmVyIiwic2V0VGltZW91dCIsIl9zZXR1cEhhbmRsZXJzIiwiYmluZFNwZWNpZmljUG9ydCIsImFkZHJlc3NMaXN0IiwicG9ydE51bSIsInByZXZpb3VzQ291bnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvdW50IiwiYWxsIiwibWFwIiwiYWRkcmVzcyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJhZGRyIiwiaXNUY3BTdWJjaGFubmVsQWRkcmVzcyIsImhvc3QiLCJyZWplY3QiLCJvbkVycm9yIiwiZXJyIiwib25jZSIsImxpc3RlbiIsImNsb3NlIiwiYm91bmRBZGRyZXNzIiwiYm91bmRTdWJjaGFubmVsQWRkcmVzcyIsInJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQiLCJyZWZDaGlsZCIsInB1c2giLCJzZXJ2ZXIiLCJyZW1vdmVMaXN0ZW5lciIsInRoZW4iLCJyZXN1bHRzIiwicmVzdWx0IiwiYmluZFdpbGRjYXJkUG9ydCIsInNsaWNlIiwicmVzb2x2ZXJMaXN0ZW5lciIsIm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24iLCJzZXJ2aWNlQ29uZmlnIiwic2VydmljZUNvbmZpZ0Vycm9yIiwiYmluZFJlc3VsdFByb21pc2UiLCJiaW5kUmVzdWx0IiwiZXJyb3JTdHJpbmciLCJsb2ciLCJFUlJPUiIsIklORk8iLCJyZXNvbHZlciIsImNyZWF0ZVJlc29sdmVyIiwidXBkYXRlUmVzb2x1dGlvbiIsImZvcmNlU2h1dGRvd24iLCJyZWYiLCJsaXN0ZW5pbmciLCJ1bnJlZkNoaWxkIiwidW5yZWdpc3RlckNoYW5uZWx6UmVmIiwiY2hhbm5lbHpJbmZvIiwiZGVzdHJveSIsIk5HSFRUUDJfQ0FOQ0VMIiwiY2xlYXIiLCJoYW5kbGVyIiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJ0eXBlIiwiaGFzIiwic2V0IiwiZnVuYyIsImRlbGV0ZSIsInN0YXJ0IiwiZXZlcnkiLCJ0cnlTaHV0ZG93biIsIndyYXBwZWRDYWxsYmFjayIsInBlbmRpbmdDaGVja3MiLCJtYXliZUNhbGxiYWNrIiwiY2xvc2VkIiwiYWRkSHR0cDJQb3J0IiwiZ2V0Q2hhbm5lbHpSZWYiLCJfdmVyaWZ5Q29udGVudFR5cGUiLCJzdHJlYW0iLCJoZWFkZXJzIiwiY29udGVudFR5cGUiLCJIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFIiwic3RhcnRzV2l0aCIsInJlc3BvbmQiLCJIVFRQMl9IRUFERVJfU1RBVFVTIiwiSFRUUF9TVEFUVVNfVU5TVVBQT1JURURfTUVESUFfVFlQRSIsImVuZFN0cmVhbSIsIl9yZXRyaWV2ZUhhbmRsZXIiLCJfcmVzcG9uZFdpdGhFcnJvciIsImNoYW5uZWx6U2Vzc2lvbkluZm8iLCJIdHRwMlNlcnZlckNhbGxTdHJlYW0iLCJJTlRFUk5BTCIsImFkZENhbGxGYWlsZWQiLCJzZW5kRXJyb3IiLCJfY2hhbm5lbHpIYW5kbGVyIiwiYWRkQ2FsbFN0YXJ0ZWQiLCJPSyIsImFkZENhbGxTdWNjZWVkZWQiLCJEYXRlIiwiX3J1bkhhbmRsZXJGb3JDYWxsIiwiX3N0cmVhbUhhbmRsZXIiLCJtZXRhZGF0YSIsInJlY2VpdmVNZXRhZGF0YSIsImVuY29kaW5nIiwicmVtb3ZlIiwiaGFuZGxlVW5hcnkiLCJoYW5kbGVDbGllbnRTdHJlYW1pbmciLCJoYW5kbGVTZXJ2ZXJTdHJlYW1pbmciLCJoYW5kbGVCaWRpU3RyZWFtaW5nIiwic2VydmVyQWRkcmVzcyIsImNsaWVudEFkZHJlc3MiLCJjb25uZWN0aW9uQWdlVGltZXIiLCJjb25uZWN0aW9uQWdlR3JhY2VUaW1lciIsInNlc3Npb25DbG9zZWRCeVNlcnZlciIsImppdHRlck1hZ25pdHVkZSIsImppdHRlciIsIk1hdGgiLCJyYW5kb20iLCJnb2F3YXkiLCJOR0hUVFAyX05PX0VSUk9SIiwiQnVmZmVyIiwiZnJvbSIsInVucmVmIiwia2VlYXBsaXZlVGltZVRpbWVyIiwiX2UiLCJzZXRJbnRlcnZhbCIsInRpbWVvdXRUSW1lciIsInBpbmciLCJkdXJhdGlvbiIsInBheWxvYWQiLCJjbGVhclRpbWVvdXQiLCJleHBvcnRzIiwicmVxdWVzdCIsInJlY2VpdmVVbmFyeU1lc3NhZ2UiLCJjYW5jZWxsZWQiLCJlbWl0dGVyIiwiU2VydmVyVW5hcnlDYWxsSW1wbCIsInZhbHVlIiwidHJhaWxlciIsImZsYWdzIiwic2VuZFVuYXJ5TWVzc2FnZSIsIlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCIsIlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCIsIlNlcnZlckR1cGxleFN0cmVhbUltcGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/service-config.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.extractAndSelectServiceConfig = exports.validateServiceConfig = exports.validateRetryThrottling = void 0;\r\n/* This file implements gRFC A2 and the service config spec:\r\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\r\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\r\n * function here takes an object with unknown structure and returns its\r\n * specific object type if the input has the right structure, and throws an\r\n * error otherwise. */\r\n/* The any type is purposely used here. All functions validate their input at\r\n * runtime */\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\r\n/**\r\n * Recognizes a number with up to 9 digits after the decimal point, followed by\r\n * an \"s\", representing a number of seconds.\r\n */\r\nconst DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\r\n/**\r\n * Client language name used for determining whether this client matches a\r\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\r\n */\r\nconst CLIENT_LANGUAGE_STRING = 'node';\r\nfunction validateName(obj) {\r\n    // In this context, and unset field and '' are considered the same\r\n    if ('service' in obj && obj.service !== '') {\r\n        if (typeof obj.service !== 'string') {\r\n            throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);\r\n        }\r\n        if ('method' in obj && obj.method !== '') {\r\n            if (typeof obj.method !== 'string') {\r\n                throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);\r\n            }\r\n            return {\r\n                service: obj.service,\r\n                method: obj.method,\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                service: obj.service,\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        if ('method' in obj && obj.method !== undefined) {\r\n            throw new Error(`Invalid method config name: method set with empty or unset service`);\r\n        }\r\n        return {};\r\n    }\r\n}\r\nfunction validateRetryPolicy(obj) {\r\n    if (!('maxAttempts' in obj) ||\r\n        !Number.isInteger(obj.maxAttempts) ||\r\n        obj.maxAttempts < 2) {\r\n        throw new Error('Invalid method config retry policy: maxAttempts must be an integer at least 2');\r\n    }\r\n    if (!('initialBackoff' in obj) ||\r\n        typeof obj.initialBackoff !== 'string' ||\r\n        !DURATION_REGEX.test(obj.initialBackoff)) {\r\n        throw new Error('Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer followed by s');\r\n    }\r\n    if (!('maxBackoff' in obj) ||\r\n        typeof obj.maxBackoff !== 'string' ||\r\n        !DURATION_REGEX.test(obj.maxBackoff)) {\r\n        throw new Error('Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer followed by s');\r\n    }\r\n    if (!('backoffMultiplier' in obj) ||\r\n        typeof obj.backoffMultiplier !== 'number' ||\r\n        obj.backoffMultiplier <= 0) {\r\n        throw new Error('Invalid method config retry policy: backoffMultiplier must be a number greater than 0');\r\n    }\r\n    if (!('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))) {\r\n        throw new Error('Invalid method config retry policy: retryableStatusCodes is required');\r\n    }\r\n    if (obj.retryableStatusCodes.length === 0) {\r\n        throw new Error('Invalid method config retry policy: retryableStatusCodes must be non-empty');\r\n    }\r\n    for (const value of obj.retryableStatusCodes) {\r\n        if (typeof value === 'number') {\r\n            if (!Object.values(constants_1.Status).includes(value)) {\r\n                throw new Error('Invalid method config retry policy: retryableStatusCodes value not in status code range');\r\n            }\r\n        }\r\n        else if (typeof value === 'string') {\r\n            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\r\n                throw new Error('Invalid method config retry policy: retryableStatusCodes value not a status code name');\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Invalid method config retry policy: retryableStatusCodes value must be a string or number');\r\n        }\r\n    }\r\n    return {\r\n        maxAttempts: obj.maxAttempts,\r\n        initialBackoff: obj.initialBackoff,\r\n        maxBackoff: obj.maxBackoff,\r\n        backoffMultiplier: obj.backoffMultiplier,\r\n        retryableStatusCodes: obj.retryableStatusCodes,\r\n    };\r\n}\r\nfunction validateHedgingPolicy(obj) {\r\n    if (!('maxAttempts' in obj) ||\r\n        !Number.isInteger(obj.maxAttempts) ||\r\n        obj.maxAttempts < 2) {\r\n        throw new Error('Invalid method config hedging policy: maxAttempts must be an integer at least 2');\r\n    }\r\n    if ('hedgingDelay' in obj &&\r\n        (typeof obj.hedgingDelay !== 'string' ||\r\n            !DURATION_REGEX.test(obj.hedgingDelay))) {\r\n        throw new Error('Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s');\r\n    }\r\n    if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {\r\n        for (const value of obj.nonFatalStatusCodes) {\r\n            if (typeof value === 'number') {\r\n                if (!Object.values(constants_1.Status).includes(value)) {\r\n                    throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value not in status code range');\r\n                }\r\n            }\r\n            else if (typeof value === 'string') {\r\n                if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\r\n                    throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value not a status code name');\r\n                }\r\n            }\r\n            else {\r\n                throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value must be a string or number');\r\n            }\r\n        }\r\n    }\r\n    const result = {\r\n        maxAttempts: obj.maxAttempts,\r\n    };\r\n    if (obj.hedgingDelay) {\r\n        result.hedgingDelay = obj.hedgingDelay;\r\n    }\r\n    if (obj.nonFatalStatusCodes) {\r\n        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\r\n    }\r\n    return result;\r\n}\r\nfunction validateMethodConfig(obj) {\r\n    var _a;\r\n    const result = {\r\n        name: [],\r\n    };\r\n    if (!('name' in obj) || !Array.isArray(obj.name)) {\r\n        throw new Error('Invalid method config: invalid name array');\r\n    }\r\n    for (const name of obj.name) {\r\n        result.name.push(validateName(name));\r\n    }\r\n    if ('waitForReady' in obj) {\r\n        if (typeof obj.waitForReady !== 'boolean') {\r\n            throw new Error('Invalid method config: invalid waitForReady');\r\n        }\r\n        result.waitForReady = obj.waitForReady;\r\n    }\r\n    if ('timeout' in obj) {\r\n        if (typeof obj.timeout === 'object') {\r\n            if (!('seconds' in obj.timeout) ||\r\n                !(typeof obj.timeout.seconds === 'number')) {\r\n                throw new Error('Invalid method config: invalid timeout.seconds');\r\n            }\r\n            if (!('nanos' in obj.timeout) ||\r\n                !(typeof obj.timeout.nanos === 'number')) {\r\n                throw new Error('Invalid method config: invalid timeout.nanos');\r\n            }\r\n            result.timeout = obj.timeout;\r\n        }\r\n        else if (typeof obj.timeout === 'string' &&\r\n            DURATION_REGEX.test(obj.timeout)) {\r\n            const timeoutParts = obj.timeout\r\n                .substring(0, obj.timeout.length - 1)\r\n                .split('.');\r\n            result.timeout = {\r\n                seconds: timeoutParts[0] | 0,\r\n                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0,\r\n            };\r\n        }\r\n        else {\r\n            throw new Error('Invalid method config: invalid timeout');\r\n        }\r\n    }\r\n    if ('maxRequestBytes' in obj) {\r\n        if (typeof obj.maxRequestBytes !== 'number') {\r\n            throw new Error('Invalid method config: invalid maxRequestBytes');\r\n        }\r\n        result.maxRequestBytes = obj.maxRequestBytes;\r\n    }\r\n    if ('maxResponseBytes' in obj) {\r\n        if (typeof obj.maxResponseBytes !== 'number') {\r\n            throw new Error('Invalid method config: invalid maxRequestBytes');\r\n        }\r\n        result.maxResponseBytes = obj.maxResponseBytes;\r\n    }\r\n    if ('retryPolicy' in obj) {\r\n        if ('hedgingPolicy' in obj) {\r\n            throw new Error('Invalid method config: retryPolicy and hedgingPolicy cannot both be specified');\r\n        }\r\n        else {\r\n            result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\r\n        }\r\n    }\r\n    else if ('hedgingPolicy' in obj) {\r\n        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\r\n    }\r\n    return result;\r\n}\r\nfunction validateRetryThrottling(obj) {\r\n    if (!('maxTokens' in obj) ||\r\n        typeof obj.maxTokens !== 'number' ||\r\n        obj.maxTokens <= 0 ||\r\n        obj.maxTokens > 1000) {\r\n        throw new Error('Invalid retryThrottling: maxTokens must be a number in (0, 1000]');\r\n    }\r\n    if (!('tokenRatio' in obj) ||\r\n        typeof obj.tokenRatio !== 'number' ||\r\n        obj.tokenRatio <= 0) {\r\n        throw new Error('Invalid retryThrottling: tokenRatio must be a number greater than 0');\r\n    }\r\n    return {\r\n        maxTokens: +obj.maxTokens.toFixed(3),\r\n        tokenRatio: +obj.tokenRatio.toFixed(3),\r\n    };\r\n}\r\nexports.validateRetryThrottling = validateRetryThrottling;\r\nfunction validateServiceConfig(obj) {\r\n    const result = {\r\n        loadBalancingConfig: [],\r\n        methodConfig: [],\r\n    };\r\n    if ('loadBalancingPolicy' in obj) {\r\n        if (typeof obj.loadBalancingPolicy === 'string') {\r\n            result.loadBalancingPolicy = obj.loadBalancingPolicy;\r\n        }\r\n        else {\r\n            throw new Error('Invalid service config: invalid loadBalancingPolicy');\r\n        }\r\n    }\r\n    if ('loadBalancingConfig' in obj) {\r\n        if (Array.isArray(obj.loadBalancingConfig)) {\r\n            for (const config of obj.loadBalancingConfig) {\r\n                result.loadBalancingConfig.push((0, load_balancer_1.validateLoadBalancingConfig)(config));\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Invalid service config: invalid loadBalancingConfig');\r\n        }\r\n    }\r\n    if ('methodConfig' in obj) {\r\n        if (Array.isArray(obj.methodConfig)) {\r\n            for (const methodConfig of obj.methodConfig) {\r\n                result.methodConfig.push(validateMethodConfig(methodConfig));\r\n            }\r\n        }\r\n    }\r\n    if ('retryThrottling' in obj) {\r\n        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\r\n    }\r\n    // Validate method name uniqueness\r\n    const seenMethodNames = [];\r\n    for (const methodConfig of result.methodConfig) {\r\n        for (const name of methodConfig.name) {\r\n            for (const seenName of seenMethodNames) {\r\n                if (name.service === seenName.service &&\r\n                    name.method === seenName.method) {\r\n                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\r\n                }\r\n            }\r\n            seenMethodNames.push(name);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.validateServiceConfig = validateServiceConfig;\r\nfunction validateCanaryConfig(obj) {\r\n    if (!('serviceConfig' in obj)) {\r\n        throw new Error('Invalid service config choice: missing service config');\r\n    }\r\n    const result = {\r\n        serviceConfig: validateServiceConfig(obj.serviceConfig),\r\n    };\r\n    if ('clientLanguage' in obj) {\r\n        if (Array.isArray(obj.clientLanguage)) {\r\n            result.clientLanguage = [];\r\n            for (const lang of obj.clientLanguage) {\r\n                if (typeof lang === 'string') {\r\n                    result.clientLanguage.push(lang);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid service config choice: invalid clientLanguage');\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Invalid service config choice: invalid clientLanguage');\r\n        }\r\n    }\r\n    if ('clientHostname' in obj) {\r\n        if (Array.isArray(obj.clientHostname)) {\r\n            result.clientHostname = [];\r\n            for (const lang of obj.clientHostname) {\r\n                if (typeof lang === 'string') {\r\n                    result.clientHostname.push(lang);\r\n                }\r\n                else {\r\n                    throw new Error('Invalid service config choice: invalid clientHostname');\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('Invalid service config choice: invalid clientHostname');\r\n        }\r\n    }\r\n    if ('percentage' in obj) {\r\n        if (typeof obj.percentage === 'number' &&\r\n            0 <= obj.percentage &&\r\n            obj.percentage <= 100) {\r\n            result.percentage = obj.percentage;\r\n        }\r\n        else {\r\n            throw new Error('Invalid service config choice: invalid percentage');\r\n        }\r\n    }\r\n    // Validate that no unexpected fields are present\r\n    const allowedFields = [\r\n        'clientLanguage',\r\n        'percentage',\r\n        'clientHostname',\r\n        'serviceConfig',\r\n    ];\r\n    for (const field in obj) {\r\n        if (!allowedFields.includes(field)) {\r\n            throw new Error(`Invalid service config choice: unexpected field ${field}`);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction validateAndSelectCanaryConfig(obj, percentage) {\r\n    if (!Array.isArray(obj)) {\r\n        throw new Error('Invalid service config list');\r\n    }\r\n    for (const config of obj) {\r\n        const validatedConfig = validateCanaryConfig(config);\r\n        /* For each field, we check if it is present, then only discard the\r\n         * config if the field value does not match the current client */\r\n        if (typeof validatedConfig.percentage === 'number' &&\r\n            percentage > validatedConfig.percentage) {\r\n            continue;\r\n        }\r\n        if (Array.isArray(validatedConfig.clientHostname)) {\r\n            let hostnameMatched = false;\r\n            for (const hostname of validatedConfig.clientHostname) {\r\n                if (hostname === os.hostname()) {\r\n                    hostnameMatched = true;\r\n                }\r\n            }\r\n            if (!hostnameMatched) {\r\n                continue;\r\n            }\r\n        }\r\n        if (Array.isArray(validatedConfig.clientLanguage)) {\r\n            let languageMatched = false;\r\n            for (const language of validatedConfig.clientLanguage) {\r\n                if (language === CLIENT_LANGUAGE_STRING) {\r\n                    languageMatched = true;\r\n                }\r\n            }\r\n            if (!languageMatched) {\r\n                continue;\r\n            }\r\n        }\r\n        return validatedConfig.serviceConfig;\r\n    }\r\n    throw new Error('No matching service config found');\r\n}\r\n/**\r\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\r\n * and select a service config with selection fields that all match this client. Most of these steps\r\n * can fail with an error; the caller must handle any errors thrown this way.\r\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\r\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\r\n * @return The service configuration to use, given the percentage value, or null if the service config\r\n *     data has a valid format but none of the options match the current client.\r\n */\r\nfunction extractAndSelectServiceConfig(txtRecord, percentage) {\r\n    for (const record of txtRecord) {\r\n        if (record.length > 0 && record[0].startsWith('grpc_config=')) {\r\n            /* Treat the list of strings in this record as a single string and remove\r\n             * \"grpc_config=\" from the beginning. The rest should be a JSON string */\r\n            const recordString = record.join('').substring('grpc_config='.length);\r\n            const recordJson = JSON.parse(recordString);\r\n            return validateAndSelectCanaryConfig(recordJson, percentage);\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;\r\n//# sourceMappingURL=service-config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmljZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQ0FBcUMsR0FBRyw2QkFBNkIsR0FBRywrQkFBK0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLG1CQUFtQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsbUJBQW1CO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGFBQWEsR0FBRyxZQUFZO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZpY2UtY29uZmlnLmpzP2E5MjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcgPSBleHBvcnRzLnZhbGlkYXRlU2VydmljZUNvbmZpZyA9IGV4cG9ydHMudmFsaWRhdGVSZXRyeVRocm90dGxpbmcgPSB2b2lkIDA7XHJcbi8qIFRoaXMgZmlsZSBpbXBsZW1lbnRzIGdSRkMgQTIgYW5kIHRoZSBzZXJ2aWNlIGNvbmZpZyBzcGVjOlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9wcm9wb3NhbC9ibG9iL21hc3Rlci9BMi1zZXJ2aWNlLWNvbmZpZ3MtaW4tZG5zLm1kXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9tYXN0ZXIvZG9jL3NlcnZpY2VfY29uZmlnLm1kLiBFYWNoXHJcbiAqIGZ1bmN0aW9uIGhlcmUgdGFrZXMgYW4gb2JqZWN0IHdpdGggdW5rbm93biBzdHJ1Y3R1cmUgYW5kIHJldHVybnMgaXRzXHJcbiAqIHNwZWNpZmljIG9iamVjdCB0eXBlIGlmIHRoZSBpbnB1dCBoYXMgdGhlIHJpZ2h0IHN0cnVjdHVyZSwgYW5kIHRocm93cyBhblxyXG4gKiBlcnJvciBvdGhlcndpc2UuICovXHJcbi8qIFRoZSBhbnkgdHlwZSBpcyBwdXJwb3NlbHkgdXNlZCBoZXJlLiBBbGwgZnVuY3Rpb25zIHZhbGlkYXRlIHRoZWlyIGlucHV0IGF0XHJcbiAqIHJ1bnRpbWUgKi9cclxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xyXG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcclxuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XHJcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XHJcbi8qKlxyXG4gKiBSZWNvZ25pemVzIGEgbnVtYmVyIHdpdGggdXAgdG8gOSBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIGZvbGxvd2VkIGJ5XHJcbiAqIGFuIFwic1wiLCByZXByZXNlbnRpbmcgYSBudW1iZXIgb2Ygc2Vjb25kcy5cclxuICovXHJcbmNvbnN0IERVUkFUSU9OX1JFR0VYID0gL15cXGQrKFxcLlxcZHsxLDl9KT9zJC87XHJcbi8qKlxyXG4gKiBDbGllbnQgbGFuZ3VhZ2UgbmFtZSB1c2VkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoaXMgY2xpZW50IG1hdGNoZXMgYVxyXG4gKiBgU2VydmljZUNvbmZpZ0NhbmFyeUNvbmZpZ2AncyBgY2xpZW50TGFuZ3VhZ2VgIGxpc3QuXHJcbiAqL1xyXG5jb25zdCBDTElFTlRfTEFOR1VBR0VfU1RSSU5HID0gJ25vZGUnO1xyXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWUob2JqKSB7XHJcbiAgICAvLyBJbiB0aGlzIGNvbnRleHQsIGFuZCB1bnNldCBmaWVsZCBhbmQgJycgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWVcclxuICAgIGlmICgnc2VydmljZScgaW4gb2JqICYmIG9iai5zZXJ2aWNlICE9PSAnJykge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnNlcnZpY2UgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXRob2QgY29uZmlnIG5hbWU6IGludmFsaWQgc2VydmljZTogZXhwZWN0ZWQgdHlwZSBzdHJpbmcsIGdvdCAke3R5cGVvZiBvYmouc2VydmljZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCdtZXRob2QnIGluIG9iaiAmJiBvYmoubWV0aG9kICE9PSAnJykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iai5tZXRob2QgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWV0aG9kIGNvbmZpZyBuYW1lOiBpbnZhbGlkIG1ldGhvZDogZXhwZWN0ZWQgdHlwZSBzdHJpbmcsIGdvdCAke3R5cGVvZiBvYmouc2VydmljZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2VydmljZTogb2JqLnNlcnZpY2UsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG9iai5tZXRob2QsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2VydmljZTogb2JqLnNlcnZpY2UsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCdtZXRob2QnIGluIG9iaiAmJiBvYmoubWV0aG9kICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1ldGhvZCBjb25maWcgbmFtZTogbWV0aG9kIHNldCB3aXRoIGVtcHR5IG9yIHVuc2V0IHNlcnZpY2VgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUmV0cnlQb2xpY3kob2JqKSB7XHJcbiAgICBpZiAoISgnbWF4QXR0ZW1wdHMnIGluIG9iaikgfHxcclxuICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvYmoubWF4QXR0ZW1wdHMpIHx8XHJcbiAgICAgICAgb2JqLm1heEF0dGVtcHRzIDwgMikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogbWF4QXR0ZW1wdHMgbXVzdCBiZSBhbiBpbnRlZ2VyIGF0IGxlYXN0IDInKTtcclxuICAgIH1cclxuICAgIGlmICghKCdpbml0aWFsQmFja29mZicgaW4gb2JqKSB8fFxyXG4gICAgICAgIHR5cGVvZiBvYmouaW5pdGlhbEJhY2tvZmYgIT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgIURVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLmluaXRpYWxCYWNrb2ZmKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogaW5pdGlhbEJhY2tvZmYgbXVzdCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIG9mIGEgcG9zaXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieSBzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoISgnbWF4QmFja29mZicgaW4gb2JqKSB8fFxyXG4gICAgICAgIHR5cGVvZiBvYmoubWF4QmFja29mZiAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgICAhRFVSQVRJT05fUkVHRVgudGVzdChvYmoubWF4QmFja29mZikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IG1heEJhY2tvZmYgbXVzdCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIG9mIGEgcG9zaXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieSBzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoISgnYmFja29mZk11bHRpcGxpZXInIGluIG9iaikgfHxcclxuICAgICAgICB0eXBlb2Ygb2JqLmJhY2tvZmZNdWx0aXBsaWVyICE9PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgIG9iai5iYWNrb2ZmTXVsdGlwbGllciA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiBiYWNrb2ZmTXVsdGlwbGllciBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoISgncmV0cnlhYmxlU3RhdHVzQ29kZXMnIGluIG9iaiAmJiBBcnJheS5pc0FycmF5KG9iai5yZXRyeWFibGVTdGF0dXNDb2RlcykpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyBpcyByZXF1aXJlZCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9iai5yZXRyeWFibGVTdGF0dXNDb2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IHJldHJ5YWJsZVN0YXR1c0NvZGVzIG11c3QgYmUgbm9uLWVtcHR5Jyk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iai5yZXRyeWFibGVTdGF0dXNDb2Rlcykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnZhbHVlcyhjb25zdGFudHNfMS5TdGF0dXMpLmluY2x1ZGVzKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyB2YWx1ZSBub3QgaW4gc3RhdHVzIGNvZGUgcmFuZ2UnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnZhbHVlcyhjb25zdGFudHNfMS5TdGF0dXMpLmluY2x1ZGVzKHZhbHVlLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IHJldHJ5YWJsZVN0YXR1c0NvZGVzIHZhbHVlIG5vdCBhIHN0YXR1cyBjb2RlIG5hbWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlcicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWF4QXR0ZW1wdHM6IG9iai5tYXhBdHRlbXB0cyxcclxuICAgICAgICBpbml0aWFsQmFja29mZjogb2JqLmluaXRpYWxCYWNrb2ZmLFxyXG4gICAgICAgIG1heEJhY2tvZmY6IG9iai5tYXhCYWNrb2ZmLFxyXG4gICAgICAgIGJhY2tvZmZNdWx0aXBsaWVyOiBvYmouYmFja29mZk11bHRpcGxpZXIsXHJcbiAgICAgICAgcmV0cnlhYmxlU3RhdHVzQ29kZXM6IG9iai5yZXRyeWFibGVTdGF0dXNDb2RlcyxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVIZWRnaW5nUG9saWN5KG9iaikge1xyXG4gICAgaWYgKCEoJ21heEF0dGVtcHRzJyBpbiBvYmopIHx8XHJcbiAgICAgICAgIU51bWJlci5pc0ludGVnZXIob2JqLm1heEF0dGVtcHRzKSB8fFxyXG4gICAgICAgIG9iai5tYXhBdHRlbXB0cyA8IDIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbWF4QXR0ZW1wdHMgbXVzdCBiZSBhbiBpbnRlZ2VyIGF0IGxlYXN0IDInKTtcclxuICAgIH1cclxuICAgIGlmICgnaGVkZ2luZ0RlbGF5JyBpbiBvYmogJiZcclxuICAgICAgICAodHlwZW9mIG9iai5oZWRnaW5nRGVsYXkgIT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgICAgICFEVVJBVElPTl9SRUdFWC50ZXN0KG9iai5oZWRnaW5nRGVsYXkpKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIGhlZGdpbmcgcG9saWN5OiBoZWRnaW5nRGVsYXkgbXVzdCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIG9mIGEgcG9zaXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieSBzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoJ25vbkZhdGFsU3RhdHVzQ29kZXMnIGluIG9iaiAmJiBBcnJheS5pc0FycmF5KG9iai5ub25GYXRhbFN0YXR1c0NvZGVzKSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2Ygb2JqLm5vbkZhdGFsU3RhdHVzQ29kZXMpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnZhbHVlcyhjb25zdGFudHNfMS5TdGF0dXMpLmluY2x1ZGVzKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52bGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IG5vbkZhdGFsU3RhdHVzQ29kZXMgdmFsdWUgbm90IGluIHN0YXR1cyBjb2RlIHJhbmdlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmxpZCBtZXRob2QgY29uZmlnIGhlZGdpbmcgcG9saWN5OiBub25GYXRhbFN0YXR1c0NvZGVzIHZhbHVlIG5vdCBhIHN0YXR1cyBjb2RlIG5hbWUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52bGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IG5vbkZhdGFsU3RhdHVzQ29kZXMgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBvciBudW1iZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICBtYXhBdHRlbXB0czogb2JqLm1heEF0dGVtcHRzLFxyXG4gICAgfTtcclxuICAgIGlmIChvYmouaGVkZ2luZ0RlbGF5KSB7XHJcbiAgICAgICAgcmVzdWx0LmhlZGdpbmdEZWxheSA9IG9iai5oZWRnaW5nRGVsYXk7XHJcbiAgICB9XHJcbiAgICBpZiAob2JqLm5vbkZhdGFsU3RhdHVzQ29kZXMpIHtcclxuICAgICAgICByZXN1bHQubm9uRmF0YWxTdGF0dXNDb2RlcyA9IG9iai5ub25GYXRhbFN0YXR1c0NvZGVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZENvbmZpZyhvYmopIHtcclxuICAgIHZhciBfYTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICBuYW1lOiBbXSxcclxuICAgIH07XHJcbiAgICBpZiAoISgnbmFtZScgaW4gb2JqKSB8fCAhQXJyYXkuaXNBcnJheShvYmoubmFtZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCBuYW1lIGFycmF5Jyk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb2JqLm5hbWUpIHtcclxuICAgICAgICByZXN1bHQubmFtZS5wdXNoKHZhbGlkYXRlTmFtZShuYW1lKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoJ3dhaXRGb3JSZWFkeScgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoud2FpdEZvclJlYWR5ICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgd2FpdEZvclJlYWR5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC53YWl0Rm9yUmVhZHkgPSBvYmoud2FpdEZvclJlYWR5O1xyXG4gICAgfVxyXG4gICAgaWYgKCd0aW1lb3V0JyBpbiBvYmopIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9iai50aW1lb3V0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBpZiAoISgnc2Vjb25kcycgaW4gb2JqLnRpbWVvdXQpIHx8XHJcbiAgICAgICAgICAgICAgICAhKHR5cGVvZiBvYmoudGltZW91dC5zZWNvbmRzID09PSAnbnVtYmVyJykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIHRpbWVvdXQuc2Vjb25kcycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghKCduYW5vcycgaW4gb2JqLnRpbWVvdXQpIHx8XHJcbiAgICAgICAgICAgICAgICAhKHR5cGVvZiBvYmoudGltZW91dC5uYW5vcyA9PT0gJ251bWJlcicpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0Lm5hbm9zJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LnRpbWVvdXQgPSBvYmoudGltZW91dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iai50aW1lb3V0ID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgICAgICBEVVJBVElPTl9SRUdFWC50ZXN0KG9iai50aW1lb3V0KSkge1xyXG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0UGFydHMgPSBvYmoudGltZW91dFxyXG4gICAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCBvYmoudGltZW91dC5sZW5ndGggLSAxKVxyXG4gICAgICAgICAgICAgICAgLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgIHJlc3VsdC50aW1lb3V0ID0ge1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kczogdGltZW91dFBhcnRzWzBdIHwgMCxcclxuICAgICAgICAgICAgICAgIG5hbm9zOiAoKF9hID0gdGltZW91dFBhcnRzWzFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSB8IDAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCdtYXhSZXF1ZXN0Qnl0ZXMnIGluIG9iaikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLm1heFJlcXVlc3RCeXRlcyAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgbWF4UmVxdWVzdEJ5dGVzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5tYXhSZXF1ZXN0Qnl0ZXMgPSBvYmoubWF4UmVxdWVzdEJ5dGVzO1xyXG4gICAgfVxyXG4gICAgaWYgKCdtYXhSZXNwb25zZUJ5dGVzJyBpbiBvYmopIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9iai5tYXhSZXNwb25zZUJ5dGVzICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCBtYXhSZXF1ZXN0Qnl0ZXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0Lm1heFJlc3BvbnNlQnl0ZXMgPSBvYmoubWF4UmVzcG9uc2VCeXRlcztcclxuICAgIH1cclxuICAgIGlmICgncmV0cnlQb2xpY3knIGluIG9iaikge1xyXG4gICAgICAgIGlmICgnaGVkZ2luZ1BvbGljeScgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiByZXRyeVBvbGljeSBhbmQgaGVkZ2luZ1BvbGljeSBjYW5ub3QgYm90aCBiZSBzcGVjaWZpZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5yZXRyeVBvbGljeSA9IHZhbGlkYXRlUmV0cnlQb2xpY3kob2JqLnJldHJ5UG9saWN5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnaGVkZ2luZ1BvbGljeScgaW4gb2JqKSB7XHJcbiAgICAgICAgcmVzdWx0LmhlZGdpbmdQb2xpY3kgPSB2YWxpZGF0ZUhlZGdpbmdQb2xpY3kob2JqLmhlZGdpbmdQb2xpY3kpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVJldHJ5VGhyb3R0bGluZyhvYmopIHtcclxuICAgIGlmICghKCdtYXhUb2tlbnMnIGluIG9iaikgfHxcclxuICAgICAgICB0eXBlb2Ygb2JqLm1heFRva2VucyAhPT0gJ251bWJlcicgfHxcclxuICAgICAgICBvYmoubWF4VG9rZW5zIDw9IDAgfHxcclxuICAgICAgICBvYmoubWF4VG9rZW5zID4gMTAwMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXRyeVRocm90dGxpbmc6IG1heFRva2VucyBtdXN0IGJlIGEgbnVtYmVyIGluICgwLCAxMDAwXScpO1xyXG4gICAgfVxyXG4gICAgaWYgKCEoJ3Rva2VuUmF0aW8nIGluIG9iaikgfHxcclxuICAgICAgICB0eXBlb2Ygb2JqLnRva2VuUmF0aW8gIT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgb2JqLnRva2VuUmF0aW8gPD0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXRyeVRocm90dGxpbmc6IHRva2VuUmF0aW8gbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtYXhUb2tlbnM6ICtvYmoubWF4VG9rZW5zLnRvRml4ZWQoMyksXHJcbiAgICAgICAgdG9rZW5SYXRpbzogK29iai50b2tlblJhdGlvLnRvRml4ZWQoMyksXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMudmFsaWRhdGVSZXRyeVRocm90dGxpbmcgPSB2YWxpZGF0ZVJldHJ5VGhyb3R0bGluZztcclxuZnVuY3Rpb24gdmFsaWRhdGVTZXJ2aWNlQ29uZmlnKG9iaikge1xyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIGxvYWRCYWxhbmNpbmdDb25maWc6IFtdLFxyXG4gICAgICAgIG1ldGhvZENvbmZpZzogW10sXHJcbiAgICB9O1xyXG4gICAgaWYgKCdsb2FkQmFsYW5jaW5nUG9saWN5JyBpbiBvYmopIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9iai5sb2FkQmFsYW5jaW5nUG9saWN5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXN1bHQubG9hZEJhbGFuY2luZ1BvbGljeSA9IG9iai5sb2FkQmFsYW5jaW5nUG9saWN5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnOiBpbnZhbGlkIGxvYWRCYWxhbmNpbmdQb2xpY3knKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoJ2xvYWRCYWxhbmNpbmdDb25maWcnIGluIG9iaikge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5sb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBvYmoubG9hZEJhbGFuY2luZ0NvbmZpZykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmxvYWRCYWxhbmNpbmdDb25maWcucHVzaCgoMCwgbG9hZF9iYWxhbmNlcl8xLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZykoY29uZmlnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogaW52YWxpZCBsb2FkQmFsYW5jaW5nQ29uZmlnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCdtZXRob2RDb25maWcnIGluIG9iaikge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5tZXRob2RDb25maWcpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWV0aG9kQ29uZmlnIG9mIG9iai5tZXRob2RDb25maWcpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5tZXRob2RDb25maWcucHVzaCh2YWxpZGF0ZU1ldGhvZENvbmZpZyhtZXRob2RDb25maWcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICgncmV0cnlUaHJvdHRsaW5nJyBpbiBvYmopIHtcclxuICAgICAgICByZXN1bHQucmV0cnlUaHJvdHRsaW5nID0gdmFsaWRhdGVSZXRyeVRocm90dGxpbmcob2JqLnJldHJ5VGhyb3R0bGluZyk7XHJcbiAgICB9XHJcbiAgICAvLyBWYWxpZGF0ZSBtZXRob2QgbmFtZSB1bmlxdWVuZXNzXHJcbiAgICBjb25zdCBzZWVuTWV0aG9kTmFtZXMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgbWV0aG9kQ29uZmlnIG9mIHJlc3VsdC5tZXRob2RDb25maWcpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbWV0aG9kQ29uZmlnLm5hbWUpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBzZWVuTmFtZSBvZiBzZWVuTWV0aG9kTmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlZW5OYW1lLnNlcnZpY2UgJiZcclxuICAgICAgICAgICAgICAgICAgICBuYW1lLm1ldGhvZCA9PT0gc2Vlbk5hbWUubWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlcnZpY2UgY29uZmlnOiBkdXBsaWNhdGUgbmFtZSAke25hbWUuc2VydmljZX0vJHtuYW1lLm1ldGhvZH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWVuTWV0aG9kTmFtZXMucHVzaChuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMudmFsaWRhdGVTZXJ2aWNlQ29uZmlnID0gdmFsaWRhdGVTZXJ2aWNlQ29uZmlnO1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUNhbmFyeUNvbmZpZyhvYmopIHtcclxuICAgIGlmICghKCdzZXJ2aWNlQ29uZmlnJyBpbiBvYmopKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogbWlzc2luZyBzZXJ2aWNlIGNvbmZpZycpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIHNlcnZpY2VDb25maWc6IHZhbGlkYXRlU2VydmljZUNvbmZpZyhvYmouc2VydmljZUNvbmZpZyksXHJcbiAgICB9O1xyXG4gICAgaWYgKCdjbGllbnRMYW5ndWFnZScgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmNsaWVudExhbmd1YWdlKSkge1xyXG4gICAgICAgICAgICByZXN1bHQuY2xpZW50TGFuZ3VhZ2UgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5nIG9mIG9iai5jbGllbnRMYW5ndWFnZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5nID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jbGllbnRMYW5ndWFnZS5wdXNoKGxhbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRMYW5ndWFnZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudExhbmd1YWdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCdjbGllbnRIb3N0bmFtZScgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmNsaWVudEhvc3RuYW1lKSkge1xyXG4gICAgICAgICAgICByZXN1bHQuY2xpZW50SG9zdG5hbWUgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5nIG9mIG9iai5jbGllbnRIb3N0bmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5nID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jbGllbnRIb3N0bmFtZS5wdXNoKGxhbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRIb3N0bmFtZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudEhvc3RuYW1lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCdwZXJjZW50YWdlJyBpbiBvYmopIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9iai5wZXJjZW50YWdlID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgICAwIDw9IG9iai5wZXJjZW50YWdlICYmXHJcbiAgICAgICAgICAgIG9iai5wZXJjZW50YWdlIDw9IDEwMCkge1xyXG4gICAgICAgICAgICByZXN1bHQucGVyY2VudGFnZSA9IG9iai5wZXJjZW50YWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBwZXJjZW50YWdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gVmFsaWRhdGUgdGhhdCBubyB1bmV4cGVjdGVkIGZpZWxkcyBhcmUgcHJlc2VudFxyXG4gICAgY29uc3QgYWxsb3dlZEZpZWxkcyA9IFtcclxuICAgICAgICAnY2xpZW50TGFuZ3VhZ2UnLFxyXG4gICAgICAgICdwZXJjZW50YWdlJyxcclxuICAgICAgICAnY2xpZW50SG9zdG5hbWUnLFxyXG4gICAgICAgICdzZXJ2aWNlQ29uZmlnJyxcclxuICAgIF07XHJcbiAgICBmb3IgKGNvbnN0IGZpZWxkIGluIG9iaikge1xyXG4gICAgICAgIGlmICghYWxsb3dlZEZpZWxkcy5pbmNsdWRlcyhmaWVsZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogdW5leHBlY3RlZCBmaWVsZCAke2ZpZWxkfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVBbmRTZWxlY3RDYW5hcnlDb25maWcob2JqLCBwZXJjZW50YWdlKSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBsaXN0Jyk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBvYmopIHtcclxuICAgICAgICBjb25zdCB2YWxpZGF0ZWRDb25maWcgPSB2YWxpZGF0ZUNhbmFyeUNvbmZpZyhjb25maWcpO1xyXG4gICAgICAgIC8qIEZvciBlYWNoIGZpZWxkLCB3ZSBjaGVjayBpZiBpdCBpcyBwcmVzZW50LCB0aGVuIG9ubHkgZGlzY2FyZCB0aGVcclxuICAgICAgICAgKiBjb25maWcgaWYgdGhlIGZpZWxkIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJyZW50IGNsaWVudCAqL1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVkQ29uZmlnLnBlcmNlbnRhZ2UgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPiB2YWxpZGF0ZWRDb25maWcucGVyY2VudGFnZSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdGVkQ29uZmlnLmNsaWVudEhvc3RuYW1lKSkge1xyXG4gICAgICAgICAgICBsZXQgaG9zdG5hbWVNYXRjaGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaG9zdG5hbWUgb2YgdmFsaWRhdGVkQ29uZmlnLmNsaWVudEhvc3RuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9zdG5hbWUgPT09IG9zLmhvc3RuYW1lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZU1hdGNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaG9zdG5hbWVNYXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0ZWRDb25maWcuY2xpZW50TGFuZ3VhZ2UpKSB7XHJcbiAgICAgICAgICAgIGxldCBsYW5ndWFnZU1hdGNoZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5ndWFnZSBvZiB2YWxpZGF0ZWRDb25maWcuY2xpZW50TGFuZ3VhZ2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZSA9PT0gQ0xJRU5UX0xBTkdVQUdFX1NUUklORykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlTWF0Y2hlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFsYW5ndWFnZU1hdGNoZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRDb25maWcuc2VydmljZUNvbmZpZztcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignTm8gbWF0Y2hpbmcgc2VydmljZSBjb25maWcgZm91bmQnKTtcclxufVxyXG4vKipcclxuICogRmluZCB0aGUgXCJncnBjX2NvbmZpZ1wiIHJlY29yZCBhbW9uZyB0aGUgVFhUIHJlY29yZHMsIHBhcnNlIGl0cyB2YWx1ZSBhcyBKU09OLCB2YWxpZGF0ZSBpdHMgY29udGVudHMsXHJcbiAqIGFuZCBzZWxlY3QgYSBzZXJ2aWNlIGNvbmZpZyB3aXRoIHNlbGVjdGlvbiBmaWVsZHMgdGhhdCBhbGwgbWF0Y2ggdGhpcyBjbGllbnQuIE1vc3Qgb2YgdGhlc2Ugc3RlcHNcclxuICogY2FuIGZhaWwgd2l0aCBhbiBlcnJvcjsgdGhlIGNhbGxlciBtdXN0IGhhbmRsZSBhbnkgZXJyb3JzIHRocm93biB0aGlzIHdheS5cclxuICogQHBhcmFtIHR4dFJlY29yZCBUaGUgVFhUIHJlY29yZCBhcnJheSB0aGF0IGlzIG91dHB1dCBmcm9tIGEgc3VjY2Vzc2Z1bCBjYWxsIHRvIGRucy5yZXNvbHZlVHh0XHJcbiAqIEBwYXJhbSBwZXJjZW50YWdlIEEgbnVtYmVyIGNob3NlbiBmcm9tIHRoZSByYW5nZSBbMCwgMTAwKSB0aGF0IGlzIHVzZWQgdG8gc2VsZWN0IHdoaWNoIGNvbmZpZyB0byB1c2VcclxuICogQHJldHVybiBUaGUgc2VydmljZSBjb25maWd1cmF0aW9uIHRvIHVzZSwgZ2l2ZW4gdGhlIHBlcmNlbnRhZ2UgdmFsdWUsIG9yIG51bGwgaWYgdGhlIHNlcnZpY2UgY29uZmlnXHJcbiAqICAgICBkYXRhIGhhcyBhIHZhbGlkIGZvcm1hdCBidXQgbm9uZSBvZiB0aGUgb3B0aW9ucyBtYXRjaCB0aGUgY3VycmVudCBjbGllbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyh0eHRSZWNvcmQsIHBlcmNlbnRhZ2UpIHtcclxuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHR4dFJlY29yZCkge1xyXG4gICAgICAgIGlmIChyZWNvcmQubGVuZ3RoID4gMCAmJiByZWNvcmRbMF0uc3RhcnRzV2l0aCgnZ3JwY19jb25maWc9JykpIHtcclxuICAgICAgICAgICAgLyogVHJlYXQgdGhlIGxpc3Qgb2Ygc3RyaW5ncyBpbiB0aGlzIHJlY29yZCBhcyBhIHNpbmdsZSBzdHJpbmcgYW5kIHJlbW92ZVxyXG4gICAgICAgICAgICAgKiBcImdycGNfY29uZmlnPVwiIGZyb20gdGhlIGJlZ2lubmluZy4gVGhlIHJlc3Qgc2hvdWxkIGJlIGEgSlNPTiBzdHJpbmcgKi9cclxuICAgICAgICAgICAgY29uc3QgcmVjb3JkU3RyaW5nID0gcmVjb3JkLmpvaW4oJycpLnN1YnN0cmluZygnZ3JwY19jb25maWc9Jy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBjb25zdCByZWNvcmRKc29uID0gSlNPTi5wYXJzZShyZWNvcmRTdHJpbmcpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVBbmRTZWxlY3RDYW5hcnlDb25maWcocmVjb3JkSnNvbiwgcGVyY2VudGFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZXhwb3J0cy5leHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyA9IGV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2aWNlLWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/service-config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/status-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/status-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.StatusBuilder = void 0;\r\n/**\r\n * A builder for gRPC status objects.\r\n */\r\nclass StatusBuilder {\r\n    constructor() {\r\n        this.code = null;\r\n        this.details = null;\r\n        this.metadata = null;\r\n    }\r\n    /**\r\n     * Adds a status code to the builder.\r\n     */\r\n    withCode(code) {\r\n        this.code = code;\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds details to the builder.\r\n     */\r\n    withDetails(details) {\r\n        this.details = details;\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds metadata to the builder.\r\n     */\r\n    withMetadata(metadata) {\r\n        this.metadata = metadata;\r\n        return this;\r\n    }\r\n    /**\r\n     * Builds the status object.\r\n     */\r\n    build() {\r\n        const status = {};\r\n        if (this.code !== null) {\r\n            status.code = this.code;\r\n        }\r\n        if (this.details !== null) {\r\n            status.details = this.details;\r\n        }\r\n        if (this.metadata !== null) {\r\n            status.metadata = this.metadata;\r\n        }\r\n        return status;\r\n    }\r\n}\r\nexports.StatusBuilder = StatusBuilder;\r\n//# sourceMappingURL=status-builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RhdHVzLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RhdHVzLWJ1aWxkZXIuanM/MGRlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5TdGF0dXNCdWlsZGVyID0gdm9pZCAwO1xyXG4vKipcclxuICogQSBidWlsZGVyIGZvciBnUlBDIHN0YXR1cyBvYmplY3RzLlxyXG4gKi9cclxuY2xhc3MgU3RhdHVzQnVpbGRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNvZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzdGF0dXMgY29kZSB0byB0aGUgYnVpbGRlci5cclxuICAgICAqL1xyXG4gICAgd2l0aENvZGUoY29kZSkge1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgZGV0YWlscyB0byB0aGUgYnVpbGRlci5cclxuICAgICAqL1xyXG4gICAgd2l0aERldGFpbHMoZGV0YWlscykge1xyXG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgbWV0YWRhdGEgdG8gdGhlIGJ1aWxkZXIuXHJcbiAgICAgKi9cclxuICAgIHdpdGhNZXRhZGF0YShtZXRhZGF0YSkge1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGRzIHRoZSBzdGF0dXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBidWlsZCgpIHtcclxuICAgICAgICBjb25zdCBzdGF0dXMgPSB7fTtcclxuICAgICAgICBpZiAodGhpcy5jb2RlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cy5jb2RlID0gdGhpcy5jb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kZXRhaWxzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzID0gdGhpcy5kZXRhaWxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGF0dXMubWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RhdHVzO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU3RhdHVzQnVpbGRlciA9IFN0YXR1c0J1aWxkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXR1cy1idWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/stream-decoder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.StreamDecoder = void 0;\r\nvar ReadState;\r\n(function (ReadState) {\r\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\r\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\r\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\r\n})(ReadState || (ReadState = {}));\r\nclass StreamDecoder {\r\n    constructor(maxReadMessageLength) {\r\n        this.maxReadMessageLength = maxReadMessageLength;\r\n        this.readState = ReadState.NO_DATA;\r\n        this.readCompressFlag = Buffer.alloc(1);\r\n        this.readPartialSize = Buffer.alloc(4);\r\n        this.readSizeRemaining = 4;\r\n        this.readMessageSize = 0;\r\n        this.readPartialMessage = [];\r\n        this.readMessageRemaining = 0;\r\n    }\r\n    write(data) {\r\n        let readHead = 0;\r\n        let toRead;\r\n        const result = [];\r\n        while (readHead < data.length) {\r\n            switch (this.readState) {\r\n                case ReadState.NO_DATA:\r\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\r\n                    readHead += 1;\r\n                    this.readState = ReadState.READING_SIZE;\r\n                    this.readPartialSize.fill(0);\r\n                    this.readSizeRemaining = 4;\r\n                    this.readMessageSize = 0;\r\n                    this.readMessageRemaining = 0;\r\n                    this.readPartialMessage = [];\r\n                    break;\r\n                case ReadState.READING_SIZE:\r\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\r\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\r\n                    this.readSizeRemaining -= toRead;\r\n                    readHead += toRead;\r\n                    // readSizeRemaining >=0 here\r\n                    if (this.readSizeRemaining === 0) {\r\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\r\n                        if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {\r\n                            throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);\r\n                        }\r\n                        this.readMessageRemaining = this.readMessageSize;\r\n                        if (this.readMessageRemaining > 0) {\r\n                            this.readState = ReadState.READING_MESSAGE;\r\n                        }\r\n                        else {\r\n                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);\r\n                            this.readState = ReadState.NO_DATA;\r\n                            result.push(message);\r\n                        }\r\n                    }\r\n                    break;\r\n                case ReadState.READING_MESSAGE:\r\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\r\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\r\n                    this.readMessageRemaining -= toRead;\r\n                    readHead += toRead;\r\n                    // readMessageRemaining >=0 here\r\n                    if (this.readMessageRemaining === 0) {\r\n                        // At this point, we have read a full message\r\n                        const framedMessageBuffers = [\r\n                            this.readCompressFlag,\r\n                            this.readPartialSize,\r\n                        ].concat(this.readPartialMessage);\r\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\r\n                        this.readState = ReadState.NO_DATA;\r\n                        result.push(framedMessage);\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw new Error('Unexpected read state');\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.StreamDecoder = StreamDecoder;\r\n//# sourceMappingURL=stream-decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RyZWFtLWRlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixzQkFBc0IsS0FBSywwQkFBMEI7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdHJlYW0tZGVjb2Rlci5qcz9lYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlN0cmVhbURlY29kZXIgPSB2b2lkIDA7XHJcbnZhciBSZWFkU3RhdGU7XHJcbihmdW5jdGlvbiAoUmVhZFN0YXRlKSB7XHJcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiTk9fREFUQVwiXSA9IDBdID0gXCJOT19EQVRBXCI7XHJcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiUkVBRElOR19TSVpFXCJdID0gMV0gPSBcIlJFQURJTkdfU0laRVwiO1xyXG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIlJFQURJTkdfTUVTU0FHRVwiXSA9IDJdID0gXCJSRUFESU5HX01FU1NBR0VcIjtcclxufSkoUmVhZFN0YXRlIHx8IChSZWFkU3RhdGUgPSB7fSkpO1xyXG5jbGFzcyBTdHJlYW1EZWNvZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG1heFJlYWRNZXNzYWdlTGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5tYXhSZWFkTWVzc2FnZUxlbmd0aCA9IG1heFJlYWRNZXNzYWdlTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLk5PX0RBVEE7XHJcbiAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnID0gQnVmZmVyLmFsbG9jKDEpO1xyXG4gICAgICAgIHRoaXMucmVhZFBhcnRpYWxTaXplID0gQnVmZmVyLmFsbG9jKDQpO1xyXG4gICAgICAgIHRoaXMucmVhZFNpemVSZW1haW5pbmcgPSA0O1xyXG4gICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gMDtcclxuICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZSA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPSAwO1xyXG4gICAgfVxyXG4gICAgd3JpdGUoZGF0YSkge1xyXG4gICAgICAgIGxldCByZWFkSGVhZCA9IDA7XHJcbiAgICAgICAgbGV0IHRvUmVhZDtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICB3aGlsZSAocmVhZEhlYWQgPCBkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucmVhZFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFJlYWRTdGF0ZS5OT19EQVRBOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZENvbXByZXNzRmxhZyA9IGRhdGEuc2xpY2UocmVhZEhlYWQsIHJlYWRIZWFkICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZEhlYWQgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5SRUFESU5HX1NJWkU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbFNpemUuZmlsbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTaXplUmVtYWluaW5nID0gNDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlU2l6ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUmVhZFN0YXRlLlJFQURJTkdfU0laRTpcclxuICAgICAgICAgICAgICAgICAgICB0b1JlYWQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIHJlYWRIZWFkLCB0aGlzLnJlYWRTaXplUmVtYWluaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmNvcHkodGhpcy5yZWFkUGFydGlhbFNpemUsIDQgLSB0aGlzLnJlYWRTaXplUmVtYWluaW5nLCByZWFkSGVhZCwgcmVhZEhlYWQgKyB0b1JlYWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFNpemVSZW1haW5pbmcgLT0gdG9SZWFkO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRIZWFkICs9IHRvUmVhZDtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkU2l6ZVJlbWFpbmluZyA+PTAgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRTaXplUmVtYWluaW5nID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gdGhpcy5yZWFkUGFydGlhbFNpemUucmVhZFVJbnQzMkJFKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhSZWFkTWVzc2FnZUxlbmd0aCAhPT0gLTEgJiYgdGhpcy5yZWFkTWVzc2FnZVNpemUgPiB0aGlzLm1heFJlYWRNZXNzYWdlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY2VpdmVkIG1lc3NhZ2UgbGFyZ2VyIHRoYW4gbWF4ICgke3RoaXMucmVhZE1lc3NhZ2VTaXplfSB2cyAke3RoaXMubWF4UmVhZE1lc3NhZ2VMZW5ndGh9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPSB0aGlzLnJlYWRNZXNzYWdlU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5SRUFESU5HX01FU1NBR0U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5yZWFkQ29tcHJlc3NGbGFnLCB0aGlzLnJlYWRQYXJ0aWFsU2l6ZV0sIDUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuUkVBRElOR19NRVNTQUdFOlxyXG4gICAgICAgICAgICAgICAgICAgIHRvUmVhZCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gcmVhZEhlYWQsIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlLnB1c2goZGF0YS5zbGljZShyZWFkSGVhZCwgcmVhZEhlYWQgKyB0b1JlYWQpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nIC09IHRvUmVhZDtcclxuICAgICAgICAgICAgICAgICAgICByZWFkSGVhZCArPSB0b1JlYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZE1lc3NhZ2VSZW1haW5pbmcgPj0wIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHJlYWQgYSBmdWxsIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJhbWVkTWVzc2FnZUJ1ZmZlcnMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDb21wcmVzc0ZsYWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQodGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZWRNZXNzYWdlID0gQnVmZmVyLmNvbmNhdChmcmFtZWRNZXNzYWdlQnVmZmVycywgdGhpcy5yZWFkTWVzc2FnZVNpemUgKyA1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWVkTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVhZCBzdGF0ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TdHJlYW1EZWNvZGVyID0gU3RyZWFtRGVjb2RlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyZWFtLWRlY29kZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-address.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2021 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.stringToSubchannelAddress = exports.subchannelAddressToString = exports.subchannelAddressEqual = exports.isTcpSubchannelAddress = void 0;\r\nconst net_1 = __webpack_require__(/*! net */ \"net\");\r\nfunction isTcpSubchannelAddress(address) {\r\n    return 'port' in address;\r\n}\r\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\r\nfunction subchannelAddressEqual(address1, address2) {\r\n    if (!address1 && !address2) {\r\n        return true;\r\n    }\r\n    if (!address1 || !address2) {\r\n        return false;\r\n    }\r\n    if (isTcpSubchannelAddress(address1)) {\r\n        return (isTcpSubchannelAddress(address2) &&\r\n            address1.host === address2.host &&\r\n            address1.port === address2.port);\r\n    }\r\n    else {\r\n        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\r\n    }\r\n}\r\nexports.subchannelAddressEqual = subchannelAddressEqual;\r\nfunction subchannelAddressToString(address) {\r\n    if (isTcpSubchannelAddress(address)) {\r\n        return address.host + ':' + address.port;\r\n    }\r\n    else {\r\n        return address.path;\r\n    }\r\n}\r\nexports.subchannelAddressToString = subchannelAddressToString;\r\nconst DEFAULT_PORT = 443;\r\nfunction stringToSubchannelAddress(addressString, port) {\r\n    if ((0, net_1.isIP)(addressString)) {\r\n        return {\r\n            host: addressString,\r\n            port: port !== null && port !== void 0 ? port : DEFAULT_PORT,\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            path: addressString,\r\n        };\r\n    }\r\n}\r\nexports.stringToSubchannelAddress = stringToSubchannelAddress;\r\n//# sourceMappingURL=subchannel-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLEdBQUcsaUNBQWlDLEdBQUcsOEJBQThCLEdBQUcsOEJBQThCO0FBQ3ZJLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWFkZHJlc3MuanM/ODJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc0VxdWFsID0gZXhwb3J0cy5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzID0gdm9pZCAwO1xyXG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XHJcbmZ1bmN0aW9uIGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzcykge1xyXG4gICAgcmV0dXJuICdwb3J0JyBpbiBhZGRyZXNzO1xyXG59XHJcbmV4cG9ydHMuaXNUY3BTdWJjaGFubmVsQWRkcmVzcyA9IGlzVGNwU3ViY2hhbm5lbEFkZHJlc3M7XHJcbmZ1bmN0aW9uIHN1YmNoYW5uZWxBZGRyZXNzRXF1YWwoYWRkcmVzczEsIGFkZHJlc3MyKSB7XHJcbiAgICBpZiAoIWFkZHJlc3MxICYmICFhZGRyZXNzMikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFhZGRyZXNzMSB8fCAhYWRkcmVzczIpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzMSkpIHtcclxuICAgICAgICByZXR1cm4gKGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzczIpICYmXHJcbiAgICAgICAgICAgIGFkZHJlc3MxLmhvc3QgPT09IGFkZHJlc3MyLmhvc3QgJiZcclxuICAgICAgICAgICAgYWRkcmVzczEucG9ydCA9PT0gYWRkcmVzczIucG9ydCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gIWlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzczIpICYmIGFkZHJlc3MxLnBhdGggPT09IGFkZHJlc3MyLnBhdGg7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc0VxdWFsID0gc3ViY2hhbm5lbEFkZHJlc3NFcXVhbDtcclxuZnVuY3Rpb24gc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKSB7XHJcbiAgICBpZiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSkge1xyXG4gICAgICAgIHJldHVybiBhZGRyZXNzLmhvc3QgKyAnOicgKyBhZGRyZXNzLnBvcnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYWRkcmVzcy5wYXRoO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyA9IHN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmc7XHJcbmNvbnN0IERFRkFVTFRfUE9SVCA9IDQ0MztcclxuZnVuY3Rpb24gc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzU3RyaW5nLCBwb3J0KSB7XHJcbiAgICBpZiAoKDAsIG5ldF8xLmlzSVApKGFkZHJlc3NTdHJpbmcpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaG9zdDogYWRkcmVzc1N0cmluZyxcclxuICAgICAgICAgICAgcG9ydDogcG9ydCAhPT0gbnVsbCAmJiBwb3J0ICE9PSB2b2lkIDAgPyBwb3J0IDogREVGQVVMVF9QT1JULFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwYXRoOiBhZGRyZXNzU3RyaW5nLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzID0gc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-call.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Http2SubchannelCall = void 0;\r\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\r\nconst os = __webpack_require__(/*! os */ \"os\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\r\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst TRACER_NAME = 'subchannel_call';\r\n/**\r\n * Should do approximately the same thing as util.getSystemErrorName but the\r\n * TypeScript types don't have that function for some reason so I just made my\r\n * own.\r\n * @param errno\r\n */\r\nfunction getSystemErrorName(errno) {\r\n    for (const [name, num] of Object.entries(os.constants.errno)) {\r\n        if (num === errno) {\r\n            return name;\r\n        }\r\n    }\r\n    return 'Unknown system error ' + errno;\r\n}\r\nclass Http2SubchannelCall {\r\n    constructor(http2Stream, callEventTracker, listener, transport, callId) {\r\n        var _a;\r\n        this.http2Stream = http2Stream;\r\n        this.callEventTracker = callEventTracker;\r\n        this.listener = listener;\r\n        this.transport = transport;\r\n        this.callId = callId;\r\n        this.isReadFilterPending = false;\r\n        this.isPushPending = false;\r\n        this.canPush = false;\r\n        /**\r\n         * Indicates that an 'end' event has come from the http2 stream, so there\r\n         * will be no more data events.\r\n         */\r\n        this.readsClosed = false;\r\n        this.statusOutput = false;\r\n        this.unpushedReadMessages = [];\r\n        // Status code mapped from :status. To be used if grpc-status is not received\r\n        this.mappedStatusCode = constants_1.Status.UNKNOWN;\r\n        // This is populated (non-null) if and only if the call has ended\r\n        this.finalStatus = null;\r\n        this.internalError = null;\r\n        const maxReceiveMessageLength = (_a = transport.getOptions()['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\r\n        this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);\r\n        http2Stream.on('response', (headers, flags) => {\r\n            let headersString = '';\r\n            for (const header of Object.keys(headers)) {\r\n                headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\r\n            }\r\n            this.trace('Received server headers:\\n' + headersString);\r\n            switch (headers[':status']) {\r\n                // TODO(murgatroid99): handle 100 and 101\r\n                case 400:\r\n                    this.mappedStatusCode = constants_1.Status.INTERNAL;\r\n                    break;\r\n                case 401:\r\n                    this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\r\n                    break;\r\n                case 403:\r\n                    this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\r\n                    break;\r\n                case 404:\r\n                    this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\r\n                    break;\r\n                case 429:\r\n                case 502:\r\n                case 503:\r\n                case 504:\r\n                    this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\r\n                    break;\r\n                default:\r\n                    this.mappedStatusCode = constants_1.Status.UNKNOWN;\r\n            }\r\n            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\r\n                this.handleTrailers(headers);\r\n            }\r\n            else {\r\n                let metadata;\r\n                try {\r\n                    metadata = metadata_1.Metadata.fromHttp2Headers(headers);\r\n                }\r\n                catch (error) {\r\n                    this.endCall({\r\n                        code: constants_1.Status.UNKNOWN,\r\n                        details: error.message,\r\n                        metadata: new metadata_1.Metadata(),\r\n                    });\r\n                    return;\r\n                }\r\n                this.listener.onReceiveMetadata(metadata);\r\n            }\r\n        });\r\n        http2Stream.on('trailers', (headers) => {\r\n            this.handleTrailers(headers);\r\n        });\r\n        http2Stream.on('data', (data) => {\r\n            /* If the status has already been output, allow the http2 stream to\r\n             * drain without processing the data. */\r\n            if (this.statusOutput) {\r\n                return;\r\n            }\r\n            this.trace('receive HTTP/2 data frame of length ' + data.length);\r\n            let messages;\r\n            try {\r\n                messages = this.decoder.write(data);\r\n            }\r\n            catch (e) {\r\n                this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);\r\n                return;\r\n            }\r\n            for (const message of messages) {\r\n                this.trace('parsed message of length ' + message.length);\r\n                this.callEventTracker.addMessageReceived();\r\n                this.tryPush(message);\r\n            }\r\n        });\r\n        http2Stream.on('end', () => {\r\n            this.readsClosed = true;\r\n            this.maybeOutputStatus();\r\n        });\r\n        http2Stream.on('close', () => {\r\n            /* Use process.next tick to ensure that this code happens after any\r\n             * \"error\" event that may be emitted at about the same time, so that\r\n             * we can bubble up the error message from that event. */\r\n            process.nextTick(() => {\r\n                var _a;\r\n                this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\r\n                /* If we have a final status with an OK status code, that means that\r\n                 * we have received all of the messages and we have processed the\r\n                 * trailers and the call completed successfully, so it doesn't matter\r\n                 * how the stream ends after that */\r\n                if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\r\n                    return;\r\n                }\r\n                let code;\r\n                let details = '';\r\n                switch (http2Stream.rstCode) {\r\n                    case http2.constants.NGHTTP2_NO_ERROR:\r\n                        /* If we get a NO_ERROR code and we already have a status, the\r\n                         * stream completed properly and we just haven't fully processed\r\n                         * it yet */\r\n                        if (this.finalStatus !== null) {\r\n                            return;\r\n                        }\r\n                        code = constants_1.Status.INTERNAL;\r\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\r\n                        break;\r\n                    case http2.constants.NGHTTP2_REFUSED_STREAM:\r\n                        code = constants_1.Status.UNAVAILABLE;\r\n                        details = 'Stream refused by server';\r\n                        break;\r\n                    case http2.constants.NGHTTP2_CANCEL:\r\n                        code = constants_1.Status.CANCELLED;\r\n                        details = 'Call cancelled';\r\n                        break;\r\n                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\r\n                        code = constants_1.Status.RESOURCE_EXHAUSTED;\r\n                        details = 'Bandwidth exhausted or memory limit exceeded';\r\n                        break;\r\n                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\r\n                        code = constants_1.Status.PERMISSION_DENIED;\r\n                        details = 'Protocol not secure enough';\r\n                        break;\r\n                    case http2.constants.NGHTTP2_INTERNAL_ERROR:\r\n                        code = constants_1.Status.INTERNAL;\r\n                        if (this.internalError === null) {\r\n                            /* This error code was previously handled in the default case, and\r\n                             * there are several instances of it online, so I wanted to\r\n                             * preserve the original error message so that people find existing\r\n                             * information in searches, but also include the more recognizable\r\n                             * \"Internal server error\" message. */\r\n                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\r\n                        }\r\n                        else {\r\n                            if (this.internalError.code === 'ECONNRESET' ||\r\n                                this.internalError.code === 'ETIMEDOUT') {\r\n                                code = constants_1.Status.UNAVAILABLE;\r\n                                details = this.internalError.message;\r\n                            }\r\n                            else {\r\n                                /* The \"Received RST_STREAM with code ...\" error is preserved\r\n                                 * here for continuity with errors reported online, but the\r\n                                 * error message at the end will probably be more relevant in\r\n                                 * most cases. */\r\n                                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\r\n                            }\r\n                        }\r\n                        break;\r\n                    default:\r\n                        code = constants_1.Status.INTERNAL;\r\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\r\n                }\r\n                // This is a no-op if trailers were received at all.\r\n                // This is OK, because status codes emitted here correspond to more\r\n                // catastrophic issues that prevent us from receiving trailers in the\r\n                // first place.\r\n                this.endCall({\r\n                    code,\r\n                    details,\r\n                    metadata: new metadata_1.Metadata(),\r\n                    rstCode: http2Stream.rstCode,\r\n                });\r\n            });\r\n        });\r\n        http2Stream.on('error', (err) => {\r\n            /* We need an error handler here to stop \"Uncaught Error\" exceptions\r\n             * from bubbling up. However, errors here should all correspond to\r\n             * \"close\" events, where we will handle the error more granularly */\r\n            /* Specifically looking for stream errors that were *not* constructed\r\n             * from a RST_STREAM response here:\r\n             * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\r\n             */\r\n            if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\r\n                this.trace('Node error event: message=' +\r\n                    err.message +\r\n                    ' code=' +\r\n                    err.code +\r\n                    ' errno=' +\r\n                    getSystemErrorName(err.errno) +\r\n                    ' syscall=' +\r\n                    err.syscall);\r\n                this.internalError = err;\r\n            }\r\n            this.callEventTracker.onStreamEnd(false);\r\n        });\r\n    }\r\n    onDisconnect() {\r\n        this.endCall({\r\n            code: constants_1.Status.UNAVAILABLE,\r\n            details: 'Connection dropped',\r\n            metadata: new metadata_1.Metadata(),\r\n        });\r\n    }\r\n    outputStatus() {\r\n        /* Precondition: this.finalStatus !== null */\r\n        if (!this.statusOutput) {\r\n            this.statusOutput = true;\r\n            this.trace('ended with status: code=' +\r\n                this.finalStatus.code +\r\n                ' details=\"' +\r\n                this.finalStatus.details +\r\n                '\"');\r\n            this.callEventTracker.onCallEnd(this.finalStatus);\r\n            /* We delay the actual action of bubbling up the status to insulate the\r\n             * cleanup code in this class from any errors that may be thrown in the\r\n             * upper layers as a result of bubbling up the status. In particular,\r\n             * if the status is not OK, the \"error\" event may be emitted\r\n             * synchronously at the top level, which will result in a thrown error if\r\n             * the user does not handle that event. */\r\n            process.nextTick(() => {\r\n                this.listener.onReceiveStatus(this.finalStatus);\r\n            });\r\n            /* Leave the http2 stream in flowing state to drain incoming messages, to\r\n             * ensure that the stream closure completes. The call stream already does\r\n             * not push more messages after the status is output, so the messages go\r\n             * nowhere either way. */\r\n            this.http2Stream.resume();\r\n        }\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);\r\n    }\r\n    /**\r\n     * On first call, emits a 'status' event with the given StatusObject.\r\n     * Subsequent calls are no-ops.\r\n     * @param status The status of the call.\r\n     */\r\n    endCall(status) {\r\n        /* If the status is OK and a new status comes in (e.g. from a\r\n         * deserialization failure), that new status takes priority */\r\n        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\r\n            this.finalStatus = status;\r\n            this.maybeOutputStatus();\r\n        }\r\n        this.destroyHttp2Stream();\r\n    }\r\n    maybeOutputStatus() {\r\n        if (this.finalStatus !== null) {\r\n            /* The combination check of readsClosed and that the two message buffer\r\n             * arrays are empty checks that there all incoming data has been fully\r\n             * processed */\r\n            if (this.finalStatus.code !== constants_1.Status.OK ||\r\n                (this.readsClosed &&\r\n                    this.unpushedReadMessages.length === 0 &&\r\n                    !this.isReadFilterPending &&\r\n                    !this.isPushPending)) {\r\n                this.outputStatus();\r\n            }\r\n        }\r\n    }\r\n    push(message) {\r\n        this.trace('pushing to reader message of length ' +\r\n            (message instanceof Buffer ? message.length : null));\r\n        this.canPush = false;\r\n        this.isPushPending = true;\r\n        process.nextTick(() => {\r\n            this.isPushPending = false;\r\n            /* If we have already output the status any later messages should be\r\n             * ignored, and can cause out-of-order operation errors higher up in the\r\n             * stack. Checking as late as possible here to avoid any race conditions.\r\n             */\r\n            if (this.statusOutput) {\r\n                return;\r\n            }\r\n            this.listener.onReceiveMessage(message);\r\n            this.maybeOutputStatus();\r\n        });\r\n    }\r\n    tryPush(messageBytes) {\r\n        if (this.canPush) {\r\n            this.http2Stream.pause();\r\n            this.push(messageBytes);\r\n        }\r\n        else {\r\n            this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);\r\n            this.unpushedReadMessages.push(messageBytes);\r\n        }\r\n    }\r\n    handleTrailers(headers) {\r\n        this.callEventTracker.onStreamEnd(true);\r\n        let headersString = '';\r\n        for (const header of Object.keys(headers)) {\r\n            headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\r\n        }\r\n        this.trace('Received server trailers:\\n' + headersString);\r\n        let metadata;\r\n        try {\r\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\r\n        }\r\n        catch (e) {\r\n            metadata = new metadata_1.Metadata();\r\n        }\r\n        const metadataMap = metadata.getMap();\r\n        let code = this.mappedStatusCode;\r\n        if (code === constants_1.Status.UNKNOWN &&\r\n            typeof metadataMap['grpc-status'] === 'string') {\r\n            const receivedStatus = Number(metadataMap['grpc-status']);\r\n            if (receivedStatus in constants_1.Status) {\r\n                code = receivedStatus;\r\n                this.trace('received status code ' + receivedStatus + ' from server');\r\n            }\r\n            metadata.remove('grpc-status');\r\n        }\r\n        let details = '';\r\n        if (typeof metadataMap['grpc-message'] === 'string') {\r\n            try {\r\n                details = decodeURI(metadataMap['grpc-message']);\r\n            }\r\n            catch (e) {\r\n                details = metadataMap['grpc-message'];\r\n            }\r\n            metadata.remove('grpc-message');\r\n            this.trace('received status details string \"' + details + '\" from server');\r\n        }\r\n        const status = { code, details, metadata };\r\n        // This is a no-op if the call was already ended when handling headers.\r\n        this.endCall(status);\r\n    }\r\n    destroyHttp2Stream() {\r\n        var _a;\r\n        // The http2 stream could already have been destroyed if cancelWithStatus\r\n        // is called in response to an internal http2 error.\r\n        if (!this.http2Stream.destroyed) {\r\n            /* If the call has ended with an OK status, communicate that when closing\r\n             * the stream, partly to avoid a situation in which we detect an error\r\n             * RST_STREAM as a result after we have the status */\r\n            let code;\r\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\r\n                code = http2.constants.NGHTTP2_NO_ERROR;\r\n            }\r\n            else {\r\n                code = http2.constants.NGHTTP2_CANCEL;\r\n            }\r\n            this.trace('close http2 stream with code ' + code);\r\n            this.http2Stream.close(code);\r\n        }\r\n    }\r\n    cancelWithStatus(status, details) {\r\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\r\n        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });\r\n    }\r\n    getStatus() {\r\n        return this.finalStatus;\r\n    }\r\n    getPeer() {\r\n        return this.transport.getPeerName();\r\n    }\r\n    getCallNumber() {\r\n        return this.callId;\r\n    }\r\n    startRead() {\r\n        /* If the stream has ended with an error, we should not emit any more\r\n         * messages and we should communicate that the stream has ended */\r\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\r\n            this.readsClosed = true;\r\n            this.maybeOutputStatus();\r\n            return;\r\n        }\r\n        this.canPush = true;\r\n        if (this.unpushedReadMessages.length > 0) {\r\n            const nextMessage = this.unpushedReadMessages.shift();\r\n            this.push(nextMessage);\r\n            return;\r\n        }\r\n        /* Only resume reading from the http2Stream if we don't have any pending\r\n         * messages to emit */\r\n        this.http2Stream.resume();\r\n    }\r\n    sendMessageWithContext(context, message) {\r\n        this.trace('write() called with message of length ' + message.length);\r\n        const cb = (error) => {\r\n            /* nextTick here ensures that no stream action can be taken in the call\r\n             * stack of the write callback, in order to hopefully work around\r\n             * https://github.com/nodejs/node/issues/49147 */\r\n            process.nextTick(() => {\r\n                var _a;\r\n                let code = constants_1.Status.UNAVAILABLE;\r\n                if ((error === null || error === void 0 ? void 0 : error.code) ===\r\n                    'ERR_STREAM_WRITE_AFTER_END') {\r\n                    code = constants_1.Status.INTERNAL;\r\n                }\r\n                if (error) {\r\n                    this.cancelWithStatus(code, `Write error: ${error.message}`);\r\n                }\r\n                (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\r\n            });\r\n        };\r\n        this.trace('sending data chunk of length ' + message.length);\r\n        this.callEventTracker.addMessageSent();\r\n        try {\r\n            this.http2Stream.write(message, cb);\r\n        }\r\n        catch (error) {\r\n            this.endCall({\r\n                code: constants_1.Status.UNAVAILABLE,\r\n                details: `Write failed with error ${error.message}`,\r\n                metadata: new metadata_1.Metadata(),\r\n            });\r\n        }\r\n    }\r\n    halfClose() {\r\n        this.trace('end() called');\r\n        this.trace('calling end() on HTTP/2 stream');\r\n        this.http2Stream.end();\r\n    }\r\n}\r\nexports.Http2SubchannelCall = Http2SubchannelCall;\r\n//# sourceMappingURL=subchannel-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1jYWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxvQkFBb0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUscUJBQXFCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxxQkFBcUIsc0NBQXNDLDJCQUEyQjtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLG9CQUFvQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBNEQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGNBQWM7QUFDOUU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWNhbGwuanM/OTZmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDYWxsID0gdm9pZCAwO1xyXG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcclxuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XHJcbmNvbnN0IHN0cmVhbV9kZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9zdHJlYW0tZGVjb2RlclwiKTtcclxuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdzdWJjaGFubmVsX2NhbGwnO1xyXG4vKipcclxuICogU2hvdWxkIGRvIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdGhpbmcgYXMgdXRpbC5nZXRTeXN0ZW1FcnJvck5hbWUgYnV0IHRoZVxyXG4gKiBUeXBlU2NyaXB0IHR5cGVzIGRvbid0IGhhdmUgdGhhdCBmdW5jdGlvbiBmb3Igc29tZSByZWFzb24gc28gSSBqdXN0IG1hZGUgbXlcclxuICogb3duLlxyXG4gKiBAcGFyYW0gZXJybm9cclxuICovXHJcbmZ1bmN0aW9uIGdldFN5c3RlbUVycm9yTmFtZShlcnJubykge1xyXG4gICAgZm9yIChjb25zdCBbbmFtZSwgbnVtXSBvZiBPYmplY3QuZW50cmllcyhvcy5jb25zdGFudHMuZXJybm8pKSB7XHJcbiAgICAgICAgaWYgKG51bSA9PT0gZXJybm8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICdVbmtub3duIHN5c3RlbSBlcnJvciAnICsgZXJybm87XHJcbn1cclxuY2xhc3MgSHR0cDJTdWJjaGFubmVsQ2FsbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihodHRwMlN0cmVhbSwgY2FsbEV2ZW50VHJhY2tlciwgbGlzdGVuZXIsIHRyYW5zcG9ydCwgY2FsbElkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0gPSBodHRwMlN0cmVhbTtcclxuICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIgPSBjYWxsRXZlbnRUcmFja2VyO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcclxuICAgICAgICB0aGlzLmNhbGxJZCA9IGNhbGxJZDtcclxuICAgICAgICB0aGlzLmlzUmVhZEZpbHRlclBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhbiAnZW5kJyBldmVudCBoYXMgY29tZSBmcm9tIHRoZSBodHRwMiBzdHJlYW0sIHNvIHRoZXJlXHJcbiAgICAgICAgICogd2lsbCBiZSBubyBtb3JlIGRhdGEgZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVhZHNDbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN0YXR1c091dHB1dCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMgPSBbXTtcclxuICAgICAgICAvLyBTdGF0dXMgY29kZSBtYXBwZWQgZnJvbSA6c3RhdHVzLiBUbyBiZSB1c2VkIGlmIGdycGMtc3RhdHVzIGlzIG5vdCByZWNlaXZlZFxyXG4gICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgcG9wdWxhdGVkIChub24tbnVsbCkgaWYgYW5kIG9ubHkgaWYgdGhlIGNhbGwgaGFzIGVuZGVkXHJcbiAgICAgICAgdGhpcy5maW5hbFN0YXR1cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gbnVsbDtcclxuICAgICAgICBjb25zdCBtYXhSZWNlaXZlTWVzc2FnZUxlbmd0aCA9IChfYSA9IHRyYW5zcG9ydC5nZXRPcHRpb25zKClbJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSDtcclxuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgc3RyZWFtX2RlY29kZXJfMS5TdHJlYW1EZWNvZGVyKG1heFJlY2VpdmVNZXNzYWdlTGVuZ3RoKTtcclxuICAgICAgICBodHRwMlN0cmVhbS5vbigncmVzcG9uc2UnLCAoaGVhZGVycywgZmxhZ3MpID0+IHtcclxuICAgICAgICAgICAgbGV0IGhlYWRlcnNTdHJpbmcgPSAnJztcclxuICAgICAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcclxuICAgICAgICAgICAgICAgIGhlYWRlcnNTdHJpbmcgKz0gJ1xcdFxcdCcgKyBoZWFkZXIgKyAnOiAnICsgaGVhZGVyc1toZWFkZXJdICsgJ1xcbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc2VydmVyIGhlYWRlcnM6XFxuJyArIGhlYWRlcnNTdHJpbmcpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGhlYWRlcnNbJzpzdGF0dXMnXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhtdXJnYXRyb2lkOTkpOiBoYW5kbGUgMTAwIGFuZCAxMDFcclxuICAgICAgICAgICAgICAgIGNhc2UgNDAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFVVEhFTlRJQ0FURUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQwMzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUEVSTUlTU0lPTl9ERU5JRUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQwNDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDI5OlxyXG4gICAgICAgICAgICAgICAgY2FzZSA1MDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDUwMzpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTA0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV047XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZsYWdzICYgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRkxBR19FTkRfU1RSRUFNKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvci5tZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCd0cmFpbGVycycsIChoZWFkZXJzKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhaWxlcnMoaGVhZGVycyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaHR0cDJTdHJlYW0ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAvKiBJZiB0aGUgc3RhdHVzIGhhcyBhbHJlYWR5IGJlZW4gb3V0cHV0LCBhbGxvdyB0aGUgaHR0cDIgc3RyZWFtIHRvXHJcbiAgICAgICAgICAgICAqIGRyYWluIHdpdGhvdXQgcHJvY2Vzc2luZyB0aGUgZGF0YS4gKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzT3V0cHV0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZSBIVFRQLzIgZGF0YSBmcmFtZSBvZiBsZW5ndGggJyArIGRhdGEubGVuZ3RoKTtcclxuICAgICAgICAgICAgbGV0IG1lc3NhZ2VzO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZXMgPSB0aGlzLmRlY29kZXIud3JpdGUoZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELCBlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgncGFyc2VkIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIuYWRkTWVzc2FnZVJlY2VpdmVkKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVB1c2gobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBodHRwMlN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWRzQ2xvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdjbG9zZScsICgpID0+IHtcclxuICAgICAgICAgICAgLyogVXNlIHByb2Nlc3MubmV4dCB0aWNrIHRvIGVuc3VyZSB0aGF0IHRoaXMgY29kZSBoYXBwZW5zIGFmdGVyIGFueVxyXG4gICAgICAgICAgICAgKiBcImVycm9yXCIgZXZlbnQgdGhhdCBtYXkgYmUgZW1pdHRlZCBhdCBhYm91dCB0aGUgc2FtZSB0aW1lLCBzbyB0aGF0XHJcbiAgICAgICAgICAgICAqIHdlIGNhbiBidWJibGUgdXAgdGhlIGVycm9yIG1lc3NhZ2UgZnJvbSB0aGF0IGV2ZW50LiAqL1xyXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0hUVFAvMiBzdHJlYW0gY2xvc2VkIHdpdGggY29kZSAnICsgaHR0cDJTdHJlYW0ucnN0Q29kZSk7XHJcbiAgICAgICAgICAgICAgICAvKiBJZiB3ZSBoYXZlIGEgZmluYWwgc3RhdHVzIHdpdGggYW4gT0sgc3RhdHVzIGNvZGUsIHRoYXQgbWVhbnMgdGhhdFxyXG4gICAgICAgICAgICAgICAgICogd2UgaGF2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIG1lc3NhZ2VzIGFuZCB3ZSBoYXZlIHByb2Nlc3NlZCB0aGVcclxuICAgICAgICAgICAgICAgICAqIHRyYWlsZXJzIGFuZCB0aGUgY2FsbCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBzbyBpdCBkb2Vzbid0IG1hdHRlclxyXG4gICAgICAgICAgICAgICAgICogaG93IHRoZSBzdHJlYW0gZW5kcyBhZnRlciB0aGF0ICovXHJcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuZmluYWxTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGNvZGU7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGV0YWlscyA9ICcnO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChodHRwMlN0cmVhbS5yc3RDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9OT19FUlJPUjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogSWYgd2UgZ2V0IGEgTk9fRVJST1IgY29kZSBhbmQgd2UgYWxyZWFkeSBoYXZlIGEgc3RhdHVzLCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogc3RyZWFtIGNvbXBsZXRlZCBwcm9wZXJseSBhbmQgd2UganVzdCBoYXZlbid0IGZ1bGx5IHByb2Nlc3NlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpdCB5ZXQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX1JFRlVTRURfU1RSRUFNOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ1N0cmVhbSByZWZ1c2VkIGJ5IHNlcnZlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfQ0FOQ0VMOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9ICdDYWxsIGNhbmNlbGxlZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVEO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ0JhbmR3aWR0aCBleGhhdXN0ZWQgb3IgbWVtb3J5IGxpbWl0IGV4Y2VlZGVkJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9JTkFERVFVQVRFX1NFQ1VSSVRZOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlBFUk1JU1NJT05fREVOSUVEO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ1Byb3RvY29sIG5vdCBzZWN1cmUgZW5vdWdoJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9JTlRFUk5BTF9FUlJPUjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxFcnJvciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhpcyBlcnJvciBjb2RlIHdhcyBwcmV2aW91c2x5IGhhbmRsZWQgaW4gdGhlIGRlZmF1bHQgY2FzZSwgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGVyZSBhcmUgc2V2ZXJhbCBpbnN0YW5jZXMgb2YgaXQgb25saW5lLCBzbyBJIHdhbnRlZCB0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogcHJlc2VydmUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2Ugc28gdGhhdCBwZW9wbGUgZmluZCBleGlzdGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaW5mb3JtYXRpb24gaW4gc2VhcmNoZXMsIGJ1dCBhbHNvIGluY2x1ZGUgdGhlIG1vcmUgcmVjb2duaXphYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiIG1lc3NhZ2UuICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX0gKEludGVybmFsIHNlcnZlciBlcnJvcilgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxFcnJvci5jb2RlID09PSAnRUNPTk5SRVNFVCcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsRXJyb3IuY29kZSA9PT0gJ0VUSU1FRE9VVCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSB0aGlzLmludGVybmFsRXJyb3IubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZSBcIlJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlIC4uLlwiIGVycm9yIGlzIHByZXNlcnZlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGhlcmUgZm9yIGNvbnRpbnVpdHkgd2l0aCBlcnJvcnMgcmVwb3J0ZWQgb25saW5lLCBidXQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZXJyb3IgbWVzc2FnZSBhdCB0aGUgZW5kIHdpbGwgcHJvYmFibHkgYmUgbW9yZSByZWxldmFudCBpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG1vc3QgY2FzZXMuICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke2h0dHAyU3RyZWFtLnJzdENvZGV9IHRyaWdnZXJlZCBieSBpbnRlcm5hbCBjbGllbnQgZXJyb3I6ICR7dGhpcy5pbnRlcm5hbEVycm9yLm1lc3NhZ2V9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX1gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5vLW9wIGlmIHRyYWlsZXJzIHdlcmUgcmVjZWl2ZWQgYXQgYWxsLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBPSywgYmVjYXVzZSBzdGF0dXMgY29kZXMgZW1pdHRlZCBoZXJlIGNvcnJlc3BvbmQgdG8gbW9yZVxyXG4gICAgICAgICAgICAgICAgLy8gY2F0YXN0cm9waGljIGlzc3VlcyB0aGF0IHByZXZlbnQgdXMgZnJvbSByZWNlaXZpbmcgdHJhaWxlcnMgaW4gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBwbGFjZS5cclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZSxcclxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJzdENvZGU6IGh0dHAyU3RyZWFtLnJzdENvZGUsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaHR0cDJTdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4ge1xyXG4gICAgICAgICAgICAvKiBXZSBuZWVkIGFuIGVycm9yIGhhbmRsZXIgaGVyZSB0byBzdG9wIFwiVW5jYXVnaHQgRXJyb3JcIiBleGNlcHRpb25zXHJcbiAgICAgICAgICAgICAqIGZyb20gYnViYmxpbmcgdXAuIEhvd2V2ZXIsIGVycm9ycyBoZXJlIHNob3VsZCBhbGwgY29ycmVzcG9uZCB0b1xyXG4gICAgICAgICAgICAgKiBcImNsb3NlXCIgZXZlbnRzLCB3aGVyZSB3ZSB3aWxsIGhhbmRsZSB0aGUgZXJyb3IgbW9yZSBncmFudWxhcmx5ICovXHJcbiAgICAgICAgICAgIC8qIFNwZWNpZmljYWxseSBsb29raW5nIGZvciBzdHJlYW0gZXJyb3JzIHRoYXQgd2VyZSAqbm90KiBjb25zdHJ1Y3RlZFxyXG4gICAgICAgICAgICAgKiBmcm9tIGEgUlNUX1NUUkVBTSByZXNwb25zZSBoZXJlOlxyXG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi84Yjg2MjBkNTgwMzE0MDUwMTc1OTgzNDAyZGZkZGYyNjc0ZThlMjJhL2xpYi9pbnRlcm5hbC9odHRwMi9jb3JlLmpzI0wyMjY3XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdFUlJfSFRUUDJfU1RSRUFNX0VSUk9SJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnTm9kZSBlcnJvciBldmVudDogbWVzc2FnZT0nICtcclxuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBjb2RlPScgK1xyXG4gICAgICAgICAgICAgICAgICAgIGVyci5jb2RlICtcclxuICAgICAgICAgICAgICAgICAgICAnIGVycm5vPScgK1xyXG4gICAgICAgICAgICAgICAgICAgIGdldFN5c3RlbUVycm9yTmFtZShlcnIuZXJybm8pICtcclxuICAgICAgICAgICAgICAgICAgICAnIHN5c2NhbGw9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyLnN5c2NhbGwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vblN0cmVhbUVuZChmYWxzZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3QoKSB7XHJcbiAgICAgICAgdGhpcy5lbmRDYWxsKHtcclxuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxyXG4gICAgICAgICAgICBkZXRhaWxzOiAnQ29ubmVjdGlvbiBkcm9wcGVkJyxcclxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvdXRwdXRTdGF0dXMoKSB7XHJcbiAgICAgICAgLyogUHJlY29uZGl0aW9uOiB0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsICovXHJcbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c091dHB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXR1c091dHB1dCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2VuZGVkIHdpdGggc3RhdHVzOiBjb2RlPScgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbFN0YXR1cy5jb2RlICtcclxuICAgICAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbFN0YXR1cy5kZXRhaWxzICtcclxuICAgICAgICAgICAgICAgICdcIicpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIub25DYWxsRW5kKHRoaXMuZmluYWxTdGF0dXMpO1xyXG4gICAgICAgICAgICAvKiBXZSBkZWxheSB0aGUgYWN0dWFsIGFjdGlvbiBvZiBidWJibGluZyB1cCB0aGUgc3RhdHVzIHRvIGluc3VsYXRlIHRoZVxyXG4gICAgICAgICAgICAgKiBjbGVhbnVwIGNvZGUgaW4gdGhpcyBjbGFzcyBmcm9tIGFueSBlcnJvcnMgdGhhdCBtYXkgYmUgdGhyb3duIGluIHRoZVxyXG4gICAgICAgICAgICAgKiB1cHBlciBsYXllcnMgYXMgYSByZXN1bHQgb2YgYnViYmxpbmcgdXAgdGhlIHN0YXR1cy4gSW4gcGFydGljdWxhcixcclxuICAgICAgICAgICAgICogaWYgdGhlIHN0YXR1cyBpcyBub3QgT0ssIHRoZSBcImVycm9yXCIgZXZlbnQgbWF5IGJlIGVtaXR0ZWRcclxuICAgICAgICAgICAgICogc3luY2hyb25vdXNseSBhdCB0aGUgdG9wIGxldmVsLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIHRocm93biBlcnJvciBpZlxyXG4gICAgICAgICAgICAgKiB0aGUgdXNlciBkb2VzIG5vdCBoYW5kbGUgdGhhdCBldmVudC4gKi9cclxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyh0aGlzLmZpbmFsU3RhdHVzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8qIExlYXZlIHRoZSBodHRwMiBzdHJlYW0gaW4gZmxvd2luZyBzdGF0ZSB0byBkcmFpbiBpbmNvbWluZyBtZXNzYWdlcywgdG9cclxuICAgICAgICAgICAgICogZW5zdXJlIHRoYXQgdGhlIHN0cmVhbSBjbG9zdXJlIGNvbXBsZXRlcy4gVGhlIGNhbGwgc3RyZWFtIGFscmVhZHkgZG9lc1xyXG4gICAgICAgICAgICAgKiBub3QgcHVzaCBtb3JlIG1lc3NhZ2VzIGFmdGVyIHRoZSBzdGF0dXMgaXMgb3V0cHV0LCBzbyB0aGUgbWVzc2FnZXMgZ29cclxuICAgICAgICAgICAgICogbm93aGVyZSBlaXRoZXIgd2F5LiAqL1xyXG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLnJlc3VtZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRyYWNlKHRleHQpIHtcclxuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18yLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbElkICsgJ10gJyArIHRleHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbiBmaXJzdCBjYWxsLCBlbWl0cyBhICdzdGF0dXMnIGV2ZW50IHdpdGggdGhlIGdpdmVuIFN0YXR1c09iamVjdC5cclxuICAgICAqIFN1YnNlcXVlbnQgY2FsbHMgYXJlIG5vLW9wcy5cclxuICAgICAqIEBwYXJhbSBzdGF0dXMgVGhlIHN0YXR1cyBvZiB0aGUgY2FsbC5cclxuICAgICAqL1xyXG4gICAgZW5kQ2FsbChzdGF0dXMpIHtcclxuICAgICAgICAvKiBJZiB0aGUgc3RhdHVzIGlzIE9LIGFuZCBhIG5ldyBzdGF0dXMgY29tZXMgaW4gKGUuZy4gZnJvbSBhXHJcbiAgICAgICAgICogZGVzZXJpYWxpemF0aW9uIGZhaWx1cmUpLCB0aGF0IG5ldyBzdGF0dXMgdGFrZXMgcHJpb3JpdHkgKi9cclxuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyA9PT0gbnVsbCB8fCB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xyXG4gICAgICAgICAgICB0aGlzLmZpbmFsU3RhdHVzID0gc3RhdHVzO1xyXG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGVzdHJveUh0dHAyU3RyZWFtKCk7XHJcbiAgICB9XHJcbiAgICBtYXliZU91dHB1dFN0YXR1cygpIHtcclxuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvKiBUaGUgY29tYmluYXRpb24gY2hlY2sgb2YgcmVhZHNDbG9zZWQgYW5kIHRoYXQgdGhlIHR3byBtZXNzYWdlIGJ1ZmZlclxyXG4gICAgICAgICAgICAgKiBhcnJheXMgYXJlIGVtcHR5IGNoZWNrcyB0aGF0IHRoZXJlIGFsbCBpbmNvbWluZyBkYXRhIGhhcyBiZWVuIGZ1bGx5XHJcbiAgICAgICAgICAgICAqIHByb2Nlc3NlZCAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0sgfHxcclxuICAgICAgICAgICAgICAgICh0aGlzLnJlYWRzQ2xvc2VkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcy5sZW5ndGggPT09IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuaXNQdXNoUGVuZGluZykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwdXNoKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLnRyYWNlKCdwdXNoaW5nIHRvIHJlYWRlciBtZXNzYWdlIG9mIGxlbmd0aCAnICtcclxuICAgICAgICAgICAgKG1lc3NhZ2UgaW5zdGFuY2VvZiBCdWZmZXIgPyBtZXNzYWdlLmxlbmd0aCA6IG51bGwpKTtcclxuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyogSWYgd2UgaGF2ZSBhbHJlYWR5IG91dHB1dCB0aGUgc3RhdHVzIGFueSBsYXRlciBtZXNzYWdlcyBzaG91bGQgYmVcclxuICAgICAgICAgICAgICogaWdub3JlZCwgYW5kIGNhbiBjYXVzZSBvdXQtb2Ytb3JkZXIgb3BlcmF0aW9uIGVycm9ycyBoaWdoZXIgdXAgaW4gdGhlXHJcbiAgICAgICAgICAgICAqIHN0YWNrLiBDaGVja2luZyBhcyBsYXRlIGFzIHBvc3NpYmxlIGhlcmUgdG8gYXZvaWQgYW55IHJhY2UgY29uZGl0aW9ucy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c091dHB1dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdHJ5UHVzaChtZXNzYWdlQnl0ZXMpIHtcclxuICAgICAgICBpZiAodGhpcy5jYW5QdXNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ucGF1c2UoKTtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKG1lc3NhZ2VCeXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCd1bnB1c2hlZFJlYWRNZXNzYWdlcy5wdXNoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlQnl0ZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2VCeXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFuZGxlVHJhaWxlcnMoaGVhZGVycykge1xyXG4gICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vblN0cmVhbUVuZCh0cnVlKTtcclxuICAgICAgICBsZXQgaGVhZGVyc1N0cmluZyA9ICcnO1xyXG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnNTdHJpbmcgKz0gJ1xcdFxcdCcgKyBoZWFkZXIgKyAnOiAnICsgaGVhZGVyc1toZWFkZXJdICsgJ1xcbic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIHNlcnZlciB0cmFpbGVyczpcXG4nICsgaGVhZGVyc1N0cmluZyk7XHJcbiAgICAgICAgbGV0IG1ldGFkYXRhO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGFfMS5NZXRhZGF0YS5mcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBtZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTWFwID0gbWV0YWRhdGEuZ2V0TWFwKCk7XHJcbiAgICAgICAgbGV0IGNvZGUgPSB0aGlzLm1hcHBlZFN0YXR1c0NvZGU7XHJcbiAgICAgICAgaWYgKGNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBtZXRhZGF0YU1hcFsnZ3JwYy1zdGF0dXMnXSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVjZWl2ZWRTdGF0dXMgPSBOdW1iZXIobWV0YWRhdGFNYXBbJ2dycGMtc3RhdHVzJ10pO1xyXG4gICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMgaW4gY29uc3RhbnRzXzEuU3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID0gcmVjZWl2ZWRTdGF0dXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdyZWNlaXZlZCBzdGF0dXMgY29kZSAnICsgcmVjZWl2ZWRTdGF0dXMgKyAnIGZyb20gc2VydmVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLXN0YXR1cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGV0YWlscyA9ICcnO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGFNYXBbJ2dycGMtbWVzc2FnZSddID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZGV0YWlscyA9IGRlY29kZVVSSShtZXRhZGF0YU1hcFsnZ3JwYy1tZXNzYWdlJ10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gbWV0YWRhdGFNYXBbJ2dycGMtbWVzc2FnZSddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1tZXNzYWdlJyk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3JlY2VpdmVkIHN0YXR1cyBkZXRhaWxzIHN0cmluZyBcIicgKyBkZXRhaWxzICsgJ1wiIGZyb20gc2VydmVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHsgY29kZSwgZGV0YWlscywgbWV0YWRhdGEgfTtcclxuICAgICAgICAvLyBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlIGNhbGwgd2FzIGFscmVhZHkgZW5kZWQgd2hlbiBoYW5kbGluZyBoZWFkZXJzLlxyXG4gICAgICAgIHRoaXMuZW5kQ2FsbChzdGF0dXMpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveUh0dHAyU3RyZWFtKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvLyBUaGUgaHR0cDIgc3RyZWFtIGNvdWxkIGFscmVhZHkgaGF2ZSBiZWVuIGRlc3Ryb3llZCBpZiBjYW5jZWxXaXRoU3RhdHVzXHJcbiAgICAgICAgLy8gaXMgY2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVybmFsIGh0dHAyIGVycm9yLlxyXG4gICAgICAgIGlmICghdGhpcy5odHRwMlN0cmVhbS5kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgLyogSWYgdGhlIGNhbGwgaGFzIGVuZGVkIHdpdGggYW4gT0sgc3RhdHVzLCBjb21tdW5pY2F0ZSB0aGF0IHdoZW4gY2xvc2luZ1xyXG4gICAgICAgICAgICAgKiB0aGUgc3RyZWFtLCBwYXJ0bHkgdG8gYXZvaWQgYSBzaXR1YXRpb24gaW4gd2hpY2ggd2UgZGV0ZWN0IGFuIGVycm9yXHJcbiAgICAgICAgICAgICAqIFJTVF9TVFJFQU0gYXMgYSByZXN1bHQgYWZ0ZXIgd2UgaGF2ZSB0aGUgc3RhdHVzICovXHJcbiAgICAgICAgICAgIGxldCBjb2RlO1xyXG4gICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuZmluYWxTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfQ0FOQ0VMO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nsb3NlIGh0dHAyIHN0cmVhbSB3aXRoIGNvZGUgJyArIGNvZGUpO1xyXG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLmNsb3NlKGNvZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XHJcbiAgICAgICAgdGhpcy50cmFjZSgnY2FuY2VsV2l0aFN0YXR1cyBjb2RlOiAnICsgc3RhdHVzICsgJyBkZXRhaWxzOiBcIicgKyBkZXRhaWxzICsgJ1wiJyk7XHJcbiAgICAgICAgdGhpcy5lbmRDYWxsKHsgY29kZTogc3RhdHVzLCBkZXRhaWxzLCBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSB9KTtcclxuICAgIH1cclxuICAgIGdldFN0YXR1cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maW5hbFN0YXR1cztcclxuICAgIH1cclxuICAgIGdldFBlZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmdldFBlZXJOYW1lKCk7XHJcbiAgICB9XHJcbiAgICBnZXRDYWxsTnVtYmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxJZDtcclxuICAgIH1cclxuICAgIHN0YXJ0UmVhZCgpIHtcclxuICAgICAgICAvKiBJZiB0aGUgc3RyZWFtIGhhcyBlbmRlZCB3aXRoIGFuIGVycm9yLCB3ZSBzaG91bGQgbm90IGVtaXQgYW55IG1vcmVcclxuICAgICAgICAgKiBtZXNzYWdlcyBhbmQgd2Ugc2hvdWxkIGNvbW11bmljYXRlIHRoYXQgdGhlIHN0cmVhbSBoYXMgZW5kZWQgKi9cclxuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCAmJiB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWRzQ2xvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0TWVzc2FnZSA9IHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKG5leHRNZXNzYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBPbmx5IHJlc3VtZSByZWFkaW5nIGZyb20gdGhlIGh0dHAyU3RyZWFtIGlmIHdlIGRvbid0IGhhdmUgYW55IHBlbmRpbmdcclxuICAgICAgICAgKiBtZXNzYWdlcyB0byBlbWl0ICovXHJcbiAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5yZXN1bWUoKTtcclxuICAgIH1cclxuICAgIHNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgbWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ3dyaXRlKCkgY2FsbGVkIHdpdGggbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBjYiA9IChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAvKiBuZXh0VGljayBoZXJlIGVuc3VyZXMgdGhhdCBubyBzdHJlYW0gYWN0aW9uIGNhbiBiZSB0YWtlbiBpbiB0aGUgY2FsbFxyXG4gICAgICAgICAgICAgKiBzdGFjayBvZiB0aGUgd3JpdGUgY2FsbGJhY2ssIGluIG9yZGVyIHRvIGhvcGVmdWxseSB3b3JrIGFyb3VuZFxyXG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MTQ3ICovXHJcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5jb2RlKSA9PT1cclxuICAgICAgICAgICAgICAgICAgICAnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb2RlLCBgV3JpdGUgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIChfYSA9IGNvbnRleHQuY2FsbGJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ3NlbmRpbmcgZGF0YSBjaHVuayBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcclxuICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIuYWRkTWVzc2FnZVNlbnQoKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLndyaXRlKG1lc3NhZ2UsIGNiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXHJcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgV3JpdGUgZmFpbGVkIHdpdGggZXJyb3IgJHtlcnJvci5tZXNzYWdlfWAsXHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFsZkNsb3NlKCkge1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ2VuZCgpIGNhbGxlZCcpO1xyXG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbGxpbmcgZW5kKCkgb24gSFRUUC8yIHN0cmVhbScpO1xyXG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0uZW5kKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDYWxsID0gSHR0cDJTdWJjaGFubmVsQ2FsbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2022 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BaseSubchannelWrapper = void 0;\r\nclass BaseSubchannelWrapper {\r\n    constructor(child) {\r\n        this.child = child;\r\n    }\r\n    getConnectivityState() {\r\n        return this.child.getConnectivityState();\r\n    }\r\n    addConnectivityStateListener(listener) {\r\n        this.child.addConnectivityStateListener(listener);\r\n    }\r\n    removeConnectivityStateListener(listener) {\r\n        this.child.removeConnectivityStateListener(listener);\r\n    }\r\n    startConnecting() {\r\n        this.child.startConnecting();\r\n    }\r\n    getAddress() {\r\n        return this.child.getAddress();\r\n    }\r\n    throttleKeepalive(newKeepaliveTime) {\r\n        this.child.throttleKeepalive(newKeepaliveTime);\r\n    }\r\n    ref() {\r\n        this.child.ref();\r\n    }\r\n    unref() {\r\n        this.child.unref();\r\n    }\r\n    getChannelzRef() {\r\n        return this.child.getChannelzRef();\r\n    }\r\n    getRealSubchannel() {\r\n        return this.child.getRealSubchannel();\r\n    }\r\n    realSubchannelEquals(other) {\r\n        return this.getRealSubchannel() === other.getRealSubchannel();\r\n    }\r\n}\r\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper;\r\n//# sourceMappingURL=subchannel-interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1pbnRlcmZhY2UuanM/MTAzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5CYXNlU3ViY2hhbm5lbFdyYXBwZXIgPSB2b2lkIDA7XHJcbmNsYXNzIEJhc2VTdWJjaGFubmVsV3JhcHBlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaGlsZCkge1xyXG4gICAgICAgIHRoaXMuY2hpbGQgPSBjaGlsZDtcclxuICAgIH1cclxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XHJcbiAgICB9XHJcbiAgICBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmNoaWxkLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgc3RhcnRDb25uZWN0aW5nKCkge1xyXG4gICAgICAgIHRoaXMuY2hpbGQuc3RhcnRDb25uZWN0aW5nKCk7XHJcbiAgICB9XHJcbiAgICBnZXRBZGRyZXNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldEFkZHJlc3MoKTtcclxuICAgIH1cclxuICAgIHRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpIHtcclxuICAgICAgICB0aGlzLmNoaWxkLnRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpO1xyXG4gICAgfVxyXG4gICAgcmVmKCkge1xyXG4gICAgICAgIHRoaXMuY2hpbGQucmVmKCk7XHJcbiAgICB9XHJcbiAgICB1bnJlZigpIHtcclxuICAgICAgICB0aGlzLmNoaWxkLnVucmVmKCk7XHJcbiAgICB9XHJcbiAgICBnZXRDaGFubmVselJlZigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRDaGFubmVselJlZigpO1xyXG4gICAgfVxyXG4gICAgZ2V0UmVhbFN1YmNoYW5uZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0UmVhbFN1YmNoYW5uZWwoKTtcclxuICAgIH1cclxuICAgIHJlYWxTdWJjaGFubmVsRXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVhbFN1YmNoYW5uZWwoKSA9PT0gb3RoZXIuZ2V0UmVhbFN1YmNoYW5uZWwoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkJhc2VTdWJjaGFubmVsV3JhcHBlciA9IEJhc2VTdWJjaGFubmVsV3JhcHBlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1pbnRlcmZhY2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\r\nconst channel_options_1 = __webpack_require__(/*! ./channel-options */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\");\r\nconst subchannel_1 = __webpack_require__(/*! ./subchannel */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst transport_1 = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/transport.js\");\r\n// 10 seconds in milliseconds. This value is arbitrary.\r\n/**\r\n * The amount of time in between checks for dropping subchannels that have no\r\n * other references\r\n */\r\nconst REF_CHECK_INTERVAL = 10000;\r\nclass SubchannelPool {\r\n    /**\r\n     * A pool of subchannels use for making connections. Subchannels with the\r\n     * exact same parameters will be reused.\r\n     */\r\n    constructor() {\r\n        this.pool = Object.create(null);\r\n        /**\r\n         * A timer of a task performing a periodic subchannel cleanup.\r\n         */\r\n        this.cleanupTimer = null;\r\n    }\r\n    /**\r\n     * Unrefs all unused subchannels and cancels the cleanup task if all\r\n     * subchannels have been unrefed.\r\n     */\r\n    unrefUnusedSubchannels() {\r\n        let allSubchannelsUnrefed = true;\r\n        /* These objects are created with Object.create(null), so they do not\r\n         * have a prototype, which means that for (... in ...) loops over them\r\n         * do not need to be filtered */\r\n        // eslint-disable-disable-next-line:forin\r\n        for (const channelTarget in this.pool) {\r\n            const subchannelObjArray = this.pool[channelTarget];\r\n            const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());\r\n            if (refedSubchannels.length > 0) {\r\n                allSubchannelsUnrefed = false;\r\n            }\r\n            /* For each subchannel in the pool, try to unref it if it has\r\n             * exactly one ref (which is the ref from the pool itself). If that\r\n             * does happen, remove the subchannel from the pool */\r\n            this.pool[channelTarget] = refedSubchannels;\r\n        }\r\n        /* Currently we do not delete keys with empty values. If that results\r\n         * in significant memory usage we should change it. */\r\n        // Cancel the cleanup task if all subchannels have been unrefed.\r\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\r\n            clearInterval(this.cleanupTimer);\r\n            this.cleanupTimer = null;\r\n        }\r\n    }\r\n    /**\r\n     * Ensures that the cleanup task is spawned.\r\n     */\r\n    ensureCleanupTask() {\r\n        var _a, _b;\r\n        if (this.cleanupTimer === null) {\r\n            this.cleanupTimer = setInterval(() => {\r\n                this.unrefUnusedSubchannels();\r\n            }, REF_CHECK_INTERVAL);\r\n            // Unref because this timer should not keep the event loop running.\r\n            // Call unref only if it exists to address electron/electron#21162\r\n            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n    }\r\n    /**\r\n     * Get a subchannel if one already exists with exactly matching parameters.\r\n     * Otherwise, create and save a subchannel with those parameters.\r\n     * @param channelTarget\r\n     * @param subchannelTarget\r\n     * @param channelArguments\r\n     * @param channelCredentials\r\n     */\r\n    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\r\n        this.ensureCleanupTask();\r\n        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);\r\n        if (channelTarget in this.pool) {\r\n            const subchannelObjArray = this.pool[channelTarget];\r\n            for (const subchannelObj of subchannelObjArray) {\r\n                if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) &&\r\n                    (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) &&\r\n                    channelCredentials._equals(subchannelObj.channelCredentials)) {\r\n                    return subchannelObj.subchannel;\r\n                }\r\n            }\r\n        }\r\n        // If we get here, no matching subchannel was found\r\n        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));\r\n        if (!(channelTarget in this.pool)) {\r\n            this.pool[channelTarget] = [];\r\n        }\r\n        this.pool[channelTarget].push({\r\n            subchannelAddress: subchannelTarget,\r\n            channelArguments,\r\n            channelCredentials,\r\n            subchannel,\r\n        });\r\n        subchannel.ref();\r\n        return subchannel;\r\n    }\r\n}\r\nexports.SubchannelPool = SubchannelPool;\r\nconst globalSubchannelPool = new SubchannelPool();\r\n/**\r\n * Get either the global subchannel pool, or a new subchannel pool.\r\n * @param global\r\n */\r\nfunction getSubchannelPool(global) {\r\n    if (global) {\r\n        return globalSubchannelPool;\r\n    }\r\n    else {\r\n        return new SubchannelPool();\r\n    }\r\n}\r\nexports.getSubchannelPool = getSubchannelPool;\r\n//# sourceMappingURL=subchannel-pool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsc0JBQXNCO0FBQ2xELDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRCxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0Msb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLXBvb2wuanM/YjAzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICpcclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5nZXRTdWJjaGFubmVsUG9vbCA9IGV4cG9ydHMuU3ViY2hhbm5lbFBvb2wgPSB2b2lkIDA7XHJcbmNvbnN0IGNoYW5uZWxfb3B0aW9uc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1vcHRpb25zXCIpO1xyXG5jb25zdCBzdWJjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsXCIpO1xyXG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcclxuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcclxuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRcIik7XHJcbi8vIDEwIHNlY29uZHMgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIHZhbHVlIGlzIGFyYml0cmFyeS5cclxuLyoqXHJcbiAqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBiZXR3ZWVuIGNoZWNrcyBmb3IgZHJvcHBpbmcgc3ViY2hhbm5lbHMgdGhhdCBoYXZlIG5vXHJcbiAqIG90aGVyIHJlZmVyZW5jZXNcclxuICovXHJcbmNvbnN0IFJFRl9DSEVDS19JTlRFUlZBTCA9IDEwMDAwO1xyXG5jbGFzcyBTdWJjaGFubmVsUG9vbCB7XHJcbiAgICAvKipcclxuICAgICAqIEEgcG9vbCBvZiBzdWJjaGFubmVscyB1c2UgZm9yIG1ha2luZyBjb25uZWN0aW9ucy4gU3ViY2hhbm5lbHMgd2l0aCB0aGVcclxuICAgICAqIGV4YWN0IHNhbWUgcGFyYW1ldGVycyB3aWxsIGJlIHJldXNlZC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5wb29sID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHRpbWVyIG9mIGEgdGFzayBwZXJmb3JtaW5nIGEgcGVyaW9kaWMgc3ViY2hhbm5lbCBjbGVhbnVwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVW5yZWZzIGFsbCB1bnVzZWQgc3ViY2hhbm5lbHMgYW5kIGNhbmNlbHMgdGhlIGNsZWFudXAgdGFzayBpZiBhbGxcclxuICAgICAqIHN1YmNoYW5uZWxzIGhhdmUgYmVlbiB1bnJlZmVkLlxyXG4gICAgICovXHJcbiAgICB1bnJlZlVudXNlZFN1YmNoYW5uZWxzKCkge1xyXG4gICAgICAgIGxldCBhbGxTdWJjaGFubmVsc1VucmVmZWQgPSB0cnVlO1xyXG4gICAgICAgIC8qIFRoZXNlIG9iamVjdHMgYXJlIGNyZWF0ZWQgd2l0aCBPYmplY3QuY3JlYXRlKG51bGwpLCBzbyB0aGV5IGRvIG5vdFxyXG4gICAgICAgICAqIGhhdmUgYSBwcm90b3R5cGUsIHdoaWNoIG1lYW5zIHRoYXQgZm9yICguLi4gaW4gLi4uKSBsb29wcyBvdmVyIHRoZW1cclxuICAgICAgICAgKiBkbyBub3QgbmVlZCB0byBiZSBmaWx0ZXJlZCAqL1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWRpc2FibGUtbmV4dC1saW5lOmZvcmluXHJcbiAgICAgICAgZm9yIChjb25zdCBjaGFubmVsVGFyZ2V0IGluIHRoaXMucG9vbCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsT2JqQXJyYXkgPSB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZmVkU3ViY2hhbm5lbHMgPSBzdWJjaGFubmVsT2JqQXJyYXkuZmlsdGVyKHZhbHVlID0+ICF2YWx1ZS5zdWJjaGFubmVsLnVucmVmSWZPbmVSZWYoKSk7XHJcbiAgICAgICAgICAgIGlmIChyZWZlZFN1YmNoYW5uZWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGFsbFN1YmNoYW5uZWxzVW5yZWZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIEZvciBlYWNoIHN1YmNoYW5uZWwgaW4gdGhlIHBvb2wsIHRyeSB0byB1bnJlZiBpdCBpZiBpdCBoYXNcclxuICAgICAgICAgICAgICogZXhhY3RseSBvbmUgcmVmICh3aGljaCBpcyB0aGUgcmVmIGZyb20gdGhlIHBvb2wgaXRzZWxmKS4gSWYgdGhhdFxyXG4gICAgICAgICAgICAgKiBkb2VzIGhhcHBlbiwgcmVtb3ZlIHRoZSBzdWJjaGFubmVsIGZyb20gdGhlIHBvb2wgKi9cclxuICAgICAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdID0gcmVmZWRTdWJjaGFubmVscztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogQ3VycmVudGx5IHdlIGRvIG5vdCBkZWxldGUga2V5cyB3aXRoIGVtcHR5IHZhbHVlcy4gSWYgdGhhdCByZXN1bHRzXHJcbiAgICAgICAgICogaW4gc2lnbmlmaWNhbnQgbWVtb3J5IHVzYWdlIHdlIHNob3VsZCBjaGFuZ2UgaXQuICovXHJcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBjbGVhbnVwIHRhc2sgaWYgYWxsIHN1YmNoYW5uZWxzIGhhdmUgYmVlbiB1bnJlZmVkLlxyXG4gICAgICAgIGlmIChhbGxTdWJjaGFubmVsc1VucmVmZWQgJiYgdGhpcy5jbGVhbnVwVGltZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNsZWFudXBUaW1lcik7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgY2xlYW51cCB0YXNrIGlzIHNwYXduZWQuXHJcbiAgICAgKi9cclxuICAgIGVuc3VyZUNsZWFudXBUYXNrKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bnJlZlVudXNlZFN1YmNoYW5uZWxzKCk7XHJcbiAgICAgICAgICAgIH0sIFJFRl9DSEVDS19JTlRFUlZBTCk7XHJcbiAgICAgICAgICAgIC8vIFVucmVmIGJlY2F1c2UgdGhpcyB0aW1lciBzaG91bGQgbm90IGtlZXAgdGhlIGV2ZW50IGxvb3AgcnVubmluZy5cclxuICAgICAgICAgICAgLy8gQ2FsbCB1bnJlZiBvbmx5IGlmIGl0IGV4aXN0cyB0byBhZGRyZXNzIGVsZWN0cm9uL2VsZWN0cm9uIzIxMTYyXHJcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2xlYW51cFRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgc3ViY2hhbm5lbCBpZiBvbmUgYWxyZWFkeSBleGlzdHMgd2l0aCBleGFjdGx5IG1hdGNoaW5nIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBPdGhlcndpc2UsIGNyZWF0ZSBhbmQgc2F2ZSBhIHN1YmNoYW5uZWwgd2l0aCB0aG9zZSBwYXJhbWV0ZXJzLlxyXG4gICAgICogQHBhcmFtIGNoYW5uZWxUYXJnZXRcclxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsVGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0gY2hhbm5lbEFyZ3VtZW50c1xyXG4gICAgICogQHBhcmFtIGNoYW5uZWxDcmVkZW50aWFsc1xyXG4gICAgICovXHJcbiAgICBnZXRPckNyZWF0ZVN1YmNoYW5uZWwoY2hhbm5lbFRhcmdldFVyaSwgc3ViY2hhbm5lbFRhcmdldCwgY2hhbm5lbEFyZ3VtZW50cywgY2hhbm5lbENyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVDbGVhbnVwVGFzaygpO1xyXG4gICAgICAgIGNvbnN0IGNoYW5uZWxUYXJnZXQgPSAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKShjaGFubmVsVGFyZ2V0VXJpKTtcclxuICAgICAgICBpZiAoY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbE9iakFycmF5ID0gdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWxPYmogb2Ygc3ViY2hhbm5lbE9iakFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzRXF1YWwpKHN1YmNoYW5uZWxUYXJnZXQsIHN1YmNoYW5uZWxPYmouc3ViY2hhbm5lbEFkZHJlc3MpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKDAsIGNoYW5uZWxfb3B0aW9uc18xLmNoYW5uZWxPcHRpb25zRXF1YWwpKGNoYW5uZWxBcmd1bWVudHMsIHN1YmNoYW5uZWxPYmouY2hhbm5lbEFyZ3VtZW50cykgJiZcclxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ3JlZGVudGlhbHMuX2VxdWFscyhzdWJjaGFubmVsT2JqLmNoYW5uZWxDcmVkZW50aWFscykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViY2hhbm5lbE9iai5zdWJjaGFubmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBubyBtYXRjaGluZyBzdWJjaGFubmVsIHdhcyBmb3VuZFxyXG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWwgPSBuZXcgc3ViY2hhbm5lbF8xLlN1YmNoYW5uZWwoY2hhbm5lbFRhcmdldFVyaSwgc3ViY2hhbm5lbFRhcmdldCwgY2hhbm5lbEFyZ3VtZW50cywgY2hhbm5lbENyZWRlbnRpYWxzLCBuZXcgdHJhbnNwb3J0XzEuSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXRVcmkpKTtcclxuICAgICAgICBpZiAoIShjaGFubmVsVGFyZ2V0IGluIHRoaXMucG9vbCkpIHtcclxuICAgICAgICAgICAgdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XS5wdXNoKHtcclxuICAgICAgICAgICAgc3ViY2hhbm5lbEFkZHJlc3M6IHN1YmNoYW5uZWxUYXJnZXQsXHJcbiAgICAgICAgICAgIGNoYW5uZWxBcmd1bWVudHMsXHJcbiAgICAgICAgICAgIGNoYW5uZWxDcmVkZW50aWFscyxcclxuICAgICAgICAgICAgc3ViY2hhbm5lbCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xyXG4gICAgICAgIHJldHVybiBzdWJjaGFubmVsO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU3ViY2hhbm5lbFBvb2wgPSBTdWJjaGFubmVsUG9vbDtcclxuY29uc3QgZ2xvYmFsU3ViY2hhbm5lbFBvb2wgPSBuZXcgU3ViY2hhbm5lbFBvb2woKTtcclxuLyoqXHJcbiAqIEdldCBlaXRoZXIgdGhlIGdsb2JhbCBzdWJjaGFubmVsIHBvb2wsIG9yIGEgbmV3IHN1YmNoYW5uZWwgcG9vbC5cclxuICogQHBhcmFtIGdsb2JhbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U3ViY2hhbm5lbFBvb2woZ2xvYmFsKSB7XHJcbiAgICBpZiAoZ2xvYmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbFN1YmNoYW5uZWxQb29sO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJjaGFubmVsUG9vbCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZ2V0U3ViY2hhbm5lbFBvb2wgPSBnZXRTdWJjaGFubmVsUG9vbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1wb29sLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Subchannel = void 0;\r\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\r\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\r\nconst TRACER_NAME = 'subchannel';\r\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\r\n * have a constant for the max signed 32 bit integer, so this is a simple way\r\n * to calculate it */\r\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\r\nclass Subchannel {\r\n    /**\r\n     * A class representing a connection to a single backend.\r\n     * @param channelTarget The target string for the channel as a whole\r\n     * @param subchannelAddress The address for the backend that this subchannel\r\n     *     will connect to\r\n     * @param options The channel options, plus any specific subchannel options\r\n     *     for this subchannel\r\n     * @param credentials The channel credentials used to establish this\r\n     *     connection\r\n     */\r\n    constructor(channelTarget, subchannelAddress, options, credentials, connector) {\r\n        var _a;\r\n        this.channelTarget = channelTarget;\r\n        this.subchannelAddress = subchannelAddress;\r\n        this.options = options;\r\n        this.credentials = credentials;\r\n        this.connector = connector;\r\n        /**\r\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\r\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\r\n         */\r\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\r\n        /**\r\n         * The underlying http2 session used to make requests.\r\n         */\r\n        this.transport = null;\r\n        /**\r\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\r\n         * CONNECTING instead of IDLE when the backoff timeout ends.\r\n         */\r\n        this.continueConnecting = false;\r\n        /**\r\n         * A list of listener functions that will be called whenever the connectivity\r\n         * state changes. Will be modified by `addConnectivityStateListener` and\r\n         * `removeConnectivityStateListener`\r\n         */\r\n        this.stateListeners = new Set();\r\n        /**\r\n         * Tracks channels and subchannel pools with references to this subchannel\r\n         */\r\n        this.refcount = 0;\r\n        // Channelz info\r\n        this.channelzEnabled = true;\r\n        this.callTracker = new channelz_1.ChannelzCallTracker();\r\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\r\n        // Channelz socket info\r\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\r\n        const backoffOptions = {\r\n            initialDelay: options['grpc.initial_reconnect_backoff_ms'],\r\n            maxDelay: options['grpc.max_reconnect_backoff_ms'],\r\n        };\r\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\r\n            this.handleBackoffTimer();\r\n        }, backoffOptions);\r\n        this.backoffTimeout.unref();\r\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\r\n        this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== void 0 ? _a : -1;\r\n        if (options['grpc.enable_channelz'] === 0) {\r\n            this.channelzEnabled = false;\r\n        }\r\n        this.channelzTrace = new channelz_1.ChannelzTrace();\r\n        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\r\n        if (this.channelzEnabled) {\r\n            this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\r\n        }\r\n        this.trace('Subchannel constructed with options ' +\r\n            JSON.stringify(options, undefined, 2));\r\n    }\r\n    getChannelzInfo() {\r\n        return {\r\n            state: this.connectivityState,\r\n            trace: this.channelzTrace,\r\n            callTracker: this.callTracker,\r\n            children: this.childrenTracker.getChildLists(),\r\n            target: this.subchannelAddressString,\r\n        };\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            this.subchannelAddressString +\r\n            ' ' +\r\n            text);\r\n    }\r\n    refTrace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            this.subchannelAddressString +\r\n            ' ' +\r\n            text);\r\n    }\r\n    handleBackoffTimer() {\r\n        if (this.continueConnecting) {\r\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\r\n        }\r\n        else {\r\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\r\n        }\r\n    }\r\n    /**\r\n     * Start a backoff timer with the current nextBackoff timeout\r\n     */\r\n    startBackoff() {\r\n        this.backoffTimeout.runOnce();\r\n    }\r\n    stopBackoff() {\r\n        this.backoffTimeout.stop();\r\n        this.backoffTimeout.reset();\r\n    }\r\n    startConnectingInternal() {\r\n        let options = this.options;\r\n        if (options['grpc.keepalive_time_ms']) {\r\n            const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\r\n            options = Object.assign(Object.assign({}, options), { 'grpc.keepalive_time_ms': adjustedKeepaliveTime });\r\n        }\r\n        this.connector\r\n            .connect(this.subchannelAddress, this.credentials, options)\r\n            .then(transport => {\r\n            if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {\r\n                this.transport = transport;\r\n                if (this.channelzEnabled) {\r\n                    this.childrenTracker.refChild(transport.getChannelzRef());\r\n                }\r\n                transport.addDisconnectListener(tooManyPings => {\r\n                    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\r\n                    if (tooManyPings && this.keepaliveTime > 0) {\r\n                        this.keepaliveTime *= 2;\r\n                        logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                /* If we can't transition from CONNECTING to READY here, we will\r\n                 * not be using this transport, so release its resources. */\r\n                transport.shutdown();\r\n            }\r\n        }, error => {\r\n            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);\r\n        });\r\n    }\r\n    /**\r\n     * Initiate a state transition from any element of oldStates to the new\r\n     * state. If the current connectivityState is not in oldStates, do nothing.\r\n     * @param oldStates The set of states to transition from\r\n     * @param newState The state to transition to\r\n     * @returns True if the state changed, false otherwise\r\n     */\r\n    transitionToState(oldStates, newState, errorMessage) {\r\n        var _a, _b;\r\n        if (oldStates.indexOf(this.connectivityState) === -1) {\r\n            return false;\r\n        }\r\n        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +\r\n            ' -> ' +\r\n            connectivity_state_1.ConnectivityState[newState]);\r\n        if (this.channelzEnabled) {\r\n            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\r\n        }\r\n        const previousState = this.connectivityState;\r\n        this.connectivityState = newState;\r\n        switch (newState) {\r\n            case connectivity_state_1.ConnectivityState.READY:\r\n                this.stopBackoff();\r\n                break;\r\n            case connectivity_state_1.ConnectivityState.CONNECTING:\r\n                this.startBackoff();\r\n                this.startConnectingInternal();\r\n                this.continueConnecting = false;\r\n                break;\r\n            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\r\n                if (this.channelzEnabled && this.transport) {\r\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\r\n                }\r\n                (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\r\n                this.transport = null;\r\n                /* If the backoff timer has already ended by the time we get to the\r\n                 * TRANSIENT_FAILURE state, we want to immediately transition out of\r\n                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */\r\n                if (!this.backoffTimeout.isRunning()) {\r\n                    process.nextTick(() => {\r\n                        this.handleBackoffTimer();\r\n                    });\r\n                }\r\n                break;\r\n            case connectivity_state_1.ConnectivityState.IDLE:\r\n                if (this.channelzEnabled && this.transport) {\r\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\r\n                }\r\n                (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\r\n                this.transport = null;\r\n                break;\r\n            default:\r\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\r\n        }\r\n        for (const listener of this.stateListeners) {\r\n            listener(this, previousState, newState, this.keepaliveTime, errorMessage);\r\n        }\r\n        return true;\r\n    }\r\n    ref() {\r\n        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\r\n        this.refcount += 1;\r\n    }\r\n    unref() {\r\n        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\r\n        this.refcount -= 1;\r\n        if (this.refcount === 0) {\r\n            if (this.channelzEnabled) {\r\n                this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\r\n            }\r\n            if (this.channelzEnabled) {\r\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\r\n            }\r\n            process.nextTick(() => {\r\n                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\r\n            });\r\n        }\r\n    }\r\n    unrefIfOneRef() {\r\n        if (this.refcount === 1) {\r\n            this.unref();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    createCall(metadata, host, method, listener) {\r\n        if (!this.transport) {\r\n            throw new Error('Cannot create call, subchannel not READY');\r\n        }\r\n        let statsTracker;\r\n        if (this.channelzEnabled) {\r\n            this.callTracker.addCallStarted();\r\n            this.streamTracker.addCallStarted();\r\n            statsTracker = {\r\n                onCallEnd: status => {\r\n                    if (status.code === constants_1.Status.OK) {\r\n                        this.callTracker.addCallSucceeded();\r\n                    }\r\n                    else {\r\n                        this.callTracker.addCallFailed();\r\n                    }\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            statsTracker = {};\r\n        }\r\n        return this.transport.createCall(metadata, host, method, listener, statsTracker);\r\n    }\r\n    /**\r\n     * If the subchannel is currently IDLE, start connecting and switch to the\r\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\r\n     * the next time it would transition to IDLE, start connecting again instead.\r\n     * Otherwise, do nothing.\r\n     */\r\n    startConnecting() {\r\n        process.nextTick(() => {\r\n            /* First, try to transition from IDLE to connecting. If that doesn't happen\r\n             * because the state is not currently IDLE, check if it is\r\n             * TRANSIENT_FAILURE, and if so indicate that it should go back to\r\n             * connecting after the backoff timer ends. Otherwise do nothing */\r\n            if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\r\n                if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\r\n                    this.continueConnecting = true;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Get the subchannel's current connectivity state.\r\n     */\r\n    getConnectivityState() {\r\n        return this.connectivityState;\r\n    }\r\n    /**\r\n     * Add a listener function to be called whenever the subchannel's\r\n     * connectivity state changes.\r\n     * @param listener\r\n     */\r\n    addConnectivityStateListener(listener) {\r\n        this.stateListeners.add(listener);\r\n    }\r\n    /**\r\n     * Remove a listener previously added with `addConnectivityStateListener`\r\n     * @param listener A reference to a function previously passed to\r\n     *     `addConnectivityStateListener`\r\n     */\r\n    removeConnectivityStateListener(listener) {\r\n        this.stateListeners.delete(listener);\r\n    }\r\n    /**\r\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\r\n     */\r\n    resetBackoff() {\r\n        process.nextTick(() => {\r\n            this.backoffTimeout.reset();\r\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\r\n        });\r\n    }\r\n    getAddress() {\r\n        return this.subchannelAddressString;\r\n    }\r\n    getChannelzRef() {\r\n        return this.channelzRef;\r\n    }\r\n    getRealSubchannel() {\r\n        return this;\r\n    }\r\n    realSubchannelEquals(other) {\r\n        return other.getRealSubchannel() === this;\r\n    }\r\n    throttleKeepalive(newKeepaliveTime) {\r\n        if (newKeepaliveTime > this.keepaliveTime) {\r\n            this.keepaliveTime = newKeepaliveTime;\r\n        }\r\n    }\r\n}\r\nexports.Subchannel = Subchannel;\r\n//# sourceMappingURL=subchannel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsMEJBQTBCLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWMsaURBQWlEO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLG1EQUFtRCxLQUFLLDhCQUE4QiwwRUFBMEUsb0JBQW9CO0FBQ3pRO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxSkFBcUosTUFBTTtBQUMzSixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFNBQVM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcz9iODMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlN1YmNoYW5uZWwgPSB2b2lkIDA7XHJcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xyXG5jb25zdCBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcclxuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xyXG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcclxuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xyXG5jb25zdCBUUkFDRVJfTkFNRSA9ICdzdWJjaGFubmVsJztcclxuLyogc2V0SW50ZXJ2YWwgYW5kIHNldFRpbWVvdXQgb25seSBhY2NlcHQgc2lnbmVkIDMyIGJpdCBpbnRlZ2Vycy4gSlMgZG9lc24ndFxyXG4gKiBoYXZlIGEgY29uc3RhbnQgZm9yIHRoZSBtYXggc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLCBzbyB0aGlzIGlzIGEgc2ltcGxlIHdheVxyXG4gKiB0byBjYWxjdWxhdGUgaXQgKi9cclxuY29uc3QgS0VFUEFMSVZFX01BWF9USU1FX01TID0gfigxIDw8IDMxKTtcclxuY2xhc3MgU3ViY2hhbm5lbCB7XHJcbiAgICAvKipcclxuICAgICAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgY29ubmVjdGlvbiB0byBhIHNpbmdsZSBiYWNrZW5kLlxyXG4gICAgICogQHBhcmFtIGNoYW5uZWxUYXJnZXQgVGhlIHRhcmdldCBzdHJpbmcgZm9yIHRoZSBjaGFubmVsIGFzIGEgd2hvbGVcclxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsQWRkcmVzcyBUaGUgYWRkcmVzcyBmb3IgdGhlIGJhY2tlbmQgdGhhdCB0aGlzIHN1YmNoYW5uZWxcclxuICAgICAqICAgICB3aWxsIGNvbm5lY3QgdG9cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjaGFubmVsIG9wdGlvbnMsIHBsdXMgYW55IHNwZWNpZmljIHN1YmNoYW5uZWwgb3B0aW9uc1xyXG4gICAgICogICAgIGZvciB0aGlzIHN1YmNoYW5uZWxcclxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgY2hhbm5lbCBjcmVkZW50aWFscyB1c2VkIHRvIGVzdGFibGlzaCB0aGlzXHJcbiAgICAgKiAgICAgY29ubmVjdGlvblxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsVGFyZ2V0LCBzdWJjaGFubmVsQWRkcmVzcywgb3B0aW9ucywgY3JlZGVudGlhbHMsIGNvbm5lY3Rvcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLmNoYW5uZWxUYXJnZXQgPSBjaGFubmVsVGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3MgPSBzdWJjaGFubmVsQWRkcmVzcztcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc3ViY2hhbm5lbCdzIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlLiBJbnZhcmlhbnQ6IGBzZXNzaW9uYCA9PT0gYG51bGxgXHJcbiAgICAgICAgICogaWYgYW5kIG9ubHkgaWYgYGNvbm5lY3Rpdml0eVN0YXRlYCBpcyBJRExFIG9yIFRSQU5TSUVOVF9GQUlMVVJFLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB1bmRlcmx5aW5nIGh0dHAyIHNlc3Npb24gdXNlZCB0byBtYWtlIHJlcXVlc3RzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgc3ViY2hhbm5lbCBzaG91bGQgdHJhbnNpdGlvbiBmcm9tIFRSQU5TSUVOVF9GQUlMVVJFIHRvXHJcbiAgICAgICAgICogQ09OTkVDVElORyBpbnN0ZWFkIG9mIElETEUgd2hlbiB0aGUgYmFja29mZiB0aW1lb3V0IGVuZHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250aW51ZUNvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIGNvbm5lY3Rpdml0eVxyXG4gICAgICAgICAqIHN0YXRlIGNoYW5nZXMuIFdpbGwgYmUgbW9kaWZpZWQgYnkgYGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXJgIGFuZFxyXG4gICAgICAgICAqIGByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhY2tzIGNoYW5uZWxzIGFuZCBzdWJjaGFubmVsIHBvb2xzIHdpdGggcmVmZXJlbmNlcyB0byB0aGlzIHN1YmNoYW5uZWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlZmNvdW50ID0gMDtcclxuICAgICAgICAvLyBDaGFubmVseiBpbmZvXHJcbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xyXG4gICAgICAgIC8vIENoYW5uZWx6IHNvY2tldCBpbmZvXHJcbiAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xyXG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IG9wdGlvbnNbJ2dycGMuaW5pdGlhbF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxyXG4gICAgICAgICAgICBtYXhEZWxheTogb3B0aW9uc1snZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQgPSBuZXcgYmFja29mZl90aW1lb3V0XzEuQmFja29mZlRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUJhY2tvZmZUaW1lcigpO1xyXG4gICAgICAgIH0sIGJhY2tvZmZPcHRpb25zKTtcclxuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnVucmVmKCk7XHJcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShzdWJjaGFubmVsQWRkcmVzcyk7XHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lID0gKF9hID0gb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTtcclxuICAgICAgICBpZiAob3B0aW9uc1snZ3JwYy5lbmFibGVfY2hhbm5lbHonXSA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlKCk7XHJcbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9ICgwLCBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsKSh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLCAoKSA9PiB0aGlzLmdldENoYW5uZWx6SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdTdWJjaGFubmVsIGNyZWF0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFjZSgnU3ViY2hhbm5lbCBjb25zdHJ1Y3RlZCB3aXRoIG9wdGlvbnMgJyArXHJcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIHVuZGVmaW5lZCwgMikpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbm5lbHpJbmZvKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlLFxyXG4gICAgICAgICAgICB0cmFjZTogdGhpcy5jaGFubmVselRyYWNlLFxyXG4gICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcclxuICAgICAgICAgICAgY2hpbGRyZW46IHRoaXMuY2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKSxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB0cmFjZSh0ZXh0KSB7XHJcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnKCcgK1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcclxuICAgICAgICAgICAgJykgJyArXHJcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xyXG4gICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICB0ZXh0KTtcclxuICAgIH1cclxuICAgIHJlZlRyYWNlKHRleHQpIHtcclxuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ3N1YmNoYW5uZWxfcmVmY291bnQnLCAnKCcgK1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcclxuICAgICAgICAgICAgJykgJyArXHJcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xyXG4gICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICB0ZXh0KTtcclxuICAgIH1cclxuICAgIGhhbmRsZUJhY2tvZmZUaW1lcigpIHtcclxuICAgICAgICBpZiAodGhpcy5jb250aW51ZUNvbm5lY3RpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBhIGJhY2tvZmYgdGltZXIgd2l0aCB0aGUgY3VycmVudCBuZXh0QmFja29mZiB0aW1lb3V0XHJcbiAgICAgKi9cclxuICAgIHN0YXJ0QmFja29mZigpIHtcclxuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJ1bk9uY2UoKTtcclxuICAgIH1cclxuICAgIHN0b3BCYWNrb2ZmKCkge1xyXG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQuc3RvcCgpO1xyXG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcclxuICAgIH1cclxuICAgIHN0YXJ0Q29ubmVjdGluZ0ludGVybmFsKCkge1xyXG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgIGlmIChvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ10pIHtcclxuICAgICAgICAgICAgY29uc3QgYWRqdXN0ZWRLZWVwYWxpdmVUaW1lID0gTWF0aC5taW4odGhpcy5rZWVwYWxpdmVUaW1lLCBLRUVQQUxJVkVfTUFYX1RJTUVfTVMpO1xyXG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyAnZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyc6IGFkanVzdGVkS2VlcGFsaXZlVGltZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0b3JcclxuICAgICAgICAgICAgLmNvbm5lY3QodGhpcy5zdWJjaGFubmVsQWRkcmVzcywgdGhpcy5jcmVkZW50aWFscywgb3B0aW9ucylcclxuICAgICAgICAgICAgLnRoZW4odHJhbnNwb3J0ID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQodHJhbnNwb3J0LmdldENoYW5uZWx6UmVmKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmFkZERpc2Nvbm5lY3RMaXN0ZW5lcih0b29NYW55UGluZ3MgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb01hbnlQaW5ncyAmJiB0aGlzLmtlZXBhbGl2ZVRpbWUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSAqPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBDb25uZWN0aW9uIHRvICR7KDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy5jaGFubmVsVGFyZ2V0KX0gYXQgJHt0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nfSByZWplY3RlZCBieSBzZXJ2ZXIgYmVjYXVzZSBvZiBleGNlc3MgcGluZ3MuIEluY3JlYXNpbmcgcGluZyBpbnRlcnZhbCB0byAke3RoaXMua2VlcGFsaXZlVGltZX0gbXNgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8qIElmIHdlIGNhbid0IHRyYW5zaXRpb24gZnJvbSBDT05ORUNUSU5HIHRvIFJFQURZIGhlcmUsIHdlIHdpbGxcclxuICAgICAgICAgICAgICAgICAqIG5vdCBiZSB1c2luZyB0aGlzIHRyYW5zcG9ydCwgc28gcmVsZWFzZSBpdHMgcmVzb3VyY2VzLiAqL1xyXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNodXRkb3duKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgYCR7ZXJyb3J9YCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYXRlIGEgc3RhdGUgdHJhbnNpdGlvbiBmcm9tIGFueSBlbGVtZW50IG9mIG9sZFN0YXRlcyB0byB0aGUgbmV3XHJcbiAgICAgKiBzdGF0ZS4gSWYgdGhlIGN1cnJlbnQgY29ubmVjdGl2aXR5U3RhdGUgaXMgbm90IGluIG9sZFN0YXRlcywgZG8gbm90aGluZy5cclxuICAgICAqIEBwYXJhbSBvbGRTdGF0ZXMgVGhlIHNldCBvZiBzdGF0ZXMgdG8gdHJhbnNpdGlvbiBmcm9tXHJcbiAgICAgKiBAcGFyYW0gbmV3U3RhdGUgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG9cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHN0YXRlIGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAgICovXHJcbiAgICB0cmFuc2l0aW9uVG9TdGF0ZShvbGRTdGF0ZXMsIG5ld1N0YXRlLCBlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmIChvbGRTdGF0ZXMuaW5kZXhPZih0aGlzLmNvbm5lY3Rpdml0eVN0YXRlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyYWNlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY29ubmVjdGl2aXR5U3RhdGVdICtcclxuICAgICAgICAgICAgJyAtPiAnICtcclxuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcclxuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UgdG8gJyArIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBuZXdTdGF0ZTtcclxuICAgICAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFk6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BCYWNrb2ZmKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJhY2tvZmYoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW5nSW50ZXJuYWwoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVDb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRTpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCAmJiB0aGlzLnRyYW5zcG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQodGhpcy50cmFuc3BvcnQuZ2V0Q2hhbm5lbHpSZWYoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNodXRkb3duKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgYmFja29mZiB0aW1lciBoYXMgYWxyZWFkeSBlbmRlZCBieSB0aGUgdGltZSB3ZSBnZXQgdG8gdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRSBzdGF0ZSwgd2Ugd2FudCB0byBpbW1lZGlhdGVseSB0cmFuc2l0aW9uIG91dCBvZlxyXG4gICAgICAgICAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUgYXMgdGhvdWdoIHRoZSBiYWNrb2ZmIHRpbWVyIGlzIGVuZGluZyByaWdodCBub3cgKi9cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUJhY2tvZmZUaW1lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCAmJiB0aGlzLnRyYW5zcG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQodGhpcy50cmFuc3BvcnQuZ2V0Q2hhbm5lbHpSZWYoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNodXRkb3duKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0ZTogdW5rbm93biBDb25uZWN0aXZpdHlTdGF0ZSAke25ld1N0YXRlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIHRoaXMua2VlcGFsaXZlVGltZSwgZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZWYoKSB7XHJcbiAgICAgICAgdGhpcy5yZWZUcmFjZSgncmVmY291bnQgJyArIHRoaXMucmVmY291bnQgKyAnIC0+ICcgKyAodGhpcy5yZWZjb3VudCArIDEpKTtcclxuICAgICAgICB0aGlzLnJlZmNvdW50ICs9IDE7XHJcbiAgICB9XHJcbiAgICB1bnJlZigpIHtcclxuICAgICAgICB0aGlzLnJlZlRyYWNlKCdyZWZjb3VudCAnICsgdGhpcy5yZWZjb3VudCArICcgLT4gJyArICh0aGlzLnJlZmNvdW50IC0gMSkpO1xyXG4gICAgICAgIHRoaXMucmVmY291bnQgLT0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWZjb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdTaHV0dGluZyBkb3duJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHRoaXMuY2hhbm5lbHpSZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdW5yZWZJZk9uZVJlZigpIHtcclxuICAgICAgICBpZiAodGhpcy5yZWZjb3VudCA9PT0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLnVucmVmKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDYWxsKG1ldGFkYXRhLCBob3N0LCBtZXRob2QsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRyYW5zcG9ydCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgY2FsbCwgc3ViY2hhbm5lbCBub3QgUkVBRFknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0YXRzVHJhY2tlcjtcclxuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcclxuICAgICAgICAgICAgc3RhdHNUcmFja2VyID0ge1xyXG4gICAgICAgICAgICAgICAgb25DYWxsRW5kOiBzdGF0dXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRzVHJhY2tlciA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuY3JlYXRlQ2FsbChtZXRhZGF0YSwgaG9zdCwgbWV0aG9kLCBsaXN0ZW5lciwgc3RhdHNUcmFja2VyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIHN1YmNoYW5uZWwgaXMgY3VycmVudGx5IElETEUsIHN0YXJ0IGNvbm5lY3RpbmcgYW5kIHN3aXRjaCB0byB0aGVcclxuICAgICAqIENPTk5FQ1RJTkcgc3RhdGUuIElmIHRoZSBzdWJjaGFubmVsIGlzIGN1cnJlbnQgaW4gVFJBTlNJRU5UX0ZBSUxVUkUsXHJcbiAgICAgKiB0aGUgbmV4dCB0aW1lIGl0IHdvdWxkIHRyYW5zaXRpb24gdG8gSURMRSwgc3RhcnQgY29ubmVjdGluZyBhZ2FpbiBpbnN0ZWFkLlxyXG4gICAgICogT3RoZXJ3aXNlLCBkbyBub3RoaW5nLlxyXG4gICAgICovXHJcbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XHJcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICAgICAgICAgIC8qIEZpcnN0LCB0cnkgdG8gdHJhbnNpdGlvbiBmcm9tIElETEUgdG8gY29ubmVjdGluZy4gSWYgdGhhdCBkb2Vzbid0IGhhcHBlblxyXG4gICAgICAgICAgICAgKiBiZWNhdXNlIHRoZSBzdGF0ZSBpcyBub3QgY3VycmVudGx5IElETEUsIGNoZWNrIGlmIGl0IGlzXHJcbiAgICAgICAgICAgICAqIFRSQU5TSUVOVF9GQUlMVVJFLCBhbmQgaWYgc28gaW5kaWNhdGUgdGhhdCBpdCBzaG91bGQgZ28gYmFjayB0b1xyXG4gICAgICAgICAgICAgKiBjb25uZWN0aW5nIGFmdGVyIHRoZSBiYWNrb2ZmIHRpbWVyIGVuZHMuIE90aGVyd2lzZSBkbyBub3RoaW5nICovXHJcbiAgICAgICAgICAgIGlmICghdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlQ29ubmVjdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHN1YmNoYW5uZWwnc1xyXG4gICAgICogY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZXMuXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgcHJldmlvdXNseSBhZGRlZCB3aXRoIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIEEgcmVmZXJlbmNlIHRvIGEgZnVuY3Rpb24gcHJldmlvdXNseSBwYXNzZWQgdG9cclxuICAgICAqICAgICBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGJhY2tvZmYgdGltZW91dCwgYW5kIGltbWVkaWF0ZWx5IHN0YXJ0IGNvbm5lY3RpbmcgaWYgaW4gYmFja29mZi5cclxuICAgICAqL1xyXG4gICAgcmVzZXRCYWNrb2ZmKCkge1xyXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRBZGRyZXNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHpSZWY7XHJcbiAgICB9XHJcbiAgICBnZXRSZWFsU3ViY2hhbm5lbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHJlYWxTdWJjaGFubmVsRXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG90aGVyLmdldFJlYWxTdWJjaGFubmVsKCkgPT09IHRoaXM7XHJcbiAgICB9XHJcbiAgICB0aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKSB7XHJcbiAgICAgICAgaWYgKG5ld0tlZXBhbGl2ZVRpbWUgPiB0aGlzLmtlZXBhbGl2ZVRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lID0gbmV3S2VlcGFsaXZlVGltZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TdWJjaGFubmVsID0gU3ViY2hhbm5lbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/tls-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2019 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.getDefaultRootsData = exports.CIPHER_SUITES = void 0;\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nexports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;\r\nconst DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;\r\nlet defaultRootsData = null;\r\nfunction getDefaultRootsData() {\r\n    if (DEFAULT_ROOTS_FILE_PATH) {\r\n        if (defaultRootsData === null) {\r\n            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);\r\n        }\r\n        return defaultRootsData;\r\n    }\r\n    return null;\r\n}\r\nexports.getDefaultRootsData = getDefaultRootsData;\r\n//# sourceMappingURL=tls-helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxxQkFBcUI7QUFDbkQsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Rscy1oZWxwZXJzLmpzPzkxYjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZ2V0RGVmYXVsdFJvb3RzRGF0YSA9IGV4cG9ydHMuQ0lQSEVSX1NVSVRFUyA9IHZvaWQgMDtcclxuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcbmV4cG9ydHMuQ0lQSEVSX1NVSVRFUyA9IHByb2Nlc3MuZW52LkdSUENfU1NMX0NJUEhFUl9TVUlURVM7XHJcbmNvbnN0IERFRkFVTFRfUk9PVFNfRklMRV9QQVRIID0gcHJvY2Vzcy5lbnYuR1JQQ19ERUZBVUxUX1NTTF9ST09UU19GSUxFX1BBVEg7XHJcbmxldCBkZWZhdWx0Um9vdHNEYXRhID0gbnVsbDtcclxuZnVuY3Rpb24gZ2V0RGVmYXVsdFJvb3RzRGF0YSgpIHtcclxuICAgIGlmIChERUZBVUxUX1JPT1RTX0ZJTEVfUEFUSCkge1xyXG4gICAgICAgIGlmIChkZWZhdWx0Um9vdHNEYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRSb290c0RhdGEgPSBmcy5yZWFkRmlsZVN5bmMoREVGQVVMVF9ST09UU19GSUxFX1BBVEgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmYXVsdFJvb3RzRGF0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmV4cG9ydHMuZ2V0RGVmYXVsdFJvb3RzRGF0YSA9IGdldERlZmF1bHRSb290c0RhdGE7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRscy1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/transport.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/transport.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/*\r\n * Copyright 2023 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Http2SubchannelConnector = void 0;\r\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\r\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\r\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\r\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\r\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\r\nconst logging = __webpack_require__(/*! ./logging */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\r\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\r\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\r\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\r\nconst net = __webpack_require__(/*! net */ \"net\");\r\nconst subchannel_call_1 = __webpack_require__(/*! ./subchannel-call */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\");\r\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(rsc)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\r\nconst TRACER_NAME = 'transport';\r\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\r\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@grpc/grpc-js/package.json\").version);\r\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;\r\nconst KEEPALIVE_TIMEOUT_MS = 20000;\r\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\r\nclass Http2Transport {\r\n    constructor(session, subchannelAddress, options, \r\n    /**\r\n     * Name of the remote server, if it is not the same as the subchannel\r\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\r\n     */\r\n    remoteName) {\r\n        this.session = session;\r\n        this.options = options;\r\n        this.remoteName = remoteName;\r\n        /**\r\n         * The amount of time in between sending pings\r\n         */\r\n        this.keepaliveTimeMs = -1;\r\n        /**\r\n         * The amount of time to wait for an acknowledgement after sending a ping\r\n         */\r\n        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\r\n        /**\r\n         * Timer reference for timeout that indicates when to send the next ping\r\n         */\r\n        this.keepaliveTimerId = null;\r\n        /**\r\n         * Indicates that the keepalive timer ran out while there were no active\r\n         * calls, and a ping should be sent the next time a call starts.\r\n         */\r\n        this.pendingSendKeepalivePing = false;\r\n        /**\r\n         * Timer reference tracking when the most recent ping will be considered lost\r\n         */\r\n        this.keepaliveTimeoutId = null;\r\n        /**\r\n         * Indicates whether keepalive pings should be sent without any active calls\r\n         */\r\n        this.keepaliveWithoutCalls = false;\r\n        this.activeCalls = new Set();\r\n        this.disconnectListeners = [];\r\n        this.disconnectHandled = false;\r\n        this.channelzEnabled = true;\r\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\r\n        this.keepalivesSent = 0;\r\n        this.messagesSent = 0;\r\n        this.messagesReceived = 0;\r\n        this.lastMessageSentTimestamp = null;\r\n        this.lastMessageReceivedTimestamp = null;\r\n        /* Populate subchannelAddressString and channelzRef before doing anything\r\n         * else, because they are used in the trace methods. */\r\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\r\n        if (options['grpc.enable_channelz'] === 0) {\r\n            this.channelzEnabled = false;\r\n        }\r\n        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\r\n        // Build user-agent string.\r\n        this.userAgent = [\r\n            options['grpc.primary_user_agent'],\r\n            `grpc-node-js/${clientVersion}`,\r\n            options['grpc.secondary_user_agent'],\r\n        ]\r\n            .filter(e => e)\r\n            .join(' '); // remove falsey values first\r\n        if ('grpc.keepalive_time_ms' in options) {\r\n            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\r\n        }\r\n        if ('grpc.keepalive_timeout_ms' in options) {\r\n            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\r\n        }\r\n        if ('grpc.keepalive_permit_without_calls' in options) {\r\n            this.keepaliveWithoutCalls =\r\n                options['grpc.keepalive_permit_without_calls'] === 1;\r\n        }\r\n        else {\r\n            this.keepaliveWithoutCalls = false;\r\n        }\r\n        session.once('close', () => {\r\n            this.trace('session closed');\r\n            this.stopKeepalivePings();\r\n            this.handleDisconnect();\r\n        });\r\n        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\r\n            let tooManyPings = false;\r\n            /* See the last paragraph of\r\n             * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\r\n            if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\r\n                opaqueData &&\r\n                opaqueData.equals(tooManyPingsData)) {\r\n                tooManyPings = true;\r\n            }\r\n            this.trace('connection closed by GOAWAY with code ' + errorCode + ' and data ' + (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));\r\n            this.reportDisconnectToOwner(tooManyPings);\r\n        });\r\n        session.once('error', error => {\r\n            /* Do nothing here. Any error should also trigger a close event, which is\r\n             * where we want to handle that.  */\r\n            this.trace('connection closed with error ' + error.message);\r\n        });\r\n        if (logging.isTracerEnabled(TRACER_NAME)) {\r\n            session.on('remoteSettings', (settings) => {\r\n                this.trace('new settings received' +\r\n                    (this.session !== session ? ' on the old connection' : '') +\r\n                    ': ' +\r\n                    JSON.stringify(settings));\r\n            });\r\n            session.on('localSettings', (settings) => {\r\n                this.trace('local settings acknowledged by remote' +\r\n                    (this.session !== session ? ' on the old connection' : '') +\r\n                    ': ' +\r\n                    JSON.stringify(settings));\r\n            });\r\n        }\r\n        /* Start the keepalive timer last, because this can trigger trace logs,\r\n         * which should only happen after everything else is set up. */\r\n        if (this.keepaliveWithoutCalls) {\r\n            this.maybeStartKeepalivePingTimer();\r\n        }\r\n    }\r\n    getChannelzInfo() {\r\n        var _a, _b, _c;\r\n        const sessionSocket = this.session.socket;\r\n        const remoteAddress = sessionSocket.remoteAddress\r\n            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)\r\n            : null;\r\n        const localAddress = sessionSocket.localAddress\r\n            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)\r\n            : null;\r\n        let tlsInfo;\r\n        if (this.session.encrypted) {\r\n            const tlsSocket = sessionSocket;\r\n            const cipherInfo = tlsSocket.getCipher();\r\n            const certificate = tlsSocket.getCertificate();\r\n            const peerCertificate = tlsSocket.getPeerCertificate();\r\n            tlsInfo = {\r\n                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\r\n                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\r\n                localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\r\n                remoteCertificate: peerCertificate && 'raw' in peerCertificate\r\n                    ? peerCertificate.raw\r\n                    : null,\r\n            };\r\n        }\r\n        else {\r\n            tlsInfo = null;\r\n        }\r\n        const socketInfo = {\r\n            remoteAddress: remoteAddress,\r\n            localAddress: localAddress,\r\n            security: tlsInfo,\r\n            remoteName: this.remoteName,\r\n            streamsStarted: this.streamTracker.callsStarted,\r\n            streamsSucceeded: this.streamTracker.callsSucceeded,\r\n            streamsFailed: this.streamTracker.callsFailed,\r\n            messagesSent: this.messagesSent,\r\n            messagesReceived: this.messagesReceived,\r\n            keepAlivesSent: this.keepalivesSent,\r\n            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\r\n            lastRemoteStreamCreatedTimestamp: null,\r\n            lastMessageSentTimestamp: this.lastMessageSentTimestamp,\r\n            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\r\n            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\r\n            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null,\r\n        };\r\n        return socketInfo;\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            this.subchannelAddressString +\r\n            ' ' +\r\n            text);\r\n    }\r\n    keepaliveTrace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            this.subchannelAddressString +\r\n            ' ' +\r\n            text);\r\n    }\r\n    flowControlTrace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            this.subchannelAddressString +\r\n            ' ' +\r\n            text);\r\n    }\r\n    internalsTrace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' +\r\n            this.channelzRef.id +\r\n            ') ' +\r\n            this.subchannelAddressString +\r\n            ' ' +\r\n            text);\r\n    }\r\n    /**\r\n     * Indicate to the owner of this object that this transport should no longer\r\n     * be used. That happens if the connection drops, or if the server sends a\r\n     * GOAWAY.\r\n     * @param tooManyPings If true, this was triggered by a GOAWAY with data\r\n     * indicating that the session was closed becaues the client sent too many\r\n     * pings.\r\n     * @returns\r\n     */\r\n    reportDisconnectToOwner(tooManyPings) {\r\n        if (this.disconnectHandled) {\r\n            return;\r\n        }\r\n        this.disconnectHandled = true;\r\n        this.disconnectListeners.forEach(listener => listener(tooManyPings));\r\n    }\r\n    /**\r\n     * Handle connection drops, but not GOAWAYs.\r\n     */\r\n    handleDisconnect() {\r\n        this.reportDisconnectToOwner(false);\r\n        /* Give calls an event loop cycle to finish naturally before reporting the\r\n         * disconnnection to them. */\r\n        setImmediate(() => {\r\n            for (const call of this.activeCalls) {\r\n                call.onDisconnect();\r\n            }\r\n        });\r\n    }\r\n    addDisconnectListener(listener) {\r\n        this.disconnectListeners.push(listener);\r\n    }\r\n    clearKeepaliveTimer() {\r\n        if (!this.keepaliveTimerId) {\r\n            return;\r\n        }\r\n        clearTimeout(this.keepaliveTimerId);\r\n        this.keepaliveTimerId = null;\r\n    }\r\n    clearKeepaliveTimeout() {\r\n        if (!this.keepaliveTimeoutId) {\r\n            return;\r\n        }\r\n        clearTimeout(this.keepaliveTimeoutId);\r\n        this.keepaliveTimeoutId = null;\r\n    }\r\n    canSendPing() {\r\n        return (this.keepaliveTimeMs > 0 &&\r\n            (this.keepaliveWithoutCalls || this.activeCalls.size > 0));\r\n    }\r\n    maybeSendPing() {\r\n        var _a, _b;\r\n        this.clearKeepaliveTimer();\r\n        if (!this.canSendPing()) {\r\n            this.pendingSendKeepalivePing = true;\r\n            return;\r\n        }\r\n        if (this.channelzEnabled) {\r\n            this.keepalivesSent += 1;\r\n        }\r\n        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\r\n        if (!this.keepaliveTimeoutId) {\r\n            this.keepaliveTimeoutId = setTimeout(() => {\r\n                this.keepaliveTrace('Ping timeout passed without response');\r\n                this.handleDisconnect();\r\n            }, this.keepaliveTimeoutMs);\r\n            (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n        try {\r\n            this.session.ping((err, duration, payload) => {\r\n                if (err) {\r\n                    this.keepaliveTrace('Ping failed with error ' + err.message);\r\n                    this.handleDisconnect();\r\n                }\r\n                this.keepaliveTrace('Received ping response');\r\n                this.clearKeepaliveTimeout();\r\n                this.maybeStartKeepalivePingTimer();\r\n            });\r\n        }\r\n        catch (e) {\r\n            /* If we fail to send a ping, the connection is no longer functional, so\r\n             * we should discard it. */\r\n            this.handleDisconnect();\r\n        }\r\n    }\r\n    /**\r\n     * Starts the keepalive ping timer if appropriate. If the timer already ran\r\n     * out while there were no active requests, instead send a ping immediately.\r\n     * If the ping timer is already running or a ping is currently in flight,\r\n     * instead do nothing and wait for them to resolve.\r\n     */\r\n    maybeStartKeepalivePingTimer() {\r\n        var _a, _b;\r\n        if (!this.canSendPing()) {\r\n            return;\r\n        }\r\n        if (this.pendingSendKeepalivePing) {\r\n            this.pendingSendKeepalivePing = false;\r\n            this.maybeSendPing();\r\n        }\r\n        else if (!this.keepaliveTimerId && !this.keepaliveTimeoutId) {\r\n            this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\r\n            this.keepaliveTimerId = (_b = (_a = setTimeout(() => {\r\n                this.maybeSendPing();\r\n            }, this.keepaliveTimeMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n        /* Otherwise, there is already either a keepalive timer or a ping pending,\r\n         * wait for those to resolve. */\r\n    }\r\n    stopKeepalivePings() {\r\n        if (this.keepaliveTimerId) {\r\n            clearTimeout(this.keepaliveTimerId);\r\n            this.keepaliveTimerId = null;\r\n        }\r\n        this.clearKeepaliveTimeout();\r\n    }\r\n    removeActiveCall(call) {\r\n        this.activeCalls.delete(call);\r\n        if (this.activeCalls.size === 0) {\r\n            this.session.unref();\r\n        }\r\n    }\r\n    addActiveCall(call) {\r\n        this.activeCalls.add(call);\r\n        if (this.activeCalls.size === 1) {\r\n            this.session.ref();\r\n            if (!this.keepaliveWithoutCalls) {\r\n                this.maybeStartKeepalivePingTimer();\r\n            }\r\n        }\r\n    }\r\n    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\r\n        const headers = metadata.toHttp2Headers();\r\n        headers[HTTP2_HEADER_AUTHORITY] = host;\r\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\r\n        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\r\n        headers[HTTP2_HEADER_METHOD] = 'POST';\r\n        headers[HTTP2_HEADER_PATH] = method;\r\n        headers[HTTP2_HEADER_TE] = 'trailers';\r\n        let http2Stream;\r\n        /* In theory, if an error is thrown by session.request because session has\r\n         * become unusable (e.g. because it has received a goaway), this subchannel\r\n         * should soon see the corresponding close or goaway event anyway and leave\r\n         * READY. But we have seen reports that this does not happen\r\n         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\r\n         * so for defense in depth, we just discard the session when we see an\r\n         * error here.\r\n         */\r\n        try {\r\n            http2Stream = this.session.request(headers);\r\n        }\r\n        catch (e) {\r\n            this.handleDisconnect();\r\n            throw e;\r\n        }\r\n        this.flowControlTrace('local window size: ' +\r\n            this.session.state.localWindowSize +\r\n            ' remote window size: ' +\r\n            this.session.state.remoteWindowSize);\r\n        this.internalsTrace('session.closed=' +\r\n            this.session.closed +\r\n            ' session.destroyed=' +\r\n            this.session.destroyed +\r\n            ' session.socket.destroyed=' +\r\n            this.session.socket.destroyed);\r\n        let eventTracker;\r\n        // eslint-disable-next-line prefer-const\r\n        let call;\r\n        if (this.channelzEnabled) {\r\n            this.streamTracker.addCallStarted();\r\n            eventTracker = {\r\n                addMessageSent: () => {\r\n                    var _a;\r\n                    this.messagesSent += 1;\r\n                    this.lastMessageSentTimestamp = new Date();\r\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\r\n                },\r\n                addMessageReceived: () => {\r\n                    var _a;\r\n                    this.messagesReceived += 1;\r\n                    this.lastMessageReceivedTimestamp = new Date();\r\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\r\n                },\r\n                onCallEnd: status => {\r\n                    var _a;\r\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\r\n                    this.removeActiveCall(call);\r\n                },\r\n                onStreamEnd: success => {\r\n                    var _a;\r\n                    if (success) {\r\n                        this.streamTracker.addCallSucceeded();\r\n                    }\r\n                    else {\r\n                        this.streamTracker.addCallFailed();\r\n                    }\r\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            eventTracker = {\r\n                addMessageSent: () => {\r\n                    var _a;\r\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\r\n                },\r\n                addMessageReceived: () => {\r\n                    var _a;\r\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\r\n                },\r\n                onCallEnd: status => {\r\n                    var _a;\r\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\r\n                    this.removeActiveCall(call);\r\n                },\r\n                onStreamEnd: success => {\r\n                    var _a;\r\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\r\n                },\r\n            };\r\n        }\r\n        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\r\n        this.addActiveCall(call);\r\n        return call;\r\n    }\r\n    getChannelzRef() {\r\n        return this.channelzRef;\r\n    }\r\n    getPeerName() {\r\n        return this.subchannelAddressString;\r\n    }\r\n    getOptions() {\r\n        return this.options;\r\n    }\r\n    shutdown() {\r\n        this.session.close();\r\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\r\n    }\r\n}\r\nclass Http2SubchannelConnector {\r\n    constructor(channelTarget) {\r\n        this.channelTarget = channelTarget;\r\n        this.session = null;\r\n        this.isShutdown = false;\r\n    }\r\n    trace(text) {\r\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + ' ' + text);\r\n    }\r\n    createSession(address, credentials, options, proxyConnectionResult) {\r\n        if (this.isShutdown) {\r\n            return Promise.reject();\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            var _a, _b, _c;\r\n            let remoteName;\r\n            if (proxyConnectionResult.realTarget) {\r\n                remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);\r\n                this.trace('creating HTTP/2 session through proxy to ' +\r\n                    (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));\r\n            }\r\n            else {\r\n                remoteName = null;\r\n                this.trace('creating HTTP/2 session to ' + (0, subchannel_address_1.subchannelAddressToString)(address));\r\n            }\r\n            const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\r\n            let connectionOptions = credentials._getConnectionOptions() || {};\r\n            connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\r\n            if ('grpc-node.max_session_memory' in options) {\r\n                connectionOptions.maxSessionMemory =\r\n                    options['grpc-node.max_session_memory'];\r\n            }\r\n            else {\r\n                /* By default, set a very large max session memory limit, to effectively\r\n                 * disable enforcement of the limit. Some testing indicates that Node's\r\n                 * behavior degrades badly when this limit is reached, so we solve that\r\n                 * by disabling the check entirely. */\r\n                connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\r\n            }\r\n            let addressScheme = 'http://';\r\n            if ('secureContext' in connectionOptions) {\r\n                addressScheme = 'https://';\r\n                // If provided, the value of grpc.ssl_target_name_override should be used\r\n                // to override the target hostname when checking server identity.\r\n                // This option is used for testing only.\r\n                if (options['grpc.ssl_target_name_override']) {\r\n                    const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\r\n                    connectionOptions.checkServerIdentity = (host, cert) => {\r\n                        return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\r\n                    };\r\n                    connectionOptions.servername = sslTargetNameOverride;\r\n                }\r\n                else {\r\n                    const authorityHostname = (_c = (_b = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';\r\n                    // We want to always set servername to support SNI\r\n                    connectionOptions.servername = authorityHostname;\r\n                }\r\n                if (proxyConnectionResult.socket) {\r\n                    /* This is part of the workaround for\r\n                     * https://github.com/nodejs/node/issues/32922. Without that bug,\r\n                     * proxyConnectionResult.socket would always be a plaintext socket and\r\n                     * this would say\r\n                     * connectionOptions.socket = proxyConnectionResult.socket; */\r\n                    connectionOptions.createConnection = (authority, option) => {\r\n                        return proxyConnectionResult.socket;\r\n                    };\r\n                }\r\n            }\r\n            else {\r\n                /* In all but the most recent versions of Node, http2.connect does not use\r\n                 * the options when establishing plaintext connections, so we need to\r\n                 * establish that connection explicitly. */\r\n                connectionOptions.createConnection = (authority, option) => {\r\n                    if (proxyConnectionResult.socket) {\r\n                        return proxyConnectionResult.socket;\r\n                    }\r\n                    else {\r\n                        /* net.NetConnectOpts is declared in a way that is more restrictive\r\n                         * than what net.connect will actually accept, so we use the type\r\n                         * assertion to work around that. */\r\n                        return net.connect(address);\r\n                    }\r\n                };\r\n            }\r\n            connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), { enableTrace: options['grpc-node.tls_enable_trace'] === 1 });\r\n            /* http2.connect uses the options here:\r\n             * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\r\n             * The spread operator overides earlier values with later ones, so any port\r\n             * or host values in the options will be used rather than any values extracted\r\n             * from the first argument. In addition, the path overrides the host and port,\r\n             * as documented for plaintext connections here:\r\n             * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\r\n             * and for TLS connections here:\r\n             * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\r\n             * earlier versions of Node, http2.connect passes these options to\r\n             * tls.connect but not net.connect, so in the insecure case we still need\r\n             * to set the createConnection option above to create the connection\r\n             * explicitly. We cannot do that in the TLS case because http2.connect\r\n             * passes necessary additional options to tls.connect.\r\n             * The first argument just needs to be parseable as a URL and the scheme\r\n             * determines whether the connection will be established over TLS or not.\r\n             */\r\n            const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\r\n            this.session = session;\r\n            let errorMessage = 'Failed to connect';\r\n            session.unref();\r\n            session.once('connect', () => {\r\n                session.removeAllListeners();\r\n                resolve(new Http2Transport(session, address, options, remoteName));\r\n                this.session = null;\r\n            });\r\n            session.once('close', () => {\r\n                this.session = null;\r\n                // Leave time for error event to happen before rejecting\r\n                setImmediate(() => {\r\n                    reject(`${errorMessage} (${new Date().toISOString()})`);\r\n                });\r\n            });\r\n            session.once('error', error => {\r\n                errorMessage = error.message;\r\n                this.trace('connection failed with error ' + errorMessage);\r\n            });\r\n        });\r\n    }\r\n    connect(address, credentials, options) {\r\n        var _a, _b;\r\n        if (this.isShutdown) {\r\n            return Promise.reject();\r\n        }\r\n        /* Pass connection options through to the proxy so that it's able to\r\n         * upgrade it's connection to support tls if needed.\r\n         * This is a workaround for https://github.com/nodejs/node/issues/32922\r\n         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\r\n        const connectionOptions = credentials._getConnectionOptions() || {};\r\n        if ('secureContext' in connectionOptions) {\r\n            connectionOptions.ALPNProtocols = ['h2'];\r\n            // If provided, the value of grpc.ssl_target_name_override should be used\r\n            // to override the target hostname when checking server identity.\r\n            // This option is used for testing only.\r\n            if (options['grpc.ssl_target_name_override']) {\r\n                const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\r\n                connectionOptions.checkServerIdentity = (host, cert) => {\r\n                    return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\r\n                };\r\n                connectionOptions.servername = sslTargetNameOverride;\r\n            }\r\n            else {\r\n                if ('grpc.http_connect_target' in options) {\r\n                    /* This is more or less how servername will be set in createSession\r\n                     * if a connection is successfully established through the proxy.\r\n                     * If the proxy is not used, these connectionOptions are discarded\r\n                     * anyway */\r\n                    const targetPath = (0, resolver_1.getDefaultAuthority)((_a = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\r\n                        path: 'localhost',\r\n                    });\r\n                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\r\n                    connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\r\n                }\r\n            }\r\n            if (options['grpc-node.tls_enable_trace']) {\r\n                connectionOptions.enableTrace = true;\r\n            }\r\n        }\r\n        return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then(result => this.createSession(address, credentials, options, result));\r\n    }\r\n    shutdown() {\r\n        var _a;\r\n        this.isShutdown = true;\r\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\r\n        this.session = null;\r\n    }\r\n}\r\nexports.Http2SubchannelConnector = Http2SubchannelConnector;\r\n//# sourceMappingURL=transport.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QiwwQkFBMEIsbUJBQU8sQ0FBQywwRkFBbUI7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMsa0ZBQWU7QUFDN0M7QUFDQTtBQUNBLHNCQUFzQiwwR0FBcUM7QUFDM0QsUUFBUSx1SUFBdUk7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGtDQUFrQywwREFBMEQ7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYyxHQUFHLHlCQUF5QjtBQUN4RSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdHJhbnNwb3J0LmpzPzVhNDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIzIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yID0gdm9pZCAwO1xyXG5jb25zdCBodHRwMiA9IHJlcXVpcmUoXCJodHRwMlwiKTtcclxuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xyXG5jb25zdCBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XHJcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xyXG5jb25zdCBodHRwX3Byb3h5XzEgPSByZXF1aXJlKFwiLi9odHRwX3Byb3h5XCIpO1xyXG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcclxuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xyXG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcclxuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcclxuY29uc3QgbmV0ID0gcmVxdWlyZShcIm5ldFwiKTtcclxuY29uc3Qgc3ViY2hhbm5lbF9jYWxsXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWNhbGxcIik7XHJcbmNvbnN0IGNhbGxfbnVtYmVyXzEgPSByZXF1aXJlKFwiLi9jYWxsLW51bWJlclwiKTtcclxuY29uc3QgVFJBQ0VSX05BTUUgPSAndHJhbnNwb3J0JztcclxuY29uc3QgRkxPV19DT05UUk9MX1RSQUNFUl9OQU1FID0gJ3RyYW5zcG9ydF9mbG93Y3RybCc7XHJcbmNvbnN0IGNsaWVudFZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xyXG5jb25zdCB7IEhUVFAyX0hFQURFUl9BVVRIT1JJVFksIEhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUsIEhUVFAyX0hFQURFUl9NRVRIT0QsIEhUVFAyX0hFQURFUl9QQVRILCBIVFRQMl9IRUFERVJfVEUsIEhUVFAyX0hFQURFUl9VU0VSX0FHRU5ULCB9ID0gaHR0cDIuY29uc3RhbnRzO1xyXG5jb25zdCBLRUVQQUxJVkVfVElNRU9VVF9NUyA9IDIwMDAwO1xyXG5jb25zdCB0b29NYW55UGluZ3NEYXRhID0gQnVmZmVyLmZyb20oJ3Rvb19tYW55X3BpbmdzJywgJ2FzY2lpJyk7XHJcbmNsYXNzIEh0dHAyVHJhbnNwb3J0IHtcclxuICAgIGNvbnN0cnVjdG9yKHNlc3Npb24sIHN1YmNoYW5uZWxBZGRyZXNzLCBvcHRpb25zLCBcclxuICAgIC8qKlxyXG4gICAgICogTmFtZSBvZiB0aGUgcmVtb3RlIHNlcnZlciwgaWYgaXQgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBzdWJjaGFubmVsXHJcbiAgICAgKiBhZGRyZXNzLCBpLmUuIGlmIGNvbm5lY3RpbmcgdGhyb3VnaCBhbiBIVFRQIENPTk5FQ1QgcHJveHkuXHJcbiAgICAgKi9cclxuICAgIHJlbW90ZU5hbWUpIHtcclxuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVOYW1lID0gcmVtb3RlTmFtZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYW1vdW50IG9mIHRpbWUgaW4gYmV0d2VlbiBzZW5kaW5nIHBpbmdzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPSAtMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IGFmdGVyIHNlbmRpbmcgYSBwaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgPSBLRUVQQUxJVkVfVElNRU9VVF9NUztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaW1lciByZWZlcmVuY2UgZm9yIHRpbWVvdXQgdGhhdCBpbmRpY2F0ZXMgd2hlbiB0byBzZW5kIHRoZSBuZXh0IHBpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVySWQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBrZWVwYWxpdmUgdGltZXIgcmFuIG91dCB3aGlsZSB0aGVyZSB3ZXJlIG5vIGFjdGl2ZVxyXG4gICAgICAgICAqIGNhbGxzLCBhbmQgYSBwaW5nIHNob3VsZCBiZSBzZW50IHRoZSBuZXh0IHRpbWUgYSBjYWxsIHN0YXJ0cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdTZW5kS2VlcGFsaXZlUGluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRpbWVyIHJlZmVyZW5jZSB0cmFja2luZyB3aGVuIHRoZSBtb3N0IHJlY2VudCBwaW5nIHdpbGwgYmUgY29uc2lkZXJlZCBsb3N0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGtlZXBhbGl2ZSBwaW5ncyBzaG91bGQgYmUgc2VudCB3aXRob3V0IGFueSBhY3RpdmUgY2FsbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlQ2FsbHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0SGFuZGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVzU2VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlc1NlbnQgPSAwO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZXNSZWNlaXZlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCA9IG51bGw7XHJcbiAgICAgICAgLyogUG9wdWxhdGUgc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgYW5kIGNoYW5uZWx6UmVmIGJlZm9yZSBkb2luZyBhbnl0aGluZ1xyXG4gICAgICAgICAqIGVsc2UsIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbiB0aGUgdHJhY2UgbWV0aG9kcy4gKi9cclxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKHN1YmNoYW5uZWxBZGRyZXNzKTtcclxuICAgICAgICBpZiAob3B0aW9uc1snZ3JwYy5lbmFibGVfY2hhbm5lbHonXSA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCkodGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZywgKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xyXG4gICAgICAgIC8vIEJ1aWxkIHVzZXItYWdlbnQgc3RyaW5nLlxyXG4gICAgICAgIHRoaXMudXNlckFnZW50ID0gW1xyXG4gICAgICAgICAgICBvcHRpb25zWydncnBjLnByaW1hcnlfdXNlcl9hZ2VudCddLFxyXG4gICAgICAgICAgICBgZ3JwYy1ub2RlLWpzLyR7Y2xpZW50VmVyc2lvbn1gLFxyXG4gICAgICAgICAgICBvcHRpb25zWydncnBjLnNlY29uZGFyeV91c2VyX2FnZW50J10sXHJcbiAgICAgICAgXVxyXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSlcclxuICAgICAgICAgICAgLmpvaW4oJyAnKTsgLy8gcmVtb3ZlIGZhbHNleSB2YWx1ZXMgZmlyc3RcclxuICAgICAgICBpZiAoJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPSBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgnZ3JwYy5rZWVwYWxpdmVfdGltZW91dF9tcycgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyA9IG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCdncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscycgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyA9XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscyddID09PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdjbG9zZScsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50cmFjZSgnc2Vzc2lvbiBjbG9zZWQnKTtcclxuICAgICAgICAgICAgdGhpcy5zdG9wS2VlcGFsaXZlUGluZ3MoKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdnb2F3YXknLCAoZXJyb3JDb2RlLCBsYXN0U3RyZWFtSUQsIG9wYXF1ZURhdGEpID0+IHtcclxuICAgICAgICAgICAgbGV0IHRvb01hbnlQaW5ncyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKiBTZWUgdGhlIGxhc3QgcGFyYWdyYXBoIG9mXHJcbiAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0E4LWNsaWVudC1zaWRlLWtlZXBhbGl2ZS5tZCNiYXNpYy1rZWVwYWxpdmUgKi9cclxuICAgICAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE0gJiZcclxuICAgICAgICAgICAgICAgIG9wYXF1ZURhdGEgJiZcclxuICAgICAgICAgICAgICAgIG9wYXF1ZURhdGEuZXF1YWxzKHRvb01hbnlQaW5nc0RhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICB0b29NYW55UGluZ3MgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gY2xvc2VkIGJ5IEdPQVdBWSB3aXRoIGNvZGUgJyArIGVycm9yQ29kZSArICcgYW5kIGRhdGEgJyArIChvcGFxdWVEYXRhID09PSBudWxsIHx8IG9wYXF1ZURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wYXF1ZURhdGEudG9TdHJpbmcoKSkpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcG9ydERpc2Nvbm5lY3RUb093bmVyKHRvb01hbnlQaW5ncyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdlcnJvcicsIGVycm9yID0+IHtcclxuICAgICAgICAgICAgLyogRG8gbm90aGluZyBoZXJlLiBBbnkgZXJyb3Igc2hvdWxkIGFsc28gdHJpZ2dlciBhIGNsb3NlIGV2ZW50LCB3aGljaCBpc1xyXG4gICAgICAgICAgICAgKiB3aGVyZSB3ZSB3YW50IHRvIGhhbmRsZSB0aGF0LiAgKi9cclxuICAgICAgICAgICAgdGhpcy50cmFjZSgnY29ubmVjdGlvbiBjbG9zZWQgd2l0aCBlcnJvciAnICsgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGxvZ2dpbmcuaXNUcmFjZXJFbmFibGVkKFRSQUNFUl9OQU1FKSkge1xyXG4gICAgICAgICAgICBzZXNzaW9uLm9uKCdyZW1vdGVTZXR0aW5ncycsIChzZXR0aW5ncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnbmV3IHNldHRpbmdzIHJlY2VpdmVkJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2Vzc2lvbiAhPT0gc2Vzc2lvbiA/ICcgb24gdGhlIG9sZCBjb25uZWN0aW9uJyA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNlc3Npb24ub24oJ2xvY2FsU2V0dGluZ3MnLCAoc2V0dGluZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2xvY2FsIHNldHRpbmdzIGFja25vd2xlZGdlZCBieSByZW1vdGUnICtcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5zZXNzaW9uICE9PSBzZXNzaW9uID8gJyBvbiB0aGUgb2xkIGNvbm5lY3Rpb24nIDogJycpICtcclxuICAgICAgICAgICAgICAgICAgICAnOiAnICtcclxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogU3RhcnQgdGhlIGtlZXBhbGl2ZSB0aW1lciBsYXN0LCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXIgdHJhY2UgbG9ncyxcclxuICAgICAgICAgKiB3aGljaCBzaG91bGQgb25seSBoYXBwZW4gYWZ0ZXIgZXZlcnl0aGluZyBlbHNlIGlzIHNldCB1cC4gKi9cclxuICAgICAgICBpZiAodGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbm5lbHpJbmZvKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGNvbnN0IHNlc3Npb25Tb2NrZXQgPSB0aGlzLnNlc3Npb24uc29ja2V0O1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZUFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3NcclxuICAgICAgICAgICAgPyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcykoc2Vzc2lvblNvY2tldC5yZW1vdGVBZGRyZXNzLCBzZXNzaW9uU29ja2V0LnJlbW90ZVBvcnQpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICBjb25zdCBsb2NhbEFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzc1xyXG4gICAgICAgICAgICA/ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKShzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzcywgc2Vzc2lvblNvY2tldC5sb2NhbFBvcnQpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICBsZXQgdGxzSW5mbztcclxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLmVuY3J5cHRlZCkge1xyXG4gICAgICAgICAgICBjb25zdCB0bHNTb2NrZXQgPSBzZXNzaW9uU29ja2V0O1xyXG4gICAgICAgICAgICBjb25zdCBjaXBoZXJJbmZvID0gdGxzU29ja2V0LmdldENpcGhlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBjZXJ0aWZpY2F0ZSA9IHRsc1NvY2tldC5nZXRDZXJ0aWZpY2F0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBwZWVyQ2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKCk7XHJcbiAgICAgICAgICAgIHRsc0luZm8gPSB7XHJcbiAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZTogKF9hID0gY2lwaGVySW5mby5zdGFuZGFyZE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZU90aGVyTmFtZTogY2lwaGVySW5mby5zdGFuZGFyZE5hbWUgPyBudWxsIDogY2lwaGVySW5mby5uYW1lLFxyXG4gICAgICAgICAgICAgICAgbG9jYWxDZXJ0aWZpY2F0ZTogY2VydGlmaWNhdGUgJiYgJ3JhdycgaW4gY2VydGlmaWNhdGUgPyBjZXJ0aWZpY2F0ZS5yYXcgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcmVtb3RlQ2VydGlmaWNhdGU6IHBlZXJDZXJ0aWZpY2F0ZSAmJiAncmF3JyBpbiBwZWVyQ2VydGlmaWNhdGVcclxuICAgICAgICAgICAgICAgICAgICA/IHBlZXJDZXJ0aWZpY2F0ZS5yYXdcclxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0bHNJbmZvID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc29ja2V0SW5mbyA9IHtcclxuICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogcmVtb3RlQWRkcmVzcyxcclxuICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbEFkZHJlc3MsXHJcbiAgICAgICAgICAgIHNlY3VyaXR5OiB0bHNJbmZvLFxyXG4gICAgICAgICAgICByZW1vdGVOYW1lOiB0aGlzLnJlbW90ZU5hbWUsXHJcbiAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiB0aGlzLnN0cmVhbVRyYWNrZXIuY2FsbHNTdGFydGVkLFxyXG4gICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiB0aGlzLnN0cmVhbVRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXHJcbiAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IHRoaXMuc3RyZWFtVHJhY2tlci5jYWxsc0ZhaWxlZCxcclxuICAgICAgICAgICAgbWVzc2FnZXNTZW50OiB0aGlzLm1lc3NhZ2VzU2VudCxcclxuICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogdGhpcy5tZXNzYWdlc1JlY2VpdmVkLFxyXG4gICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogdGhpcy5rZWVwYWxpdmVzU2VudCxcclxuICAgICAgICAgICAgbGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogdGhpcy5zdHJlYW1UcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCxcclxuICAgICAgICAgICAgbGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXHJcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcDogdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAsXHJcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXA6IHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCxcclxuICAgICAgICAgICAgbG9jYWxGbG93Q29udHJvbFdpbmRvdzogKF9iID0gdGhpcy5zZXNzaW9uLnN0YXRlLmxvY2FsV2luZG93U2l6ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbCxcclxuICAgICAgICAgICAgcmVtb3RlRmxvd0NvbnRyb2xXaW5kb3c6IChfYyA9IHRoaXMuc2Vzc2lvbi5zdGF0ZS5yZW1vdGVXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHNvY2tldEluZm87XHJcbiAgICB9XHJcbiAgICB0cmFjZSh0ZXh0KSB7XHJcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnKCcgK1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcclxuICAgICAgICAgICAgJykgJyArXHJcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xyXG4gICAgICAgICAgICAnICcgK1xyXG4gICAgICAgICAgICB0ZXh0KTtcclxuICAgIH1cclxuICAgIGtlZXBhbGl2ZVRyYWNlKHRleHQpIHtcclxuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2tlZXBhbGl2ZScsICcoJyArXHJcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xyXG4gICAgICAgICAgICAnKSAnICtcclxuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXHJcbiAgICAgICAgICAgICcgJyArXHJcbiAgICAgICAgICAgIHRleHQpO1xyXG4gICAgfVxyXG4gICAgZmxvd0NvbnRyb2xUcmFjZSh0ZXh0KSB7XHJcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIEZMT1dfQ09OVFJPTF9UUkFDRVJfTkFNRSwgJygnICtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXHJcbiAgICAgICAgICAgICcpICcgK1xyXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcclxuICAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICAgdGV4dCk7XHJcbiAgICB9XHJcbiAgICBpbnRlcm5hbHNUcmFjZSh0ZXh0KSB7XHJcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICd0cmFuc3BvcnRfaW50ZXJuYWxzJywgJygnICtcclxuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXHJcbiAgICAgICAgICAgICcpICcgK1xyXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcclxuICAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICAgdGV4dCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlIHRvIHRoZSBvd25lciBvZiB0aGlzIG9iamVjdCB0aGF0IHRoaXMgdHJhbnNwb3J0IHNob3VsZCBubyBsb25nZXJcclxuICAgICAqIGJlIHVzZWQuIFRoYXQgaGFwcGVucyBpZiB0aGUgY29ubmVjdGlvbiBkcm9wcywgb3IgaWYgdGhlIHNlcnZlciBzZW5kcyBhXHJcbiAgICAgKiBHT0FXQVkuXHJcbiAgICAgKiBAcGFyYW0gdG9vTWFueVBpbmdzIElmIHRydWUsIHRoaXMgd2FzIHRyaWdnZXJlZCBieSBhIEdPQVdBWSB3aXRoIGRhdGFcclxuICAgICAqIGluZGljYXRpbmcgdGhhdCB0aGUgc2Vzc2lvbiB3YXMgY2xvc2VkIGJlY2F1ZXMgdGhlIGNsaWVudCBzZW50IHRvbyBtYW55XHJcbiAgICAgKiBwaW5ncy5cclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIHJlcG9ydERpc2Nvbm5lY3RUb093bmVyKHRvb01hbnlQaW5ncykge1xyXG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RIYW5kbGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0SGFuZGxlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIodG9vTWFueVBpbmdzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBjb25uZWN0aW9uIGRyb3BzLCBidXQgbm90IEdPQVdBWXMuXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZURpc2Nvbm5lY3QoKSB7XHJcbiAgICAgICAgdGhpcy5yZXBvcnREaXNjb25uZWN0VG9Pd25lcihmYWxzZSk7XHJcbiAgICAgICAgLyogR2l2ZSBjYWxscyBhbiBldmVudCBsb29wIGN5Y2xlIHRvIGZpbmlzaCBuYXR1cmFsbHkgYmVmb3JlIHJlcG9ydGluZyB0aGVcclxuICAgICAgICAgKiBkaXNjb25ubmVjdGlvbiB0byB0aGVtLiAqL1xyXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLmFjdGl2ZUNhbGxzKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsLm9uRGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhZGREaXNjb25uZWN0TGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBjbGVhcktlZXBhbGl2ZVRpbWVyKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5rZWVwYWxpdmVUaW1lcklkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMua2VlcGFsaXZlVGltZXJJZCk7XHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lcklkID0gbnVsbDtcclxuICAgIH1cclxuICAgIGNsZWFyS2VlcGFsaXZlVGltZW91dCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMua2VlcGFsaXZlVGltZW91dElkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMua2VlcGFsaXZlVGltZW91dElkKTtcclxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBjYW5TZW5kUGluZygpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMua2VlcGFsaXZlVGltZU1zID4gMCAmJlxyXG4gICAgICAgICAgICAodGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgfHwgdGhpcy5hY3RpdmVDYWxscy5zaXplID4gMCkpO1xyXG4gICAgfVxyXG4gICAgbWF5YmVTZW5kUGluZygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHRoaXMuY2xlYXJLZWVwYWxpdmVUaW1lcigpO1xyXG4gICAgICAgIGlmICghdGhpcy5jYW5TZW5kUGluZygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVzU2VudCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdTZW5kaW5nIHBpbmcgd2l0aCB0aW1lb3V0ICcgKyB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyArICdtcycpO1xyXG4gICAgICAgIGlmICghdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1BpbmcgdGltZW91dCBwYXNzZWQgd2l0aG91dCByZXNwb25zZScpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZW91dE1zKTtcclxuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5waW5nKChlcnIsIGR1cmF0aW9uLCBwYXlsb2FkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyBmYWlsZWQgd2l0aCBlcnJvciAnICsgZXJyLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUmVjZWl2ZWQgcGluZyByZXNwb25zZScpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLyogSWYgd2UgZmFpbCB0byBzZW5kIGEgcGluZywgdGhlIGNvbm5lY3Rpb24gaXMgbm8gbG9uZ2VyIGZ1bmN0aW9uYWwsIHNvXHJcbiAgICAgICAgICAgICAqIHdlIHNob3VsZCBkaXNjYXJkIGl0LiAqL1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyB0aGUga2VlcGFsaXZlIHBpbmcgdGltZXIgaWYgYXBwcm9wcmlhdGUuIElmIHRoZSB0aW1lciBhbHJlYWR5IHJhblxyXG4gICAgICogb3V0IHdoaWxlIHRoZXJlIHdlcmUgbm8gYWN0aXZlIHJlcXVlc3RzLCBpbnN0ZWFkIHNlbmQgYSBwaW5nIGltbWVkaWF0ZWx5LlxyXG4gICAgICogSWYgdGhlIHBpbmcgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIG9yIGEgcGluZyBpcyBjdXJyZW50bHkgaW4gZmxpZ2h0LFxyXG4gICAgICogaW5zdGVhZCBkbyBub3RoaW5nIGFuZCB3YWl0IGZvciB0aGVtIHRvIHJlc29sdmUuXHJcbiAgICAgKi9cclxuICAgIG1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBpZiAoIXRoaXMuY2FuU2VuZFBpbmcoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdTZW5kS2VlcGFsaXZlUGluZykge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTZW5kS2VlcGFsaXZlUGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLm1heWJlU2VuZFBpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMua2VlcGFsaXZlVGltZXJJZCAmJiAhdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnU3RhcnRpbmcga2VlcGFsaXZlIHRpbWVyIGZvciAnICsgdGhpcy5rZWVwYWxpdmVUaW1lTXMgKyAnbXMnKTtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lcklkID0gKF9iID0gKF9hID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlU2VuZFBpbmcoKTtcclxuICAgICAgICAgICAgfSwgdGhpcy5rZWVwYWxpdmVUaW1lTXMpKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBPdGhlcndpc2UsIHRoZXJlIGlzIGFscmVhZHkgZWl0aGVyIGEga2VlcGFsaXZlIHRpbWVyIG9yIGEgcGluZyBwZW5kaW5nLFxyXG4gICAgICAgICAqIHdhaXQgZm9yIHRob3NlIHRvIHJlc29sdmUuICovXHJcbiAgICB9XHJcbiAgICBzdG9wS2VlcGFsaXZlUGluZ3MoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMua2VlcGFsaXZlVGltZXJJZCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5rZWVwYWxpdmVUaW1lcklkKTtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lcklkID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcclxuICAgIH1cclxuICAgIHJlbW92ZUFjdGl2ZUNhbGwoY2FsbCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlQ2FsbHMuZGVsZXRlKGNhbGwpO1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUNhbGxzLnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnVucmVmKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkQWN0aXZlQ2FsbChjYWxsKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVDYWxscy5hZGQoY2FsbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2FsbHMuc2l6ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVmKCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlQ2FsbChtZXRhZGF0YSwgaG9zdCwgbWV0aG9kLCBsaXN0ZW5lciwgc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIpIHtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gbWV0YWRhdGEudG9IdHRwMkhlYWRlcnMoKTtcclxuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9BVVRIT1JJVFldID0gaG9zdDtcclxuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9VU0VSX0FHRU5UXSA9IHRoaXMudXNlckFnZW50O1xyXG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRV0gPSAnYXBwbGljYXRpb24vZ3JwYyc7XHJcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfTUVUSE9EXSA9ICdQT1NUJztcclxuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXSA9IG1ldGhvZDtcclxuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9URV0gPSAndHJhaWxlcnMnO1xyXG4gICAgICAgIGxldCBodHRwMlN0cmVhbTtcclxuICAgICAgICAvKiBJbiB0aGVvcnksIGlmIGFuIGVycm9yIGlzIHRocm93biBieSBzZXNzaW9uLnJlcXVlc3QgYmVjYXVzZSBzZXNzaW9uIGhhc1xyXG4gICAgICAgICAqIGJlY29tZSB1bnVzYWJsZSAoZS5nLiBiZWNhdXNlIGl0IGhhcyByZWNlaXZlZCBhIGdvYXdheSksIHRoaXMgc3ViY2hhbm5lbFxyXG4gICAgICAgICAqIHNob3VsZCBzb29uIHNlZSB0aGUgY29ycmVzcG9uZGluZyBjbG9zZSBvciBnb2F3YXkgZXZlbnQgYW55d2F5IGFuZCBsZWF2ZVxyXG4gICAgICAgICAqIFJFQURZLiBCdXQgd2UgaGF2ZSBzZWVuIHJlcG9ydHMgdGhhdCB0aGlzIGRvZXMgbm90IGhhcHBlblxyXG4gICAgICAgICAqIChodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlYXBpcy9ub2RlanMtZmlyZXN0b3JlL2lzc3Vlcy8xMDIzI2lzc3VlY29tbWVudC02NTMyMDQwOTYpXHJcbiAgICAgICAgICogc28gZm9yIGRlZmVuc2UgaW4gZGVwdGgsIHdlIGp1c3QgZGlzY2FyZCB0aGUgc2Vzc2lvbiB3aGVuIHdlIHNlZSBhblxyXG4gICAgICAgICAqIGVycm9yIGhlcmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaHR0cDJTdHJlYW0gPSB0aGlzLnNlc3Npb24ucmVxdWVzdChoZWFkZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmxvd0NvbnRyb2xUcmFjZSgnbG9jYWwgd2luZG93IHNpemU6ICcgK1xyXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uc3RhdGUubG9jYWxXaW5kb3dTaXplICtcclxuICAgICAgICAgICAgJyByZW1vdGUgd2luZG93IHNpemU6ICcgK1xyXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uc3RhdGUucmVtb3RlV2luZG93U2l6ZSk7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbHNUcmFjZSgnc2Vzc2lvbi5jbG9zZWQ9JyArXHJcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5jbG9zZWQgK1xyXG4gICAgICAgICAgICAnIHNlc3Npb24uZGVzdHJveWVkPScgK1xyXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uZGVzdHJveWVkICtcclxuICAgICAgICAgICAgJyBzZXNzaW9uLnNvY2tldC5kZXN0cm95ZWQ9JyArXHJcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zb2NrZXQuZGVzdHJveWVkKTtcclxuICAgICAgICBsZXQgZXZlbnRUcmFja2VyO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcclxuICAgICAgICBsZXQgY2FsbDtcclxuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XHJcbiAgICAgICAgICAgIGV2ZW50VHJhY2tlciA9IHtcclxuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VTZW50OiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNTZW50ICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLmFkZE1lc3NhZ2VTZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVJlY2VpdmVkOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNSZWNlaXZlZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVJlY2VpdmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25DYWxsRW5kOiBzdGF0dXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5vbkNhbGxFbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLCBzdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlQ2FsbChjYWxsKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvblN0cmVhbUVuZDogc3VjY2VzcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5vblN0cmVhbUVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIsIHN1Y2Nlc3MpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50VHJhY2tlciA9IHtcclxuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VTZW50OiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLmFkZE1lc3NhZ2VTZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVJlY2VpdmVkOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLmFkZE1lc3NhZ2VSZWNlaXZlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uQ2FsbEVuZDogc3RhdHVzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIub25DYWxsRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZUNhbGwoY2FsbCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25TdHJlYW1FbmQ6IHN1Y2Nlc3MgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5vblN0cmVhbUVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIsIHN1Y2Nlc3MpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FsbCA9IG5ldyBzdWJjaGFubmVsX2NhbGxfMS5IdHRwMlN1YmNoYW5uZWxDYWxsKGh0dHAyU3RyZWFtLCBldmVudFRyYWNrZXIsIGxpc3RlbmVyLCB0aGlzLCAoMCwgY2FsbF9udW1iZXJfMS5nZXROZXh0Q2FsbE51bWJlcikoKSk7XHJcbiAgICAgICAgdGhpcy5hZGRBY3RpdmVDYWxsKGNhbGwpO1xyXG4gICAgICAgIHJldHVybiBjYWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHpSZWY7XHJcbiAgICB9XHJcbiAgICBnZXRQZWVyTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZztcclxuICAgIH1cclxuICAgIGdldE9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcclxuICAgIH1cclxuICAgIHNodXRkb3duKCkge1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbi5jbG9zZSgpO1xyXG4gICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxUYXJnZXQpIHtcclxuICAgICAgICB0aGlzLmNoYW5uZWxUYXJnZXQgPSBjaGFubmVsVGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc1NodXRkb3duID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0cmFjZSh0ZXh0KSB7XHJcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLmNoYW5uZWxUYXJnZXQpICsgJyAnICsgdGV4dCk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVTZXNzaW9uKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zLCBwcm94eUNvbm5lY3Rpb25SZXN1bHQpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1NodXRkb3duKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICAgICAgbGV0IHJlbW90ZU5hbWU7XHJcbiAgICAgICAgICAgIGlmIChwcm94eUNvbm5lY3Rpb25SZXN1bHQucmVhbFRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3RlTmFtZSA9ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0aW5nIEhUVFAvMiBzZXNzaW9uIHRocm91Z2ggcHJveHkgdG8gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykocHJveHlDb25uZWN0aW9uUmVzdWx0LnJlYWxUYXJnZXQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlbW90ZU5hbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnY3JlYXRpbmcgSFRUUC8yIHNlc3Npb24gdG8gJyArICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QXV0aG9yaXR5ID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkoKF9hID0gcHJveHlDb25uZWN0aW9uUmVzdWx0LnJlYWxUYXJnZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuY2hhbm5lbFRhcmdldCk7XHJcbiAgICAgICAgICAgIGxldCBjb25uZWN0aW9uT3B0aW9ucyA9IGNyZWRlbnRpYWxzLl9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHx8IHt9O1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5tYXhTZW5kSGVhZGVyQmxvY2tMZW5ndGggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcclxuICAgICAgICAgICAgaWYgKCdncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5JyBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5tYXhTZXNzaW9uTWVtb3J5ID1cclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zWydncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5J107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvKiBCeSBkZWZhdWx0LCBzZXQgYSB2ZXJ5IGxhcmdlIG1heCBzZXNzaW9uIG1lbW9yeSBsaW1pdCwgdG8gZWZmZWN0aXZlbHlcclxuICAgICAgICAgICAgICAgICAqIGRpc2FibGUgZW5mb3JjZW1lbnQgb2YgdGhlIGxpbWl0LiBTb21lIHRlc3RpbmcgaW5kaWNhdGVzIHRoYXQgTm9kZSdzXHJcbiAgICAgICAgICAgICAgICAgKiBiZWhhdmlvciBkZWdyYWRlcyBiYWRseSB3aGVuIHRoaXMgbGltaXQgaXMgcmVhY2hlZCwgc28gd2Ugc29sdmUgdGhhdFxyXG4gICAgICAgICAgICAgICAgICogYnkgZGlzYWJsaW5nIHRoZSBjaGVjayBlbnRpcmVseS4gKi9cclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLm1heFNlc3Npb25NZW1vcnkgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgYWRkcmVzc1NjaGVtZSA9ICdodHRwOi8vJztcclxuICAgICAgICAgICAgaWYgKCdzZWN1cmVDb250ZXh0JyBpbiBjb25uZWN0aW9uT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgYWRkcmVzc1NjaGVtZSA9ICdodHRwczovLyc7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwcm92aWRlZCwgdGhlIHZhbHVlIG9mIGdycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlIHNob3VsZCBiZSB1c2VkXHJcbiAgICAgICAgICAgICAgICAvLyB0byBvdmVycmlkZSB0aGUgdGFyZ2V0IGhvc3RuYW1lIHdoZW4gY2hlY2tpbmcgc2VydmVyIGlkZW50aXR5LlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBvcHRpb24gaXMgdXNlZCBmb3IgdGVzdGluZyBvbmx5LlxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJ10pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzc2xUYXJnZXROYW1lT3ZlcnJpZGUgPSBvcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPSAoaG9zdCwgY2VydCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHRsc18xLmNoZWNrU2VydmVySWRlbnRpdHkpKHNzbFRhcmdldE5hbWVPdmVycmlkZSwgY2VydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gc3NsVGFyZ2V0TmFtZU92ZXJyaWRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXR5SG9zdG5hbWUgPSAoX2MgPSAoX2IgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHRhcmdldEF1dGhvcml0eSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ob3N0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnbG9jYWxob3N0JztcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRvIGFsd2F5cyBzZXQgc2VydmVybmFtZSB0byBzdXBwb3J0IFNOSVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcm5hbWUgPSBhdXRob3JpdHlIb3N0bmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogVGhpcyBpcyBwYXJ0IG9mIHRoZSB3b3JrYXJvdW5kIGZvclxyXG4gICAgICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzI5MjIuIFdpdGhvdXQgdGhhdCBidWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICogcHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldCB3b3VsZCBhbHdheXMgYmUgYSBwbGFpbnRleHQgc29ja2V0IGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIHRoaXMgd291bGQgc2F5XHJcbiAgICAgICAgICAgICAgICAgICAgICogY29ubmVjdGlvbk9wdGlvbnMuc29ja2V0ID0gcHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldDsgKi9cclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jcmVhdGVDb25uZWN0aW9uID0gKGF1dGhvcml0eSwgb3B0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvKiBJbiBhbGwgYnV0IHRoZSBtb3N0IHJlY2VudCB2ZXJzaW9ucyBvZiBOb2RlLCBodHRwMi5jb25uZWN0IGRvZXMgbm90IHVzZVxyXG4gICAgICAgICAgICAgICAgICogdGhlIG9wdGlvbnMgd2hlbiBlc3RhYmxpc2hpbmcgcGxhaW50ZXh0IGNvbm5lY3Rpb25zLCBzbyB3ZSBuZWVkIHRvXHJcbiAgICAgICAgICAgICAgICAgKiBlc3RhYmxpc2ggdGhhdCBjb25uZWN0aW9uIGV4cGxpY2l0bHkuICovXHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jcmVhdGVDb25uZWN0aW9uID0gKGF1dGhvcml0eSwgb3B0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBuZXQuTmV0Q29ubmVjdE9wdHMgaXMgZGVjbGFyZWQgaW4gYSB3YXkgdGhhdCBpcyBtb3JlIHJlc3RyaWN0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoYW4gd2hhdCBuZXQuY29ubmVjdCB3aWxsIGFjdHVhbGx5IGFjY2VwdCwgc28gd2UgdXNlIHRoZSB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGFzc2VydGlvbiB0byB3b3JrIGFyb3VuZCB0aGF0LiAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV0LmNvbm5lY3QoYWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25uZWN0aW9uT3B0aW9ucyksIGFkZHJlc3MpLCB7IGVuYWJsZVRyYWNlOiBvcHRpb25zWydncnBjLW5vZGUudGxzX2VuYWJsZV90cmFjZSddID09PSAxIH0pO1xyXG4gICAgICAgICAgICAvKiBodHRwMi5jb25uZWN0IHVzZXMgdGhlIG9wdGlvbnMgaGVyZTpcclxuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvNzBjMzJhNmQxOTBlMmI1ZDdiOWZmOWQ1YjZhNDU5ZDE0ZThiN2Q1OS9saWIvaW50ZXJuYWwvaHR0cDIvY29yZS5qcyNMMzAyOC1MMzAzNlxyXG4gICAgICAgICAgICAgKiBUaGUgc3ByZWFkIG9wZXJhdG9yIG92ZXJpZGVzIGVhcmxpZXIgdmFsdWVzIHdpdGggbGF0ZXIgb25lcywgc28gYW55IHBvcnRcclxuICAgICAgICAgICAgICogb3IgaG9zdCB2YWx1ZXMgaW4gdGhlIG9wdGlvbnMgd2lsbCBiZSB1c2VkIHJhdGhlciB0aGFuIGFueSB2YWx1ZXMgZXh0cmFjdGVkXHJcbiAgICAgICAgICAgICAqIGZyb20gdGhlIGZpcnN0IGFyZ3VtZW50LiBJbiBhZGRpdGlvbiwgdGhlIHBhdGggb3ZlcnJpZGVzIHRoZSBob3N0IGFuZCBwb3J0LFxyXG4gICAgICAgICAgICAgKiBhcyBkb2N1bWVudGVkIGZvciBwbGFpbnRleHQgY29ubmVjdGlvbnMgaGVyZTpcclxuICAgICAgICAgICAgICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X2Nvbm5lY3Rfb3B0aW9uc19jb25uZWN0bGlzdGVuZXJcclxuICAgICAgICAgICAgICogYW5kIGZvciBUTFMgY29ubmVjdGlvbnMgaGVyZTpcclxuICAgICAgICAgICAgICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90bHMuaHRtbCN0bHNfdGxzX2Nvbm5lY3Rfb3B0aW9uc19jYWxsYmFjay4gSW5cclxuICAgICAgICAgICAgICogZWFybGllciB2ZXJzaW9ucyBvZiBOb2RlLCBodHRwMi5jb25uZWN0IHBhc3NlcyB0aGVzZSBvcHRpb25zIHRvXHJcbiAgICAgICAgICAgICAqIHRscy5jb25uZWN0IGJ1dCBub3QgbmV0LmNvbm5lY3QsIHNvIGluIHRoZSBpbnNlY3VyZSBjYXNlIHdlIHN0aWxsIG5lZWRcclxuICAgICAgICAgICAgICogdG8gc2V0IHRoZSBjcmVhdGVDb25uZWN0aW9uIG9wdGlvbiBhYm92ZSB0byBjcmVhdGUgdGhlIGNvbm5lY3Rpb25cclxuICAgICAgICAgICAgICogZXhwbGljaXRseS4gV2UgY2Fubm90IGRvIHRoYXQgaW4gdGhlIFRMUyBjYXNlIGJlY2F1c2UgaHR0cDIuY29ubmVjdFxyXG4gICAgICAgICAgICAgKiBwYXNzZXMgbmVjZXNzYXJ5IGFkZGl0aW9uYWwgb3B0aW9ucyB0byB0bHMuY29ubmVjdC5cclxuICAgICAgICAgICAgICogVGhlIGZpcnN0IGFyZ3VtZW50IGp1c3QgbmVlZHMgdG8gYmUgcGFyc2VhYmxlIGFzIGEgVVJMIGFuZCB0aGUgc2NoZW1lXHJcbiAgICAgICAgICAgICAqIGRldGVybWluZXMgd2hldGhlciB0aGUgY29ubmVjdGlvbiB3aWxsIGJlIGVzdGFibGlzaGVkIG92ZXIgVExTIG9yIG5vdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBodHRwMi5jb25uZWN0KGFkZHJlc3NTY2hlbWUgKyB0YXJnZXRBdXRob3JpdHksIGNvbm5lY3Rpb25PcHRpb25zKTtcclxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcclxuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdGYWlsZWQgdG8gY29ubmVjdCc7XHJcbiAgICAgICAgICAgIHNlc3Npb24udW5yZWYoKTtcclxuICAgICAgICAgICAgc2Vzc2lvbi5vbmNlKCdjb25uZWN0JywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEh0dHAyVHJhbnNwb3J0KHNlc3Npb24sIGFkZHJlc3MsIG9wdGlvbnMsIHJlbW90ZU5hbWUpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vIExlYXZlIHRpbWUgZm9yIGVycm9yIGV2ZW50IHRvIGhhcHBlbiBiZWZvcmUgcmVqZWN0aW5nXHJcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChgJHtlcnJvck1lc3NhZ2V9ICgke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX0pYCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNlc3Npb24ub25jZSgnZXJyb3InLCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnY29ubmVjdGlvbiBmYWlsZWQgd2l0aCBlcnJvciAnICsgZXJyb3JNZXNzYWdlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25uZWN0KGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBpZiAodGhpcy5pc1NodXRkb3duKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBQYXNzIGNvbm5lY3Rpb24gb3B0aW9ucyB0aHJvdWdoIHRvIHRoZSBwcm94eSBzbyB0aGF0IGl0J3MgYWJsZSB0b1xyXG4gICAgICAgICAqIHVwZ3JhZGUgaXQncyBjb25uZWN0aW9uIHRvIHN1cHBvcnQgdGxzIGlmIG5lZWRlZC5cclxuICAgICAgICAgKiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjkyMlxyXG4gICAgICAgICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjLW5vZGUvcHVsbC8xMzY5IGZvciBtb3JlIGluZm8uICovXHJcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbk9wdGlvbnMgPSBjcmVkZW50aWFscy5fZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKSB8fCB7fTtcclxuICAgICAgICBpZiAoJ3NlY3VyZUNvbnRleHQnIGluIGNvbm5lY3Rpb25PcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLkFMUE5Qcm90b2NvbHMgPSBbJ2gyJ107XHJcbiAgICAgICAgICAgIC8vIElmIHByb3ZpZGVkLCB0aGUgdmFsdWUgb2YgZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUgc2hvdWxkIGJlIHVzZWRcclxuICAgICAgICAgICAgLy8gdG8gb3ZlcnJpZGUgdGhlIHRhcmdldCBob3N0bmFtZSB3aGVuIGNoZWNraW5nIHNlcnZlciBpZGVudGl0eS5cclxuICAgICAgICAgICAgLy8gVGhpcyBvcHRpb24gaXMgdXNlZCBmb3IgdGVzdGluZyBvbmx5LlxyXG4gICAgICAgICAgICBpZiAob3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3NsVGFyZ2V0TmFtZU92ZXJyaWRlID0gb3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXTtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPSAoaG9zdCwgY2VydCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdGxzXzEuY2hlY2tTZXJ2ZXJJZGVudGl0eSkoc3NsVGFyZ2V0TmFtZU92ZXJyaWRlLCBjZXJ0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gc3NsVGFyZ2V0TmFtZU92ZXJyaWRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCdncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnIGluIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGlzIG1vcmUgb3IgbGVzcyBob3cgc2VydmVybmFtZSB3aWxsIGJlIHNldCBpbiBjcmVhdGVTZXNzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICogaWYgYSBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCB0aHJvdWdoIHRoZSBwcm94eS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgcHJveHkgaXMgbm90IHVzZWQsIHRoZXNlIGNvbm5lY3Rpb25PcHRpb25zIGFyZSBkaXNjYXJkZWRcclxuICAgICAgICAgICAgICAgICAgICAgKiBhbnl3YXkgKi9cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkoKF9hID0gKDAsIHVyaV9wYXJzZXJfMS5wYXJzZVVyaSkob3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0J10pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICdsb2NhbGhvc3QnLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXRQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gKF9iID0gaG9zdFBvcnQgPT09IG51bGwgfHwgaG9zdFBvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvc3RQb3J0Lmhvc3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRhcmdldFBhdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMtbm9kZS50bHNfZW5hYmxlX3RyYWNlJ10pIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmVuYWJsZVRyYWNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKDAsIGh0dHBfcHJveHlfMS5nZXRQcm94aWVkQ29ubmVjdGlvbikoYWRkcmVzcywgb3B0aW9ucywgY29ubmVjdGlvbk9wdGlvbnMpLnRoZW4ocmVzdWx0ID0+IHRoaXMuY3JlYXRlU2Vzc2lvbihhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucywgcmVzdWx0KSk7XHJcbiAgICB9XHJcbiAgICBzaHV0ZG93bigpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdGhpcy5pc1NodXRkb3duID0gdHJ1ZTtcclxuICAgICAgICAoX2EgPSB0aGlzLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDb25uZWN0b3IgPSBIdHRwMlN1YmNoYW5uZWxDb25uZWN0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9ydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/uri-parser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/*\r\n * Copyright 2020 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.uriToString = exports.splitHostPort = exports.parseUri = void 0;\r\n/*\r\n * The groups correspond to URI parts as follows:\r\n * 1. scheme\r\n * 2. authority\r\n * 3. path\r\n */\r\nconst URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\r\nfunction parseUri(uriString) {\r\n    const parsedUri = URI_REGEX.exec(uriString);\r\n    if (parsedUri === null) {\r\n        return null;\r\n    }\r\n    return {\r\n        scheme: parsedUri[1],\r\n        authority: parsedUri[2],\r\n        path: parsedUri[3],\r\n    };\r\n}\r\nexports.parseUri = parseUri;\r\nconst NUMBER_REGEX = /^\\d+$/;\r\nfunction splitHostPort(path) {\r\n    if (path.startsWith('[')) {\r\n        const hostEnd = path.indexOf(']');\r\n        if (hostEnd === -1) {\r\n            return null;\r\n        }\r\n        const host = path.substring(1, hostEnd);\r\n        /* Only an IPv6 address should be in bracketed notation, and an IPv6\r\n         * address should have at least one colon */\r\n        if (host.indexOf(':') === -1) {\r\n            return null;\r\n        }\r\n        if (path.length > hostEnd + 1) {\r\n            if (path[hostEnd + 1] === ':') {\r\n                const portString = path.substring(hostEnd + 2);\r\n                if (NUMBER_REGEX.test(portString)) {\r\n                    return {\r\n                        host: host,\r\n                        port: +portString,\r\n                    };\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return {\r\n                host,\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        const splitPath = path.split(':');\r\n        /* Exactly one colon means that this is host:port. Zero colons means that\r\n         * there is no port. And multiple colons means that this is a bare IPv6\r\n         * address with no port */\r\n        if (splitPath.length === 2) {\r\n            if (NUMBER_REGEX.test(splitPath[1])) {\r\n                return {\r\n                    host: splitPath[0],\r\n                    port: +splitPath[1],\r\n                };\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return {\r\n                host: path,\r\n            };\r\n        }\r\n    }\r\n}\r\nexports.splitHostPort = splitHostPort;\r\nfunction uriToString(uri) {\r\n    let result = '';\r\n    if (uri.scheme !== undefined) {\r\n        result += uri.scheme + ':';\r\n    }\r\n    if (uri.authority !== undefined) {\r\n        result += '//' + uri.authority + '/';\r\n    }\r\n    result += uri.path;\r\n    return result;\r\n}\r\nexports.uriToString = uriToString;\r\n//# sourceMappingURL=uri-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdXJpLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLHFCQUFxQixHQUFHLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3JpYy1uZXdzLWFwcC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy91cmktcGFyc2VyLmpzPzlmZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDIwIGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMudXJpVG9TdHJpbmcgPSBleHBvcnRzLnNwbGl0SG9zdFBvcnQgPSBleHBvcnRzLnBhcnNlVXJpID0gdm9pZCAwO1xyXG4vKlxyXG4gKiBUaGUgZ3JvdXBzIGNvcnJlc3BvbmQgdG8gVVJJIHBhcnRzIGFzIGZvbGxvd3M6XHJcbiAqIDEuIHNjaGVtZVxyXG4gKiAyLiBhdXRob3JpdHlcclxuICogMy4gcGF0aFxyXG4gKi9cclxuY29uc3QgVVJJX1JFR0VYID0gL14oPzooW0EtWmEtejAtOSsuLV0rKTopPyg/OlxcL1xcLyhbXi9dKilcXC8pPyguKykkLztcclxuZnVuY3Rpb24gcGFyc2VVcmkodXJpU3RyaW5nKSB7XHJcbiAgICBjb25zdCBwYXJzZWRVcmkgPSBVUklfUkVHRVguZXhlYyh1cmlTdHJpbmcpO1xyXG4gICAgaWYgKHBhcnNlZFVyaSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzY2hlbWU6IHBhcnNlZFVyaVsxXSxcclxuICAgICAgICBhdXRob3JpdHk6IHBhcnNlZFVyaVsyXSxcclxuICAgICAgICBwYXRoOiBwYXJzZWRVcmlbM10sXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucGFyc2VVcmkgPSBwYXJzZVVyaTtcclxuY29uc3QgTlVNQkVSX1JFR0VYID0gL15cXGQrJC87XHJcbmZ1bmN0aW9uIHNwbGl0SG9zdFBvcnQocGF0aCkge1xyXG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnWycpKSB7XHJcbiAgICAgICAgY29uc3QgaG9zdEVuZCA9IHBhdGguaW5kZXhPZignXScpO1xyXG4gICAgICAgIGlmIChob3N0RW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaG9zdCA9IHBhdGguc3Vic3RyaW5nKDEsIGhvc3RFbmQpO1xyXG4gICAgICAgIC8qIE9ubHkgYW4gSVB2NiBhZGRyZXNzIHNob3VsZCBiZSBpbiBicmFja2V0ZWQgbm90YXRpb24sIGFuZCBhbiBJUHY2XHJcbiAgICAgICAgICogYWRkcmVzcyBzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUgY29sb24gKi9cclxuICAgICAgICBpZiAoaG9zdC5pbmRleE9mKCc6JykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiBob3N0RW5kICsgMSkge1xyXG4gICAgICAgICAgICBpZiAocGF0aFtob3N0RW5kICsgMV0gPT09ICc6Jykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9ydFN0cmluZyA9IHBhdGguc3Vic3RyaW5nKGhvc3RFbmQgKyAyKTtcclxuICAgICAgICAgICAgICAgIGlmIChOVU1CRVJfUkVHRVgudGVzdChwb3J0U3RyaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGhvc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6ICtwb3J0U3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaG9zdCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzcGxpdFBhdGggPSBwYXRoLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgLyogRXhhY3RseSBvbmUgY29sb24gbWVhbnMgdGhhdCB0aGlzIGlzIGhvc3Q6cG9ydC4gWmVybyBjb2xvbnMgbWVhbnMgdGhhdFxyXG4gICAgICAgICAqIHRoZXJlIGlzIG5vIHBvcnQuIEFuZCBtdWx0aXBsZSBjb2xvbnMgbWVhbnMgdGhhdCB0aGlzIGlzIGEgYmFyZSBJUHY2XHJcbiAgICAgICAgICogYWRkcmVzcyB3aXRoIG5vIHBvcnQgKi9cclxuICAgICAgICBpZiAoc3BsaXRQYXRoLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBpZiAoTlVNQkVSX1JFR0VYLnRlc3Qoc3BsaXRQYXRoWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0OiBzcGxpdFBhdGhbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogK3NwbGl0UGF0aFsxXSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGhvc3Q6IHBhdGgsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuc3BsaXRIb3N0UG9ydCA9IHNwbGl0SG9zdFBvcnQ7XHJcbmZ1bmN0aW9uIHVyaVRvU3RyaW5nKHVyaSkge1xyXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgaWYgKHVyaS5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJlc3VsdCArPSB1cmkuc2NoZW1lICsgJzonO1xyXG4gICAgfVxyXG4gICAgaWYgKHVyaS5hdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJlc3VsdCArPSAnLy8nICsgdXJpLmF1dGhvcml0eSArICcvJztcclxuICAgIH1cclxuICAgIHJlc3VsdCArPSB1cmkucGF0aDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZXhwb3J0cy51cmlUb1N0cmluZyA9IHVyaVRvU3RyaW5nO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmktcGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/proto-loader/build/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/**\r\n * @license\r\n * Copyright 2018 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = void 0;\r\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(rsc)/./node_modules/lodash.camelcase/index.js\");\r\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(rsc)/./node_modules/protobufjs/index.js\");\r\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(rsc)/./node_modules/protobufjs/ext/descriptor/index.js\");\r\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/@grpc/proto-loader/build/src/util.js\");\r\nconst Long = __webpack_require__(/*! long */ \"(rsc)/./node_modules/long/umd/index.js\");\r\nexports.Long = Long;\r\nfunction isAnyExtension(obj) {\r\n    return ('@type' in obj) && (typeof obj['@type'] === 'string');\r\n}\r\nexports.isAnyExtension = isAnyExtension;\r\nvar IdempotencyLevel;\r\n(function (IdempotencyLevel) {\r\n    IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = \"IDEMPOTENCY_UNKNOWN\";\r\n    IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = \"NO_SIDE_EFFECTS\";\r\n    IdempotencyLevel[\"IDEMPOTENT\"] = \"IDEMPOTENT\";\r\n})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));\r\nconst descriptorOptions = {\r\n    longs: String,\r\n    enums: String,\r\n    bytes: String,\r\n    defaults: true,\r\n    oneofs: true,\r\n    json: true,\r\n};\r\nfunction joinName(baseName, name) {\r\n    if (baseName === '') {\r\n        return name;\r\n    }\r\n    else {\r\n        return baseName + '.' + name;\r\n    }\r\n}\r\nfunction isHandledReflectionObject(obj) {\r\n    return (obj instanceof Protobuf.Service ||\r\n        obj instanceof Protobuf.Type ||\r\n        obj instanceof Protobuf.Enum);\r\n}\r\nfunction isNamespaceBase(obj) {\r\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\r\n}\r\nfunction getAllHandledReflectionObjects(obj, parentName) {\r\n    const objName = joinName(parentName, obj.name);\r\n    if (isHandledReflectionObject(obj)) {\r\n        return [[objName, obj]];\r\n    }\r\n    else {\r\n        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\r\n            return Object.keys(obj.nested)\r\n                .map(name => {\r\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\r\n            })\r\n                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\r\n        }\r\n    }\r\n    return [];\r\n}\r\nfunction createDeserializer(cls, options) {\r\n    return function deserialize(argBuf) {\r\n        return cls.toObject(cls.decode(argBuf), options);\r\n    };\r\n}\r\nfunction createSerializer(cls) {\r\n    return function serialize(arg) {\r\n        if (Array.isArray(arg)) {\r\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\r\n        }\r\n        const message = cls.fromObject(arg);\r\n        return cls.encode(message).finish();\r\n    };\r\n}\r\nfunction mapMethodOptions(options) {\r\n    return (options || []).reduce((obj, item) => {\r\n        for (const [key, value] of Object.entries(item)) {\r\n            switch (key) {\r\n                case 'uninterpreted_option':\r\n                    obj.uninterpreted_option.push(item.uninterpreted_option);\r\n                    break;\r\n                default:\r\n                    obj[key] = value;\r\n            }\r\n        }\r\n        return obj;\r\n    }, {\r\n        deprecated: false,\r\n        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,\r\n        uninterpreted_option: [],\r\n    });\r\n}\r\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\r\n    /* This is only ever called after the corresponding root.resolveAll(), so we\r\n     * can assume that the resolved request and response types are non-null */\r\n    const requestType = method.resolvedRequestType;\r\n    const responseType = method.resolvedResponseType;\r\n    return {\r\n        path: '/' + serviceName + '/' + method.name,\r\n        requestStream: !!method.requestStream,\r\n        responseStream: !!method.responseStream,\r\n        requestSerialize: createSerializer(requestType),\r\n        requestDeserialize: createDeserializer(requestType, options),\r\n        responseSerialize: createSerializer(responseType),\r\n        responseDeserialize: createDeserializer(responseType, options),\r\n        // TODO(murgatroid99): Find a better way to handle this\r\n        originalName: camelCase(method.name),\r\n        requestType: createMessageDefinition(requestType, fileDescriptors),\r\n        responseType: createMessageDefinition(responseType, fileDescriptors),\r\n        options: mapMethodOptions(method.parsedOptions),\r\n    };\r\n}\r\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\r\n    const def = {};\r\n    for (const method of service.methodsArray) {\r\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\r\n    }\r\n    return def;\r\n}\r\nfunction createMessageDefinition(message, fileDescriptors) {\r\n    const messageDescriptor = message.toDescriptor('proto3');\r\n    return {\r\n        format: 'Protocol Buffer 3 DescriptorProto',\r\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\r\n        fileDescriptorProtos: fileDescriptors,\r\n    };\r\n}\r\nfunction createEnumDefinition(enumType, fileDescriptors) {\r\n    const enumDescriptor = enumType.toDescriptor('proto3');\r\n    return {\r\n        format: 'Protocol Buffer 3 EnumDescriptorProto',\r\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\r\n        fileDescriptorProtos: fileDescriptors,\r\n    };\r\n}\r\n/**\r\n * function createDefinition(obj: Protobuf.Service, name: string, options:\r\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\r\n * name: string, options: Options): MessageTypeDefinition; function\r\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\r\n * EnumTypeDefinition;\r\n */\r\nfunction createDefinition(obj, name, options, fileDescriptors) {\r\n    if (obj instanceof Protobuf.Service) {\r\n        return createServiceDefinition(obj, name, options, fileDescriptors);\r\n    }\r\n    else if (obj instanceof Protobuf.Type) {\r\n        return createMessageDefinition(obj, fileDescriptors);\r\n    }\r\n    else if (obj instanceof Protobuf.Enum) {\r\n        return createEnumDefinition(obj, fileDescriptors);\r\n    }\r\n    else {\r\n        throw new Error('Type mismatch in reflection object handling');\r\n    }\r\n}\r\nfunction createPackageDefinition(root, options) {\r\n    const def = {};\r\n    root.resolveAll();\r\n    const descriptorList = root.toDescriptor('proto3').file;\r\n    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\r\n    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\r\n        def[name] = createDefinition(obj, name, options, bufferList);\r\n    }\r\n    return def;\r\n}\r\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\r\n    options = options || {};\r\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\r\n    root.resolveAll();\r\n    return createPackageDefinition(root, options);\r\n}\r\n/**\r\n * Load a .proto file with the specified options.\r\n * @param filename One or multiple file paths to load. Can be an absolute path\r\n *     or relative to an include path.\r\n * @param options.keepCase Preserve field names. The default is to change them\r\n *     to camel case.\r\n * @param options.longs The type that should be used to represent `long` values.\r\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\r\n *     from a library.\r\n * @param options.enums The type that should be used to represent `enum` values.\r\n *     The only valid option is `String`. Defaults to the numeric value.\r\n * @param options.bytes The type that should be used to represent `bytes`\r\n *     values. Valid options are `Array` and `String`. The default is to use\r\n *     `Buffer`.\r\n * @param options.defaults Set default values on output objects. Defaults to\r\n *     `false`.\r\n * @param options.arrays Set empty arrays for missing array values even if\r\n *     `defaults` is `false`. Defaults to `false`.\r\n * @param options.objects Set empty objects for missing object values even if\r\n *     `defaults` is `false`. Defaults to `false`.\r\n * @param options.oneofs Set virtual oneof properties to the present field's\r\n *     name\r\n * @param options.json Represent Infinity and NaN as strings in float fields,\r\n *     and automatically decode google.protobuf.Any values.\r\n * @param options.includeDirs Paths to search for imported `.proto` files.\r\n */\r\nfunction load(filename, options) {\r\n    return (0, util_1.loadProtosWithOptions)(filename, options).then(loadedRoot => {\r\n        return createPackageDefinition(loadedRoot, options);\r\n    });\r\n}\r\nexports.load = load;\r\nfunction loadSync(filename, options) {\r\n    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\r\n    return createPackageDefinition(loadedRoot, options);\r\n}\r\nexports.loadSync = loadSync;\r\nfunction fromJSON(json, options) {\r\n    options = options || {};\r\n    const loadedRoot = Protobuf.Root.fromJSON(json);\r\n    loadedRoot.resolveAll();\r\n    return createPackageDefinition(loadedRoot, options);\r\n}\r\nexports.fromJSON = fromJSON;\r\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\r\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\r\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\r\n}\r\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\r\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\r\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\r\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\r\n}\r\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\r\n(0, util_1.addCommonProtos)();\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDLEdBQUcsdUNBQXVDLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLHdCQUF3QixHQUFHLHNCQUFzQixHQUFHLFlBQVk7QUFDek0sa0JBQWtCLG1CQUFPLENBQUMsd0VBQWtCO0FBQzVDLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMseUVBQVE7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLG9EQUFNO0FBQzNCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELHdCQUF3QixLQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFVBQVU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmljLW5ld3MtYXBwLy4vbm9kZV9tb2R1bGVzL0BncnBjL3Byb3RvLWxvYWRlci9idWlsZC9zcmMvaW5kZXguanM/MjA4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE4IGdSUEMgYXV0aG9ycy5cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCA9IGV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciA9IGV4cG9ydHMuZnJvbUpTT04gPSBleHBvcnRzLmxvYWRTeW5jID0gZXhwb3J0cy5sb2FkID0gZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsID0gZXhwb3J0cy5pc0FueUV4dGVuc2lvbiA9IGV4cG9ydHMuTG9uZyA9IHZvaWQgMDtcclxuY29uc3QgY2FtZWxDYXNlID0gcmVxdWlyZShcImxvZGFzaC5jYW1lbGNhc2VcIik7XHJcbmNvbnN0IFByb3RvYnVmID0gcmVxdWlyZShcInByb3RvYnVmanNcIik7XHJcbmNvbnN0IGRlc2NyaXB0b3IgPSByZXF1aXJlKFwicHJvdG9idWZqcy9leHQvZGVzY3JpcHRvclwiKTtcclxuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcclxuY29uc3QgTG9uZyA9IHJlcXVpcmUoXCJsb25nXCIpO1xyXG5leHBvcnRzLkxvbmcgPSBMb25nO1xyXG5mdW5jdGlvbiBpc0FueUV4dGVuc2lvbihvYmopIHtcclxuICAgIHJldHVybiAoJ0B0eXBlJyBpbiBvYmopICYmICh0eXBlb2Ygb2JqWydAdHlwZSddID09PSAnc3RyaW5nJyk7XHJcbn1cclxuZXhwb3J0cy5pc0FueUV4dGVuc2lvbiA9IGlzQW55RXh0ZW5zaW9uO1xyXG52YXIgSWRlbXBvdGVuY3lMZXZlbDtcclxuKGZ1bmN0aW9uIChJZGVtcG90ZW5jeUxldmVsKSB7XHJcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiSURFTVBPVEVOQ1lfVU5LTk9XTlwiXSA9IFwiSURFTVBPVEVOQ1lfVU5LTk9XTlwiO1xyXG4gICAgSWRlbXBvdGVuY3lMZXZlbFtcIk5PX1NJREVfRUZGRUNUU1wiXSA9IFwiTk9fU0lERV9FRkZFQ1RTXCI7XHJcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiSURFTVBPVEVOVFwiXSA9IFwiSURFTVBPVEVOVFwiO1xyXG59KShJZGVtcG90ZW5jeUxldmVsID0gZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsIHx8IChleHBvcnRzLklkZW1wb3RlbmN5TGV2ZWwgPSB7fSkpO1xyXG5jb25zdCBkZXNjcmlwdG9yT3B0aW9ucyA9IHtcclxuICAgIGxvbmdzOiBTdHJpbmcsXHJcbiAgICBlbnVtczogU3RyaW5nLFxyXG4gICAgYnl0ZXM6IFN0cmluZyxcclxuICAgIGRlZmF1bHRzOiB0cnVlLFxyXG4gICAgb25lb2ZzOiB0cnVlLFxyXG4gICAganNvbjogdHJ1ZSxcclxufTtcclxuZnVuY3Rpb24gam9pbk5hbWUoYmFzZU5hbWUsIG5hbWUpIHtcclxuICAgIGlmIChiYXNlTmFtZSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBiYXNlTmFtZSArICcuJyArIG5hbWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopIHtcclxuICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuU2VydmljZSB8fFxyXG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlR5cGUgfHxcclxuICAgICAgICBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKTtcclxufVxyXG5mdW5jdGlvbiBpc05hbWVzcGFjZUJhc2Uob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuTmFtZXNwYWNlIHx8IG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlJvb3Q7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKG9iaiwgcGFyZW50TmFtZSkge1xyXG4gICAgY29uc3Qgb2JqTmFtZSA9IGpvaW5OYW1lKHBhcmVudE5hbWUsIG9iai5uYW1lKTtcclxuICAgIGlmIChpc0hhbmRsZWRSZWZsZWN0aW9uT2JqZWN0KG9iaikpIHtcclxuICAgICAgICByZXR1cm4gW1tvYmpOYW1lLCBvYmpdXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChpc05hbWVzcGFjZUJhc2Uob2JqKSAmJiB0eXBlb2Ygb2JqLm5lc3RlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iai5uZXN0ZWQpXHJcbiAgICAgICAgICAgICAgICAubWFwKG5hbWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyhvYmoubmVzdGVkW25hbWVdLCBvYmpOYW1lKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yLmNvbmNhdChjdXJyZW50VmFsdWUpLCBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZURlc2VyaWFsaXplcihjbHMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBkZXNlcmlhbGl6ZShhcmdCdWYpIHtcclxuICAgICAgICByZXR1cm4gY2xzLnRvT2JqZWN0KGNscy5kZWNvZGUoYXJnQnVmKSwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6ZXIoY2xzKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VyaWFsaXplKGFyZykge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2VyaWFsaXplIG1lc3NhZ2U6IGV4cGVjdGVkIG9iamVjdCB3aXRoICR7Y2xzLm5hbWV9IHN0cnVjdHVyZSwgZ290IGFycmF5IGluc3RlYWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNscy5mcm9tT2JqZWN0KGFyZyk7XHJcbiAgICAgICAgcmV0dXJuIGNscy5lbmNvZGUobWVzc2FnZSkuZmluaXNoKCk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG1hcE1ldGhvZE9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIChvcHRpb25zIHx8IFtdKS5yZWR1Y2UoKG9iaiwgaXRlbSkgPT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd1bmludGVycHJldGVkX29wdGlvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLnVuaW50ZXJwcmV0ZWRfb3B0aW9uLnB1c2goaXRlbS51bmludGVycHJldGVkX29wdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH0sIHtcclxuICAgICAgICBkZXByZWNhdGVkOiBmYWxzZSxcclxuICAgICAgICBpZGVtcG90ZW5jeV9sZXZlbDogSWRlbXBvdGVuY3lMZXZlbC5JREVNUE9URU5DWV9VTktOT1dOLFxyXG4gICAgICAgIHVuaW50ZXJwcmV0ZWRfb3B0aW9uOiBbXSxcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU1ldGhvZERlZmluaXRpb24obWV0aG9kLCBzZXJ2aWNlTmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XHJcbiAgICAvKiBUaGlzIGlzIG9ubHkgZXZlciBjYWxsZWQgYWZ0ZXIgdGhlIGNvcnJlc3BvbmRpbmcgcm9vdC5yZXNvbHZlQWxsKCksIHNvIHdlXHJcbiAgICAgKiBjYW4gYXNzdW1lIHRoYXQgdGhlIHJlc29sdmVkIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHR5cGVzIGFyZSBub24tbnVsbCAqL1xyXG4gICAgY29uc3QgcmVxdWVzdFR5cGUgPSBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZTtcclxuICAgIGNvbnN0IHJlc3BvbnNlVHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcGF0aDogJy8nICsgc2VydmljZU5hbWUgKyAnLycgKyBtZXRob2QubmFtZSxcclxuICAgICAgICByZXF1ZXN0U3RyZWFtOiAhIW1ldGhvZC5yZXF1ZXN0U3RyZWFtLFxyXG4gICAgICAgIHJlc3BvbnNlU3RyZWFtOiAhIW1ldGhvZC5yZXNwb25zZVN0cmVhbSxcclxuICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBjcmVhdGVTZXJpYWxpemVyKHJlcXVlc3RUeXBlKSxcclxuICAgICAgICByZXF1ZXN0RGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXF1ZXN0VHlwZSwgb3B0aW9ucyksXHJcbiAgICAgICAgcmVzcG9uc2VTZXJpYWxpemU6IGNyZWF0ZVNlcmlhbGl6ZXIocmVzcG9uc2VUeXBlKSxcclxuICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBjcmVhdGVEZXNlcmlhbGl6ZXIocmVzcG9uc2VUeXBlLCBvcHRpb25zKSxcclxuICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzXHJcbiAgICAgICAgb3JpZ2luYWxOYW1lOiBjYW1lbENhc2UobWV0aG9kLm5hbWUpLFxyXG4gICAgICAgIHJlcXVlc3RUeXBlOiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihyZXF1ZXN0VHlwZSwgZmlsZURlc2NyaXB0b3JzKSxcclxuICAgICAgICByZXNwb25zZVR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlc3BvbnNlVHlwZSwgZmlsZURlc2NyaXB0b3JzKSxcclxuICAgICAgICBvcHRpb25zOiBtYXBNZXRob2RPcHRpb25zKG1ldGhvZC5wYXJzZWRPcHRpb25zKSxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2VydmljZURlZmluaXRpb24oc2VydmljZSwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XHJcbiAgICBjb25zdCBkZWYgPSB7fTtcclxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIHNlcnZpY2UubWV0aG9kc0FycmF5KSB7XHJcbiAgICAgICAgZGVmW21ldGhvZC5uYW1lXSA9IGNyZWF0ZU1ldGhvZERlZmluaXRpb24obWV0aG9kLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlZjtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihtZXNzYWdlLCBmaWxlRGVzY3JpcHRvcnMpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2VEZXNjcmlwdG9yID0gbWVzc2FnZS50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmb3JtYXQ6ICdQcm90b2NvbCBCdWZmZXIgMyBEZXNjcmlwdG9yUHJvdG8nLFxyXG4gICAgICAgIHR5cGU6IG1lc3NhZ2VEZXNjcmlwdG9yLiR0eXBlLnRvT2JqZWN0KG1lc3NhZ2VEZXNjcmlwdG9yLCBkZXNjcmlwdG9yT3B0aW9ucyksXHJcbiAgICAgICAgZmlsZURlc2NyaXB0b3JQcm90b3M6IGZpbGVEZXNjcmlwdG9ycyxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRW51bURlZmluaXRpb24oZW51bVR5cGUsIGZpbGVEZXNjcmlwdG9ycykge1xyXG4gICAgY29uc3QgZW51bURlc2NyaXB0b3IgPSBlbnVtVHlwZS50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmb3JtYXQ6ICdQcm90b2NvbCBCdWZmZXIgMyBFbnVtRGVzY3JpcHRvclByb3RvJyxcclxuICAgICAgICB0eXBlOiBlbnVtRGVzY3JpcHRvci4kdHlwZS50b09iamVjdChlbnVtRGVzY3JpcHRvciwgZGVzY3JpcHRvck9wdGlvbnMpLFxyXG4gICAgICAgIGZpbGVEZXNjcmlwdG9yUHJvdG9zOiBmaWxlRGVzY3JpcHRvcnMsXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBmdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuU2VydmljZSwgbmFtZTogc3RyaW5nLCBvcHRpb25zOlxyXG4gKiBPcHRpb25zKTogU2VydmljZURlZmluaXRpb247IGZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5UeXBlLFxyXG4gKiBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IE9wdGlvbnMpOiBNZXNzYWdlVHlwZURlZmluaXRpb247IGZ1bmN0aW9uXHJcbiAqIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5FbnVtLCBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IE9wdGlvbnMpOlxyXG4gKiBFbnVtVHlwZURlZmluaXRpb247XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XHJcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuU2VydmljZSkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2aWNlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5UeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKG9iaiwgZmlsZURlc2NyaXB0b3JzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLkVudW0pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRW51bURlZmluaXRpb24ob2JqLCBmaWxlRGVzY3JpcHRvcnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIG1pc21hdGNoIGluIHJlZmxlY3Rpb24gb2JqZWN0IGhhbmRsaW5nJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUGFja2FnZURlZmluaXRpb24ocm9vdCwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgZGVmID0ge307XHJcbiAgICByb290LnJlc29sdmVBbGwoKTtcclxuICAgIGNvbnN0IGRlc2NyaXB0b3JMaXN0ID0gcm9vdC50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpLmZpbGU7XHJcbiAgICBjb25zdCBidWZmZXJMaXN0ID0gZGVzY3JpcHRvckxpc3QubWFwKHZhbHVlID0+IEJ1ZmZlci5mcm9tKGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JQcm90by5lbmNvZGUodmFsdWUpLmZpbmlzaCgpKSk7XHJcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBvYmpdIG9mIGdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyhyb290LCAnJykpIHtcclxuICAgICAgICBkZWZbbmFtZV0gPSBjcmVhdGVEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgYnVmZmVyTGlzdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVmO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgY29uc3Qgcm9vdCA9IFByb3RvYnVmLlJvb3QuZnJvbURlc2NyaXB0b3IoZGVjb2RlZERlc2NyaXB0b3JTZXQpO1xyXG4gICAgcm9vdC5yZXNvbHZlQWxsKCk7XHJcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24ocm9vdCwgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIExvYWQgYSAucHJvdG8gZmlsZSB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy5cclxuICogQHBhcmFtIGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlIHBhdGhzIHRvIGxvYWQuIENhbiBiZSBhbiBhYnNvbHV0ZSBwYXRoXHJcbiAqICAgICBvciByZWxhdGl2ZSB0byBhbiBpbmNsdWRlIHBhdGguXHJcbiAqIEBwYXJhbSBvcHRpb25zLmtlZXBDYXNlIFByZXNlcnZlIGZpZWxkIG5hbWVzLiBUaGUgZGVmYXVsdCBpcyB0byBjaGFuZ2UgdGhlbVxyXG4gKiAgICAgdG8gY2FtZWwgY2FzZS5cclxuICogQHBhcmFtIG9wdGlvbnMubG9uZ3MgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGxvbmdgIHZhbHVlcy5cclxuICogICAgIFZhbGlkIG9wdGlvbnMgYXJlIGBOdW1iZXJgIGFuZCBgU3RyaW5nYC4gRGVmYXVsdHMgdG8gYSBgTG9uZ2Agb2JqZWN0IHR5cGVcclxuICogICAgIGZyb20gYSBsaWJyYXJ5LlxyXG4gKiBAcGFyYW0gb3B0aW9ucy5lbnVtcyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgZW51bWAgdmFsdWVzLlxyXG4gKiAgICAgVGhlIG9ubHkgdmFsaWQgb3B0aW9uIGlzIGBTdHJpbmdgLiBEZWZhdWx0cyB0byB0aGUgbnVtZXJpYyB2YWx1ZS5cclxuICogQHBhcmFtIG9wdGlvbnMuYnl0ZXMgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGJ5dGVzYFxyXG4gKiAgICAgdmFsdWVzLiBWYWxpZCBvcHRpb25zIGFyZSBgQXJyYXlgIGFuZCBgU3RyaW5nYC4gVGhlIGRlZmF1bHQgaXMgdG8gdXNlXHJcbiAqICAgICBgQnVmZmVyYC5cclxuICogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdHMgU2V0IGRlZmF1bHQgdmFsdWVzIG9uIG91dHB1dCBvYmplY3RzLiBEZWZhdWx0cyB0b1xyXG4gKiAgICAgYGZhbHNlYC5cclxuICogQHBhcmFtIG9wdGlvbnMuYXJyYXlzIFNldCBlbXB0eSBhcnJheXMgZm9yIG1pc3NpbmcgYXJyYXkgdmFsdWVzIGV2ZW4gaWZcclxuICogICAgIGBkZWZhdWx0c2AgaXMgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cclxuICogQHBhcmFtIG9wdGlvbnMub2JqZWN0cyBTZXQgZW1wdHkgb2JqZWN0cyBmb3IgbWlzc2luZyBvYmplY3QgdmFsdWVzIGV2ZW4gaWZcclxuICogICAgIGBkZWZhdWx0c2AgaXMgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cclxuICogQHBhcmFtIG9wdGlvbnMub25lb2ZzIFNldCB2aXJ0dWFsIG9uZW9mIHByb3BlcnRpZXMgdG8gdGhlIHByZXNlbnQgZmllbGQnc1xyXG4gKiAgICAgbmFtZVxyXG4gKiBAcGFyYW0gb3B0aW9ucy5qc29uIFJlcHJlc2VudCBJbmZpbml0eSBhbmQgTmFOIGFzIHN0cmluZ3MgaW4gZmxvYXQgZmllbGRzLFxyXG4gKiAgICAgYW5kIGF1dG9tYXRpY2FsbHkgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5BbnkgdmFsdWVzLlxyXG4gKiBAcGFyYW0gb3B0aW9ucy5pbmNsdWRlRGlycyBQYXRocyB0byBzZWFyY2ggZm9yIGltcG9ydGVkIGAucHJvdG9gIGZpbGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9hZChmaWxlbmFtZSwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuICgwLCB1dGlsXzEubG9hZFByb3Rvc1dpdGhPcHRpb25zKShmaWxlbmFtZSwgb3B0aW9ucykudGhlbihsb2FkZWRSb290ID0+IHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmxvYWQgPSBsb2FkO1xyXG5mdW5jdGlvbiBsb2FkU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgbG9hZGVkUm9vdCA9ICgwLCB1dGlsXzEubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYykoZmlsZW5hbWUsIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xyXG59XHJcbmV4cG9ydHMubG9hZFN5bmMgPSBsb2FkU3luYztcclxuZnVuY3Rpb24gZnJvbUpTT04oanNvbiwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBjb25zdCBsb2FkZWRSb290ID0gUHJvdG9idWYuUm9vdC5mcm9tSlNPTihqc29uKTtcclxuICAgIGxvYWRlZFJvb3QucmVzb2x2ZUFsbCgpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xyXG59XHJcbmV4cG9ydHMuZnJvbUpTT04gPSBmcm9tSlNPTjtcclxuZnVuY3Rpb24gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlcihkZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBkZWNvZGVkRGVzY3JpcHRvclNldCA9IGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JTZXQuZGVjb2RlKGRlc2NyaXB0b3JTZXQpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpO1xyXG59XHJcbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciA9IGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXI7XHJcbmZ1bmN0aW9uIGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QoZGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgZGVjb2RlZERlc2NyaXB0b3JTZXQgPSBkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yU2V0LmZyb21PYmplY3QoZGVzY3JpcHRvclNldCk7XHJcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucyk7XHJcbn1cclxuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0ID0gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdDtcclxuKDAsIHV0aWxfMS5hZGRDb21tb25Qcm90b3MpKCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/proto-loader/build/src/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n/**\r\n * @license\r\n * Copyright 2018 gRPC authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(rsc)/./node_modules/protobufjs/index.js\");\r\nfunction addIncludePathResolver(root, includePaths) {\r\n    const originalResolvePath = root.resolvePath;\r\n    root.resolvePath = (origin, target) => {\r\n        if (path.isAbsolute(target)) {\r\n            return target;\r\n        }\r\n        for (const directory of includePaths) {\r\n            const fullPath = path.join(directory, target);\r\n            try {\r\n                fs.accessSync(fullPath, fs.constants.R_OK);\r\n                return fullPath;\r\n            }\r\n            catch (err) {\r\n                continue;\r\n            }\r\n        }\r\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\r\n        return originalResolvePath(origin, target);\r\n    };\r\n}\r\nasync function loadProtosWithOptions(filename, options) {\r\n    const root = new Protobuf.Root();\r\n    options = options || {};\r\n    if (!!options.includeDirs) {\r\n        if (!Array.isArray(options.includeDirs)) {\r\n            return Promise.reject(new Error('The includeDirs option must be an array'));\r\n        }\r\n        addIncludePathResolver(root, options.includeDirs);\r\n    }\r\n    const loadedRoot = await root.load(filename, options);\r\n    loadedRoot.resolveAll();\r\n    return loadedRoot;\r\n}\r\nexports.loadProtosWithOptions = loadProtosWithOptions;\r\nfunction loadProtosWithOptionsSync(filename, options) {\r\n    const root = new Protobuf.Root();\r\n    options = options || {};\r\n    if (!!options.includeDirs) {\r\n        if (!Array.isArray(options.includeDirs)) {\r\n            throw new Error('The includeDirs option must be an array');\r\n        }\r\n        addIncludePathResolver(root, options.includeDirs);\r\n    }\r\n    const loadedRoot = root.loadSync(filename, options);\r\n    loadedRoot.resolveAll();\r\n    return loadedRoot;\r\n}\r\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\r\n/**\r\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\r\n */\r\nfunction addCommonProtos() {\r\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\r\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\r\n    // Using constant strings for compatibility with tools like Webpack\r\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/api.json\");\r\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/descriptor.json\");\r\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/source_context.json\");\r\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(rsc)/./node_modules/protobufjs/google/protobuf/type.json\");\r\n    Protobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);\r\n    Protobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);\r\n    Protobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);\r\n    Protobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);\r\n}\r\nexports.addCommonProtos = addCommonProtos;\r\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxpQ0FBaUMsR0FBRyw2QkFBNkI7QUFDM0YsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVEsd0NBQXdDLGFBQWE7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBcUM7QUFDdkUsaUNBQWlDLG1CQUFPLENBQUMsbUhBQTRDO0FBQ3JGLG9DQUFvQyxtQkFBTyxDQUFDLDJIQUFnRDtBQUM1RiwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBc0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NyaWMtbmV3cy1hcHAvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzPzM0YzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOCBnUlBDIGF1dGhvcnMuXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmFkZENvbW1vblByb3RvcyA9IGV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyA9IGV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zID0gdm9pZCAwO1xyXG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5jb25zdCBQcm90b2J1ZiA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzXCIpO1xyXG5mdW5jdGlvbiBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIGluY2x1ZGVQYXRocykge1xyXG4gICAgY29uc3Qgb3JpZ2luYWxSZXNvbHZlUGF0aCA9IHJvb3QucmVzb2x2ZVBhdGg7XHJcbiAgICByb290LnJlc29sdmVQYXRoID0gKG9yaWdpbiwgdGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgaWYgKHBhdGguaXNBYnNvbHV0ZSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgZGlyZWN0b3J5IG9mIGluY2x1ZGVQYXRocykge1xyXG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnksIHRhcmdldCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmcy5hY2Nlc3NTeW5jKGZ1bGxQYXRoLCBmcy5jb25zdGFudHMuUl9PSyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbFBhdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgJHt0YXJnZXR9IG5vdCBmb3VuZCBpbiBhbnkgb2YgdGhlIGluY2x1ZGUgcGF0aHMgJHtpbmNsdWRlUGF0aHN9YCk7XHJcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVzb2x2ZVBhdGgob3JpZ2luLCB0YXJnZXQpO1xyXG4gICAgfTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBsb2FkUHJvdG9zV2l0aE9wdGlvbnMoZmlsZW5hbWUsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHJvb3QgPSBuZXcgUHJvdG9idWYuUm9vdCgpO1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBpZiAoISFvcHRpb25zLmluY2x1ZGVEaXJzKSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZURpcnMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkSW5jbHVkZVBhdGhSZXNvbHZlcihyb290LCBvcHRpb25zLmluY2x1ZGVEaXJzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSBhd2FpdCByb290LmxvYWQoZmlsZW5hbWUsIG9wdGlvbnMpO1xyXG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XHJcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcclxufVxyXG5leHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9ucyA9IGxvYWRQcm90b3NXaXRoT3B0aW9ucztcclxuZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xyXG4gICAgY29uc3Qgcm9vdCA9IG5ldyBQcm90b2J1Zi5Sb290KCk7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIGlmICghIW9wdGlvbnMuaW5jbHVkZURpcnMpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlRGlycykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jbHVkZURpcnMgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkSW5jbHVkZVBhdGhSZXNvbHZlcihyb290LCBvcHRpb25zLmluY2x1ZGVEaXJzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSByb290LmxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKTtcclxuICAgIGxvYWRlZFJvb3QucmVzb2x2ZUFsbCgpO1xyXG4gICAgcmV0dXJuIGxvYWRlZFJvb3Q7XHJcbn1cclxuZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jID0gbG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYztcclxuLyoqXHJcbiAqIExvYWQgR29vZ2xlJ3Mgd2VsbC1rbm93biBwcm90byBmaWxlcyB0aGF0IGFyZW4ndCBleHBvc2VkIGJ5IFByb3RvYnVmLmpzLlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQ29tbW9uUHJvdG9zKCkge1xyXG4gICAgLy8gUHJvdG9idWYuanMgZXhwb3NlczogYW55LCBkdXJhdGlvbiwgZW1wdHksIGZpZWxkX21hc2ssIHN0cnVjdCwgdGltZXN0YW1wLFxyXG4gICAgLy8gYW5kIHdyYXBwZXJzLiBjb21waWxlci9wbHVnaW4gaXMgZXhjbHVkZWQgaW4gUHJvdG9idWYuanMgYW5kIGhlcmUuXHJcbiAgICAvLyBVc2luZyBjb25zdGFudCBzdHJpbmdzIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdG9vbHMgbGlrZSBXZWJwYWNrXHJcbiAgICBjb25zdCBhcGlEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvYXBpLmpzb24nKTtcclxuICAgIGNvbnN0IGRlc2NyaXB0b3JEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvci5qc29uJyk7XHJcbiAgICBjb25zdCBzb3VyY2VDb250ZXh0RGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL3NvdXJjZV9jb250ZXh0Lmpzb24nKTtcclxuICAgIGNvbnN0IHR5cGVEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvdHlwZS5qc29uJyk7XHJcbiAgICBQcm90b2J1Zi5jb21tb24oJ2FwaScsIGFwaURlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcclxuICAgIFByb3RvYnVmLmNvbW1vbignZGVzY3JpcHRvcicsIGRlc2NyaXB0b3JEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XHJcbiAgICBQcm90b2J1Zi5jb21tb24oJ3NvdXJjZV9jb250ZXh0Jywgc291cmNlQ29udGV4dERlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcclxuICAgIFByb3RvYnVmLmNvbW1vbigndHlwZScsIHR5cGVEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XHJcbn1cclxuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBhZGRDb21tb25Qcm90b3M7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@grpc/grpc-js/package.json":
/*!*************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/package.json ***!
  \*************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@grpc/grpc-js","version":"1.9.15","description":"gRPC Library for Node - pure JS implementation","homepage":"https://grpc.io/","repository":"https://github.com/grpc/grpc-node/tree/master/packages/grpc-js","main":"build/src/index.js","engines":{"node":"^8.13.0 || >=10.10.0"},"keywords":[],"author":{"name":"Google Inc."},"types":"build/src/index.d.ts","license":"Apache-2.0","devDependencies":{"@types/gulp":"^4.0.6","@types/gulp-mocha":"0.0.32","@types/lodash":"^4.14.186","@types/mocha":"^5.2.6","@types/ncp":"^2.0.1","@types/pify":"^3.0.2","@types/semver":"^7.3.9","@typescript-eslint/eslint-plugin":"^5.59.11","@typescript-eslint/parser":"^5.59.11","@typescript-eslint/typescript-estree":"^5.59.11","clang-format":"^1.0.55","eslint":"^8.42.0","eslint-config-prettier":"^8.8.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^4.2.1","execa":"^2.0.3","gulp":"^4.0.2","gulp-mocha":"^6.0.0","lodash":"^4.17.4","madge":"^5.0.1","mocha-jenkins-reporter":"^0.4.1","ncp":"^2.0.0","pify":"^4.0.1","prettier":"^2.8.8","rimraf":"^3.0.2","semver":"^7.3.5","ts-node":"^10.9.1","typescript":"^5.1.3"},"contributors":[{"name":"Google Inc."}],"scripts":{"build":"npm run compile","clean":"rimraf ./build","compile":"tsc -p .","format":"clang-format -i -style=\\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\\" src/*.ts test/*.ts","lint":"eslint src/*.ts test/*.ts","prepare":"npm run generate-types && npm run compile","test":"gulp test","check":"npm run lint","fix":"eslint --fix src/*.ts test/*.ts","pretest":"npm run generate-types && npm run generate-test-types && npm run compile","posttest":"npm run check && madge -c ./build/src","generate-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto","generate-test-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"},"dependencies":{"@grpc/proto-loader":"^0.7.8","@types/node":">=12.12.47"},"files":["src/**/*.ts","build/src/**/*.{js,d.ts,js.map}","proto/*.proto","LICENSE","deps/envoy-api/envoy/api/v2/**/*.proto","deps/envoy-api/envoy/config/**/*.proto","deps/envoy-api/envoy/service/**/*.proto","deps/envoy-api/envoy/type/**/*.proto","deps/udpa/udpa/**/*.proto","deps/googleapis/google/api/*.proto","deps/googleapis/google/rpc/*.proto","deps/protoc-gen-validate/validate/**/*.proto"]}');

/***/ })

};
;